{"version":3,"sources":["metisMenu.min.js","chart.js","backend.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpyWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"backend-version.js","sourcesContent":["/*\n * metismenu - v1.1.3\n * Easy menu jQuery plugin for Twitter Bootstrap 3\n * https://github.com/onokumus/metisMenu\n *\n * Made by Osman Nuri Okumus\n * Under MIT License\n */\n!function(a,b,c){function d(b,c){this.element=a(b),this.settings=a.extend({},f,c),this._defaults=f,this._name=e,this.init()}var e=\"metisMenu\",f={toggle:!0,doubleTapToGo:!1};d.prototype={init:function(){var b=this.element,d=this.settings.toggle,f=this;this.isIE()<=9?(b.find(\"li.active\").has(\"ul\").children(\"ul\").collapse(\"show\"),b.find(\"li\").not(\".active\").has(\"ul\").children(\"ul\").collapse(\"hide\")):(b.find(\"li.active\").has(\"ul\").children(\"ul\").addClass(\"collapse in\"),b.find(\"li\").not(\".active\").has(\"ul\").children(\"ul\").addClass(\"collapse\")),f.settings.doubleTapToGo&&b.find(\"li.active\").has(\"ul\").children(\"a\").addClass(\"doubleTapToGo\"),b.find(\"li\").has(\"ul\").children(\"a\").on(\"click.\"+e,function(b){return b.preventDefault(),f.settings.doubleTapToGo&&f.doubleTapToGo(a(this))&&\"#\"!==a(this).attr(\"href\")&&\"\"!==a(this).attr(\"href\")?(b.stopPropagation(),void(c.location=a(this).attr(\"href\"))):(a(this).parent(\"li\").toggleClass(\"active\").children(\"ul\").collapse(\"toggle\"),void(d&&a(this).parent(\"li\").siblings().removeClass(\"active\").children(\"ul.in\").collapse(\"hide\")))})},isIE:function(){for(var a,b=3,d=c.createElement(\"div\"),e=d.getElementsByTagName(\"i\");d.innerHTML=\"<!--[if gt IE \"+ ++b+\"]><i></i><![endif]-->\",e[0];)return b>4?b:a},doubleTapToGo:function(a){var b=this.element;return a.hasClass(\"doubleTapToGo\")?(a.removeClass(\"doubleTapToGo\"),!0):a.parent().children(\"ul\").length?(b.find(\".doubleTapToGo\").removeClass(\"doubleTapToGo\"),a.addClass(\"doubleTapToGo\"),!1):void 0},remove:function(){this.element.off(\".\"+e),this.element.removeData(e)}},a.fn[e]=function(b){return this.each(function(){var c=a(this);c.data(e)&&c.data(e).remove(),c.data(e,new d(this,b))}),this}}(jQuery,window,document);","/*!\r\n * Chart.js\r\n * http://chartjs.org/\r\n * Version: 2.4.0\r\n *\r\n * Copyright 2016 Nick Downie\r\n * Released under the MIT license\r\n * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md\r\n */\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\r\n\r\n},{}],2:[function(require,module,exports){\r\n    /* MIT license */\r\n    var colorNames = require(6);\r\n\r\n    module.exports = {\r\n        getRgba: getRgba,\r\n        getHsla: getHsla,\r\n        getRgb: getRgb,\r\n        getHsl: getHsl,\r\n        getHwb: getHwb,\r\n        getAlpha: getAlpha,\r\n\r\n        hexString: hexString,\r\n        rgbString: rgbString,\r\n        rgbaString: rgbaString,\r\n        percentString: percentString,\r\n        percentaString: percentaString,\r\n        hslString: hslString,\r\n        hslaString: hslaString,\r\n        hwbString: hwbString,\r\n        keyword: keyword\r\n    }\r\n\r\n    function getRgba(string) {\r\n        if (!string) {\r\n            return;\r\n        }\r\n        var abbr =  /^#([a-fA-F0-9]{3})$/,\r\n            hex =  /^#([a-fA-F0-9]{6})$/,\r\n            rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\r\n            per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\r\n            keyword = /(\\w+)/;\r\n\r\n        var rgb = [0, 0, 0],\r\n            a = 1,\r\n            match = string.match(abbr);\r\n        if (match) {\r\n            match = match[1];\r\n            for (var i = 0; i < rgb.length; i++) {\r\n                rgb[i] = parseInt(match[i] + match[i], 16);\r\n            }\r\n        }\r\n        else if (match = string.match(hex)) {\r\n            match = match[1];\r\n            for (var i = 0; i < rgb.length; i++) {\r\n                rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\r\n            }\r\n        }\r\n        else if (match = string.match(rgba)) {\r\n            for (var i = 0; i < rgb.length; i++) {\r\n                rgb[i] = parseInt(match[i + 1]);\r\n            }\r\n            a = parseFloat(match[4]);\r\n        }\r\n        else if (match = string.match(per)) {\r\n            for (var i = 0; i < rgb.length; i++) {\r\n                rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\r\n            }\r\n            a = parseFloat(match[4]);\r\n        }\r\n        else if (match = string.match(keyword)) {\r\n            if (match[1] == \"transparent\") {\r\n                return [0, 0, 0, 0];\r\n            }\r\n            rgb = colorNames[match[1]];\r\n            if (!rgb) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        for (var i = 0; i < rgb.length; i++) {\r\n            rgb[i] = scale(rgb[i], 0, 255);\r\n        }\r\n        if (!a && a != 0) {\r\n            a = 1;\r\n        }\r\n        else {\r\n            a = scale(a, 0, 1);\r\n        }\r\n        rgb[3] = a;\r\n        return rgb;\r\n    }\r\n\r\n    function getHsla(string) {\r\n        if (!string) {\r\n            return;\r\n        }\r\n        var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n        var match = string.match(hsl);\r\n        if (match) {\r\n            var alpha = parseFloat(match[4]);\r\n            var h = scale(parseInt(match[1]), 0, 360),\r\n                s = scale(parseFloat(match[2]), 0, 100),\r\n                l = scale(parseFloat(match[3]), 0, 100),\r\n                a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n            return [h, s, l, a];\r\n        }\r\n    }\r\n\r\n    function getHwb(string) {\r\n        if (!string) {\r\n            return;\r\n        }\r\n        var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\r\n        var match = string.match(hwb);\r\n        if (match) {\r\n            var alpha = parseFloat(match[4]);\r\n            var h = scale(parseInt(match[1]), 0, 360),\r\n                w = scale(parseFloat(match[2]), 0, 100),\r\n                b = scale(parseFloat(match[3]), 0, 100),\r\n                a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\r\n            return [h, w, b, a];\r\n        }\r\n    }\r\n\r\n    function getRgb(string) {\r\n        var rgba = getRgba(string);\r\n        return rgba && rgba.slice(0, 3);\r\n    }\r\n\r\n    function getHsl(string) {\r\n        var hsla = getHsla(string);\r\n        return hsla && hsla.slice(0, 3);\r\n    }\r\n\r\n    function getAlpha(string) {\r\n        var vals = getRgba(string);\r\n        if (vals) {\r\n            return vals[3];\r\n        }\r\n        else if (vals = getHsla(string)) {\r\n            return vals[3];\r\n        }\r\n        else if (vals = getHwb(string)) {\r\n            return vals[3];\r\n        }\r\n    }\r\n\r\n// generators\r\n    function hexString(rgb) {\r\n        return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\r\n            + hexDouble(rgb[2]);\r\n    }\r\n\r\n    function rgbString(rgba, alpha) {\r\n        if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n            return rgbaString(rgba, alpha);\r\n        }\r\n        return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\r\n    }\r\n\r\n    function rgbaString(rgba, alpha) {\r\n        if (alpha === undefined) {\r\n            alpha = (rgba[3] !== undefined ? rgba[3] : 1);\r\n        }\r\n        return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\r\n            + \", \" + alpha + \")\";\r\n    }\r\n\r\n    function percentString(rgba, alpha) {\r\n        if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\r\n            return percentaString(rgba, alpha);\r\n        }\r\n        var r = Math.round(rgba[0]/255 * 100),\r\n            g = Math.round(rgba[1]/255 * 100),\r\n            b = Math.round(rgba[2]/255 * 100);\r\n\r\n        return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\r\n    }\r\n\r\n    function percentaString(rgba, alpha) {\r\n        var r = Math.round(rgba[0]/255 * 100),\r\n            g = Math.round(rgba[1]/255 * 100),\r\n            b = Math.round(rgba[2]/255 * 100);\r\n        return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\r\n    }\r\n\r\n    function hslString(hsla, alpha) {\r\n        if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\r\n            return hslaString(hsla, alpha);\r\n        }\r\n        return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\r\n    }\r\n\r\n    function hslaString(hsla, alpha) {\r\n        if (alpha === undefined) {\r\n            alpha = (hsla[3] !== undefined ? hsla[3] : 1);\r\n        }\r\n        return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\r\n            + alpha + \")\";\r\n    }\r\n\r\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\r\n// (hwb have alpha optional & 1 is default value)\r\n    function hwbString(hwb, alpha) {\r\n        if (alpha === undefined) {\r\n            alpha = (hwb[3] !== undefined ? hwb[3] : 1);\r\n        }\r\n        return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\r\n            + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\r\n    }\r\n\r\n    function keyword(rgb) {\r\n        return reverseNames[rgb.slice(0, 3)];\r\n    }\r\n\r\n// helpers\r\n    function scale(num, min, max) {\r\n        return Math.min(Math.max(min, num), max);\r\n    }\r\n\r\n    function hexDouble(num) {\r\n        var str = num.toString(16).toUpperCase();\r\n        return (str.length < 2) ? \"0\" + str : str;\r\n    }\r\n\r\n\r\n//create a list of reverse color names\r\n    var reverseNames = {};\r\n    for (var name in colorNames) {\r\n        reverseNames[colorNames[name]] = name;\r\n    }\r\n\r\n},{\"6\":6}],3:[function(require,module,exports){\r\n    /* MIT license */\r\n    var convert = require(5);\r\n    var string = require(2);\r\n\r\n    var Color = function (obj) {\r\n        if (obj instanceof Color) {\r\n            return obj;\r\n        }\r\n        if (!(this instanceof Color)) {\r\n            return new Color(obj);\r\n        }\r\n\r\n        this.values = {\r\n            rgb: [0, 0, 0],\r\n            hsl: [0, 0, 0],\r\n            hsv: [0, 0, 0],\r\n            hwb: [0, 0, 0],\r\n            cmyk: [0, 0, 0, 0],\r\n            alpha: 1\r\n        };\r\n\r\n        // parse Color() argument\r\n        var vals;\r\n        if (typeof obj === 'string') {\r\n            vals = string.getRgba(obj);\r\n            if (vals) {\r\n                this.setValues('rgb', vals);\r\n            } else if (vals = string.getHsla(obj)) {\r\n                this.setValues('hsl', vals);\r\n            } else if (vals = string.getHwb(obj)) {\r\n                this.setValues('hwb', vals);\r\n            } else {\r\n                throw new Error('Unable to parse color from string \"' + obj + '\"');\r\n            }\r\n        } else if (typeof obj === 'object') {\r\n            vals = obj;\r\n            if (vals.r !== undefined || vals.red !== undefined) {\r\n                this.setValues('rgb', vals);\r\n            } else if (vals.l !== undefined || vals.lightness !== undefined) {\r\n                this.setValues('hsl', vals);\r\n            } else if (vals.v !== undefined || vals.value !== undefined) {\r\n                this.setValues('hsv', vals);\r\n            } else if (vals.w !== undefined || vals.whiteness !== undefined) {\r\n                this.setValues('hwb', vals);\r\n            } else if (vals.c !== undefined || vals.cyan !== undefined) {\r\n                this.setValues('cmyk', vals);\r\n            } else {\r\n                throw new Error('Unable to parse color from object ' + JSON.stringify(obj));\r\n            }\r\n        }\r\n    };\r\n\r\n    Color.prototype = {\r\n        rgb: function () {\r\n            return this.setSpace('rgb', arguments);\r\n        },\r\n        hsl: function () {\r\n            return this.setSpace('hsl', arguments);\r\n        },\r\n        hsv: function () {\r\n            return this.setSpace('hsv', arguments);\r\n        },\r\n        hwb: function () {\r\n            return this.setSpace('hwb', arguments);\r\n        },\r\n        cmyk: function () {\r\n            return this.setSpace('cmyk', arguments);\r\n        },\r\n\r\n        rgbArray: function () {\r\n            return this.values.rgb;\r\n        },\r\n        hslArray: function () {\r\n            return this.values.hsl;\r\n        },\r\n        hsvArray: function () {\r\n            return this.values.hsv;\r\n        },\r\n        hwbArray: function () {\r\n            var values = this.values;\r\n            if (values.alpha !== 1) {\r\n                return values.hwb.concat([values.alpha]);\r\n            }\r\n            return values.hwb;\r\n        },\r\n        cmykArray: function () {\r\n            return this.values.cmyk;\r\n        },\r\n        rgbaArray: function () {\r\n            var values = this.values;\r\n            return values.rgb.concat([values.alpha]);\r\n        },\r\n        hslaArray: function () {\r\n            var values = this.values;\r\n            return values.hsl.concat([values.alpha]);\r\n        },\r\n        alpha: function (val) {\r\n            if (val === undefined) {\r\n                return this.values.alpha;\r\n            }\r\n            this.setValues('alpha', val);\r\n            return this;\r\n        },\r\n\r\n        red: function (val) {\r\n            return this.setChannel('rgb', 0, val);\r\n        },\r\n        green: function (val) {\r\n            return this.setChannel('rgb', 1, val);\r\n        },\r\n        blue: function (val) {\r\n            return this.setChannel('rgb', 2, val);\r\n        },\r\n        hue: function (val) {\r\n            if (val) {\r\n                val %= 360;\r\n                val = val < 0 ? 360 + val : val;\r\n            }\r\n            return this.setChannel('hsl', 0, val);\r\n        },\r\n        saturation: function (val) {\r\n            return this.setChannel('hsl', 1, val);\r\n        },\r\n        lightness: function (val) {\r\n            return this.setChannel('hsl', 2, val);\r\n        },\r\n        saturationv: function (val) {\r\n            return this.setChannel('hsv', 1, val);\r\n        },\r\n        whiteness: function (val) {\r\n            return this.setChannel('hwb', 1, val);\r\n        },\r\n        blackness: function (val) {\r\n            return this.setChannel('hwb', 2, val);\r\n        },\r\n        value: function (val) {\r\n            return this.setChannel('hsv', 2, val);\r\n        },\r\n        cyan: function (val) {\r\n            return this.setChannel('cmyk', 0, val);\r\n        },\r\n        magenta: function (val) {\r\n            return this.setChannel('cmyk', 1, val);\r\n        },\r\n        yellow: function (val) {\r\n            return this.setChannel('cmyk', 2, val);\r\n        },\r\n        black: function (val) {\r\n            return this.setChannel('cmyk', 3, val);\r\n        },\r\n\r\n        hexString: function () {\r\n            return string.hexString(this.values.rgb);\r\n        },\r\n        rgbString: function () {\r\n            return string.rgbString(this.values.rgb, this.values.alpha);\r\n        },\r\n        rgbaString: function () {\r\n            return string.rgbaString(this.values.rgb, this.values.alpha);\r\n        },\r\n        percentString: function () {\r\n            return string.percentString(this.values.rgb, this.values.alpha);\r\n        },\r\n        hslString: function () {\r\n            return string.hslString(this.values.hsl, this.values.alpha);\r\n        },\r\n        hslaString: function () {\r\n            return string.hslaString(this.values.hsl, this.values.alpha);\r\n        },\r\n        hwbString: function () {\r\n            return string.hwbString(this.values.hwb, this.values.alpha);\r\n        },\r\n        keyword: function () {\r\n            return string.keyword(this.values.rgb, this.values.alpha);\r\n        },\r\n\r\n        rgbNumber: function () {\r\n            var rgb = this.values.rgb;\r\n            return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\r\n        },\r\n\r\n        luminosity: function () {\r\n            // http://www.w3.org/TR/WCAG20/#relativeluminancedef\r\n            var rgb = this.values.rgb;\r\n            var lum = [];\r\n            for (var i = 0; i < rgb.length; i++) {\r\n                var chan = rgb[i] / 255;\r\n                lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\r\n            }\r\n            return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\r\n        },\r\n\r\n        contrast: function (color2) {\r\n            // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\r\n            var lum1 = this.luminosity();\r\n            var lum2 = color2.luminosity();\r\n            if (lum1 > lum2) {\r\n                return (lum1 + 0.05) / (lum2 + 0.05);\r\n            }\r\n            return (lum2 + 0.05) / (lum1 + 0.05);\r\n        },\r\n\r\n        level: function (color2) {\r\n            var contrastRatio = this.contrast(color2);\r\n            if (contrastRatio >= 7.1) {\r\n                return 'AAA';\r\n            }\r\n\r\n            return (contrastRatio >= 4.5) ? 'AA' : '';\r\n        },\r\n\r\n        dark: function () {\r\n            // YIQ equation from http://24ways.org/2010/calculating-color-contrast\r\n            var rgb = this.values.rgb;\r\n            var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\r\n            return yiq < 128;\r\n        },\r\n\r\n        light: function () {\r\n            return !this.dark();\r\n        },\r\n\r\n        negate: function () {\r\n            var rgb = [];\r\n            for (var i = 0; i < 3; i++) {\r\n                rgb[i] = 255 - this.values.rgb[i];\r\n            }\r\n            this.setValues('rgb', rgb);\r\n            return this;\r\n        },\r\n\r\n        lighten: function (ratio) {\r\n            var hsl = this.values.hsl;\r\n            hsl[2] += hsl[2] * ratio;\r\n            this.setValues('hsl', hsl);\r\n            return this;\r\n        },\r\n\r\n        darken: function (ratio) {\r\n            var hsl = this.values.hsl;\r\n            hsl[2] -= hsl[2] * ratio;\r\n            this.setValues('hsl', hsl);\r\n            return this;\r\n        },\r\n\r\n        saturate: function (ratio) {\r\n            var hsl = this.values.hsl;\r\n            hsl[1] += hsl[1] * ratio;\r\n            this.setValues('hsl', hsl);\r\n            return this;\r\n        },\r\n\r\n        desaturate: function (ratio) {\r\n            var hsl = this.values.hsl;\r\n            hsl[1] -= hsl[1] * ratio;\r\n            this.setValues('hsl', hsl);\r\n            return this;\r\n        },\r\n\r\n        whiten: function (ratio) {\r\n            var hwb = this.values.hwb;\r\n            hwb[1] += hwb[1] * ratio;\r\n            this.setValues('hwb', hwb);\r\n            return this;\r\n        },\r\n\r\n        blacken: function (ratio) {\r\n            var hwb = this.values.hwb;\r\n            hwb[2] += hwb[2] * ratio;\r\n            this.setValues('hwb', hwb);\r\n            return this;\r\n        },\r\n\r\n        greyscale: function () {\r\n            var rgb = this.values.rgb;\r\n            // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\r\n            var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\r\n            this.setValues('rgb', [val, val, val]);\r\n            return this;\r\n        },\r\n\r\n        clearer: function (ratio) {\r\n            var alpha = this.values.alpha;\r\n            this.setValues('alpha', alpha - (alpha * ratio));\r\n            return this;\r\n        },\r\n\r\n        opaquer: function (ratio) {\r\n            var alpha = this.values.alpha;\r\n            this.setValues('alpha', alpha + (alpha * ratio));\r\n            return this;\r\n        },\r\n\r\n        rotate: function (degrees) {\r\n            var hsl = this.values.hsl;\r\n            var hue = (hsl[0] + degrees) % 360;\r\n            hsl[0] = hue < 0 ? 360 + hue : hue;\r\n            this.setValues('hsl', hsl);\r\n            return this;\r\n        },\r\n\r\n        /**\r\n         * Ported from sass implementation in C\r\n         * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\r\n         */\r\n        mix: function (mixinColor, weight) {\r\n            var color1 = this;\r\n            var color2 = mixinColor;\r\n            var p = weight === undefined ? 0.5 : weight;\r\n\r\n            var w = 2 * p - 1;\r\n            var a = color1.alpha() - color2.alpha();\r\n\r\n            var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\r\n            var w2 = 1 - w1;\r\n\r\n            return this\r\n                .rgb(\r\n                    w1 * color1.red() + w2 * color2.red(),\r\n                    w1 * color1.green() + w2 * color2.green(),\r\n                    w1 * color1.blue() + w2 * color2.blue()\r\n                )\r\n                .alpha(color1.alpha() * p + color2.alpha() * (1 - p));\r\n        },\r\n\r\n        toJSON: function () {\r\n            return this.rgb();\r\n        },\r\n\r\n        clone: function () {\r\n            // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\r\n            // making the final build way to big to embed in Chart.js. So let's do it manually,\r\n            // assuming that values to clone are 1 dimension arrays containing only numbers,\r\n            // except 'alpha' which is a number.\r\n            var result = new Color();\r\n            var source = this.values;\r\n            var target = result.values;\r\n            var value, type;\r\n\r\n            for (var prop in source) {\r\n                if (source.hasOwnProperty(prop)) {\r\n                    value = source[prop];\r\n                    type = ({}).toString.call(value);\r\n                    if (type === '[object Array]') {\r\n                        target[prop] = value.slice(0);\r\n                    } else if (type === '[object Number]') {\r\n                        target[prop] = value;\r\n                    } else {\r\n                        console.error('unexpected color value:', value);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    };\r\n\r\n    Color.prototype.spaces = {\r\n        rgb: ['red', 'green', 'blue'],\r\n        hsl: ['hue', 'saturation', 'lightness'],\r\n        hsv: ['hue', 'saturation', 'value'],\r\n        hwb: ['hue', 'whiteness', 'blackness'],\r\n        cmyk: ['cyan', 'magenta', 'yellow', 'black']\r\n    };\r\n\r\n    Color.prototype.maxes = {\r\n        rgb: [255, 255, 255],\r\n        hsl: [360, 100, 100],\r\n        hsv: [360, 100, 100],\r\n        hwb: [360, 100, 100],\r\n        cmyk: [100, 100, 100, 100]\r\n    };\r\n\r\n    Color.prototype.getValues = function (space) {\r\n        var values = this.values;\r\n        var vals = {};\r\n\r\n        for (var i = 0; i < space.length; i++) {\r\n            vals[space.charAt(i)] = values[space][i];\r\n        }\r\n\r\n        if (values.alpha !== 1) {\r\n            vals.a = values.alpha;\r\n        }\r\n\r\n        // {r: 255, g: 255, b: 255, a: 0.4}\r\n        return vals;\r\n    };\r\n\r\n    Color.prototype.setValues = function (space, vals) {\r\n        var values = this.values;\r\n        var spaces = this.spaces;\r\n        var maxes = this.maxes;\r\n        var alpha = 1;\r\n        var i;\r\n\r\n        if (space === 'alpha') {\r\n            alpha = vals;\r\n        } else if (vals.length) {\r\n            // [10, 10, 10]\r\n            values[space] = vals.slice(0, space.length);\r\n            alpha = vals[space.length];\r\n        } else if (vals[space.charAt(0)] !== undefined) {\r\n            // {r: 10, g: 10, b: 10}\r\n            for (i = 0; i < space.length; i++) {\r\n                values[space][i] = vals[space.charAt(i)];\r\n            }\r\n\r\n            alpha = vals.a;\r\n        } else if (vals[spaces[space][0]] !== undefined) {\r\n            // {red: 10, green: 10, blue: 10}\r\n            var chans = spaces[space];\r\n\r\n            for (i = 0; i < space.length; i++) {\r\n                values[space][i] = vals[chans[i]];\r\n            }\r\n\r\n            alpha = vals.alpha;\r\n        }\r\n\r\n        values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\r\n\r\n        if (space === 'alpha') {\r\n            return false;\r\n        }\r\n\r\n        var capped;\r\n\r\n        // cap values of the space prior converting all values\r\n        for (i = 0; i < space.length; i++) {\r\n            capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\r\n            values[space][i] = Math.round(capped);\r\n        }\r\n\r\n        // convert to all the other color spaces\r\n        for (var sname in spaces) {\r\n            if (sname !== space) {\r\n                values[sname] = convert[space][sname](values[space]);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    Color.prototype.setSpace = function (space, args) {\r\n        var vals = args[0];\r\n\r\n        if (vals === undefined) {\r\n            // color.rgb()\r\n            return this.getValues(space);\r\n        }\r\n\r\n        // color.rgb(10, 10, 10)\r\n        if (typeof vals === 'number') {\r\n            vals = Array.prototype.slice.call(args);\r\n        }\r\n\r\n        this.setValues(space, vals);\r\n        return this;\r\n    };\r\n\r\n    Color.prototype.setChannel = function (space, index, val) {\r\n        var svalues = this.values[space];\r\n        if (val === undefined) {\r\n            // color.red()\r\n            return svalues[index];\r\n        } else if (val === svalues[index]) {\r\n            // color.red(color.red())\r\n            return this;\r\n        }\r\n\r\n        // color.red(100)\r\n        svalues[index] = val;\r\n        this.setValues(space, svalues);\r\n\r\n        return this;\r\n    };\r\n\r\n    if (typeof window !== 'undefined') {\r\n        window.Color = Color;\r\n    }\r\n\r\n    module.exports = Color;\r\n\r\n},{\"2\":2,\"5\":5}],4:[function(require,module,exports){\r\n    /* MIT license */\r\n\r\n    module.exports = {\r\n        rgb2hsl: rgb2hsl,\r\n        rgb2hsv: rgb2hsv,\r\n        rgb2hwb: rgb2hwb,\r\n        rgb2cmyk: rgb2cmyk,\r\n        rgb2keyword: rgb2keyword,\r\n        rgb2xyz: rgb2xyz,\r\n        rgb2lab: rgb2lab,\r\n        rgb2lch: rgb2lch,\r\n\r\n        hsl2rgb: hsl2rgb,\r\n        hsl2hsv: hsl2hsv,\r\n        hsl2hwb: hsl2hwb,\r\n        hsl2cmyk: hsl2cmyk,\r\n        hsl2keyword: hsl2keyword,\r\n\r\n        hsv2rgb: hsv2rgb,\r\n        hsv2hsl: hsv2hsl,\r\n        hsv2hwb: hsv2hwb,\r\n        hsv2cmyk: hsv2cmyk,\r\n        hsv2keyword: hsv2keyword,\r\n\r\n        hwb2rgb: hwb2rgb,\r\n        hwb2hsl: hwb2hsl,\r\n        hwb2hsv: hwb2hsv,\r\n        hwb2cmyk: hwb2cmyk,\r\n        hwb2keyword: hwb2keyword,\r\n\r\n        cmyk2rgb: cmyk2rgb,\r\n        cmyk2hsl: cmyk2hsl,\r\n        cmyk2hsv: cmyk2hsv,\r\n        cmyk2hwb: cmyk2hwb,\r\n        cmyk2keyword: cmyk2keyword,\r\n\r\n        keyword2rgb: keyword2rgb,\r\n        keyword2hsl: keyword2hsl,\r\n        keyword2hsv: keyword2hsv,\r\n        keyword2hwb: keyword2hwb,\r\n        keyword2cmyk: keyword2cmyk,\r\n        keyword2lab: keyword2lab,\r\n        keyword2xyz: keyword2xyz,\r\n\r\n        xyz2rgb: xyz2rgb,\r\n        xyz2lab: xyz2lab,\r\n        xyz2lch: xyz2lch,\r\n\r\n        lab2xyz: lab2xyz,\r\n        lab2rgb: lab2rgb,\r\n        lab2lch: lab2lch,\r\n\r\n        lch2lab: lch2lab,\r\n        lch2xyz: lch2xyz,\r\n        lch2rgb: lch2rgb\r\n    }\r\n\r\n\r\n    function rgb2hsl(rgb) {\r\n        var r = rgb[0]/255,\r\n            g = rgb[1]/255,\r\n            b = rgb[2]/255,\r\n            min = Math.min(r, g, b),\r\n            max = Math.max(r, g, b),\r\n            delta = max - min,\r\n            h, s, l;\r\n\r\n        if (max == min)\r\n            h = 0;\r\n        else if (r == max)\r\n            h = (g - b) / delta;\r\n        else if (g == max)\r\n            h = 2 + (b - r) / delta;\r\n        else if (b == max)\r\n            h = 4 + (r - g)/ delta;\r\n\r\n        h = Math.min(h * 60, 360);\r\n\r\n        if (h < 0)\r\n            h += 360;\r\n\r\n        l = (min + max) / 2;\r\n\r\n        if (max == min)\r\n            s = 0;\r\n        else if (l <= 0.5)\r\n            s = delta / (max + min);\r\n        else\r\n            s = delta / (2 - max - min);\r\n\r\n        return [h, s * 100, l * 100];\r\n    }\r\n\r\n    function rgb2hsv(rgb) {\r\n        var r = rgb[0],\r\n            g = rgb[1],\r\n            b = rgb[2],\r\n            min = Math.min(r, g, b),\r\n            max = Math.max(r, g, b),\r\n            delta = max - min,\r\n            h, s, v;\r\n\r\n        if (max == 0)\r\n            s = 0;\r\n        else\r\n            s = (delta/max * 1000)/10;\r\n\r\n        if (max == min)\r\n            h = 0;\r\n        else if (r == max)\r\n            h = (g - b) / delta;\r\n        else if (g == max)\r\n            h = 2 + (b - r) / delta;\r\n        else if (b == max)\r\n            h = 4 + (r - g) / delta;\r\n\r\n        h = Math.min(h * 60, 360);\r\n\r\n        if (h < 0)\r\n            h += 360;\r\n\r\n        v = ((max / 255) * 1000) / 10;\r\n\r\n        return [h, s, v];\r\n    }\r\n\r\n    function rgb2hwb(rgb) {\r\n        var r = rgb[0],\r\n            g = rgb[1],\r\n            b = rgb[2],\r\n            h = rgb2hsl(rgb)[0],\r\n            w = 1/255 * Math.min(r, Math.min(g, b)),\r\n            b = 1 - 1/255 * Math.max(r, Math.max(g, b));\r\n\r\n        return [h, w * 100, b * 100];\r\n    }\r\n\r\n    function rgb2cmyk(rgb) {\r\n        var r = rgb[0] / 255,\r\n            g = rgb[1] / 255,\r\n            b = rgb[2] / 255,\r\n            c, m, y, k;\r\n\r\n        k = Math.min(1 - r, 1 - g, 1 - b);\r\n        c = (1 - r - k) / (1 - k) || 0;\r\n        m = (1 - g - k) / (1 - k) || 0;\r\n        y = (1 - b - k) / (1 - k) || 0;\r\n        return [c * 100, m * 100, y * 100, k * 100];\r\n    }\r\n\r\n    function rgb2keyword(rgb) {\r\n        return reverseKeywords[JSON.stringify(rgb)];\r\n    }\r\n\r\n    function rgb2xyz(rgb) {\r\n        var r = rgb[0] / 255,\r\n            g = rgb[1] / 255,\r\n            b = rgb[2] / 255;\r\n\r\n        // assume sRGB\r\n        r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\r\n        g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\r\n        b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\r\n\r\n        var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\r\n        var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\r\n        var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\r\n\r\n        return [x * 100, y *100, z * 100];\r\n    }\r\n\r\n    function rgb2lab(rgb) {\r\n        var xyz = rgb2xyz(rgb),\r\n            x = xyz[0],\r\n            y = xyz[1],\r\n            z = xyz[2],\r\n            l, a, b;\r\n\r\n        x /= 95.047;\r\n        y /= 100;\r\n        z /= 108.883;\r\n\r\n        x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\r\n        y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\r\n        z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\r\n\r\n        l = (116 * y) - 16;\r\n        a = 500 * (x - y);\r\n        b = 200 * (y - z);\r\n\r\n        return [l, a, b];\r\n    }\r\n\r\n    function rgb2lch(args) {\r\n        return lab2lch(rgb2lab(args));\r\n    }\r\n\r\n    function hsl2rgb(hsl) {\r\n        var h = hsl[0] / 360,\r\n            s = hsl[1] / 100,\r\n            l = hsl[2] / 100,\r\n            t1, t2, t3, rgb, val;\r\n\r\n        if (s == 0) {\r\n            val = l * 255;\r\n            return [val, val, val];\r\n        }\r\n\r\n        if (l < 0.5)\r\n            t2 = l * (1 + s);\r\n        else\r\n            t2 = l + s - l * s;\r\n        t1 = 2 * l - t2;\r\n\r\n        rgb = [0, 0, 0];\r\n        for (var i = 0; i < 3; i++) {\r\n            t3 = h + 1 / 3 * - (i - 1);\r\n            t3 < 0 && t3++;\r\n            t3 > 1 && t3--;\r\n\r\n            if (6 * t3 < 1)\r\n                val = t1 + (t2 - t1) * 6 * t3;\r\n            else if (2 * t3 < 1)\r\n                val = t2;\r\n            else if (3 * t3 < 2)\r\n                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\r\n            else\r\n                val = t1;\r\n\r\n            rgb[i] = val * 255;\r\n        }\r\n\r\n        return rgb;\r\n    }\r\n\r\n    function hsl2hsv(hsl) {\r\n        var h = hsl[0],\r\n            s = hsl[1] / 100,\r\n            l = hsl[2] / 100,\r\n            sv, v;\r\n\r\n        if(l === 0) {\r\n            // no need to do calc on black\r\n            // also avoids divide by 0 error\r\n            return [0, 0, 0];\r\n        }\r\n\r\n        l *= 2;\r\n        s *= (l <= 1) ? l : 2 - l;\r\n        v = (l + s) / 2;\r\n        sv = (2 * s) / (l + s);\r\n        return [h, sv * 100, v * 100];\r\n    }\r\n\r\n    function hsl2hwb(args) {\r\n        return rgb2hwb(hsl2rgb(args));\r\n    }\r\n\r\n    function hsl2cmyk(args) {\r\n        return rgb2cmyk(hsl2rgb(args));\r\n    }\r\n\r\n    function hsl2keyword(args) {\r\n        return rgb2keyword(hsl2rgb(args));\r\n    }\r\n\r\n\r\n    function hsv2rgb(hsv) {\r\n        var h = hsv[0] / 60,\r\n            s = hsv[1] / 100,\r\n            v = hsv[2] / 100,\r\n            hi = Math.floor(h) % 6;\r\n\r\n        var f = h - Math.floor(h),\r\n            p = 255 * v * (1 - s),\r\n            q = 255 * v * (1 - (s * f)),\r\n            t = 255 * v * (1 - (s * (1 - f))),\r\n            v = 255 * v;\r\n\r\n        switch(hi) {\r\n            case 0:\r\n                return [v, t, p];\r\n            case 1:\r\n                return [q, v, p];\r\n            case 2:\r\n                return [p, v, t];\r\n            case 3:\r\n                return [p, q, v];\r\n            case 4:\r\n                return [t, p, v];\r\n            case 5:\r\n                return [v, p, q];\r\n        }\r\n    }\r\n\r\n    function hsv2hsl(hsv) {\r\n        var h = hsv[0],\r\n            s = hsv[1] / 100,\r\n            v = hsv[2] / 100,\r\n            sl, l;\r\n\r\n        l = (2 - s) * v;\r\n        sl = s * v;\r\n        sl /= (l <= 1) ? l : 2 - l;\r\n        sl = sl || 0;\r\n        l /= 2;\r\n        return [h, sl * 100, l * 100];\r\n    }\r\n\r\n    function hsv2hwb(args) {\r\n        return rgb2hwb(hsv2rgb(args))\r\n    }\r\n\r\n    function hsv2cmyk(args) {\r\n        return rgb2cmyk(hsv2rgb(args));\r\n    }\r\n\r\n    function hsv2keyword(args) {\r\n        return rgb2keyword(hsv2rgb(args));\r\n    }\r\n\r\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\r\n    function hwb2rgb(hwb) {\r\n        var h = hwb[0] / 360,\r\n            wh = hwb[1] / 100,\r\n            bl = hwb[2] / 100,\r\n            ratio = wh + bl,\r\n            i, v, f, n;\r\n\r\n        // wh + bl cant be > 1\r\n        if (ratio > 1) {\r\n            wh /= ratio;\r\n            bl /= ratio;\r\n        }\r\n\r\n        i = Math.floor(6 * h);\r\n        v = 1 - bl;\r\n        f = 6 * h - i;\r\n        if ((i & 0x01) != 0) {\r\n            f = 1 - f;\r\n        }\r\n        n = wh + f * (v - wh);  // linear interpolation\r\n\r\n        switch (i) {\r\n            default:\r\n            case 6:\r\n            case 0: r = v; g = n; b = wh; break;\r\n            case 1: r = n; g = v; b = wh; break;\r\n            case 2: r = wh; g = v; b = n; break;\r\n            case 3: r = wh; g = n; b = v; break;\r\n            case 4: r = n; g = wh; b = v; break;\r\n            case 5: r = v; g = wh; b = n; break;\r\n        }\r\n\r\n        return [r * 255, g * 255, b * 255];\r\n    }\r\n\r\n    function hwb2hsl(args) {\r\n        return rgb2hsl(hwb2rgb(args));\r\n    }\r\n\r\n    function hwb2hsv(args) {\r\n        return rgb2hsv(hwb2rgb(args));\r\n    }\r\n\r\n    function hwb2cmyk(args) {\r\n        return rgb2cmyk(hwb2rgb(args));\r\n    }\r\n\r\n    function hwb2keyword(args) {\r\n        return rgb2keyword(hwb2rgb(args));\r\n    }\r\n\r\n    function cmyk2rgb(cmyk) {\r\n        var c = cmyk[0] / 100,\r\n            m = cmyk[1] / 100,\r\n            y = cmyk[2] / 100,\r\n            k = cmyk[3] / 100,\r\n            r, g, b;\r\n\r\n        r = 1 - Math.min(1, c * (1 - k) + k);\r\n        g = 1 - Math.min(1, m * (1 - k) + k);\r\n        b = 1 - Math.min(1, y * (1 - k) + k);\r\n        return [r * 255, g * 255, b * 255];\r\n    }\r\n\r\n    function cmyk2hsl(args) {\r\n        return rgb2hsl(cmyk2rgb(args));\r\n    }\r\n\r\n    function cmyk2hsv(args) {\r\n        return rgb2hsv(cmyk2rgb(args));\r\n    }\r\n\r\n    function cmyk2hwb(args) {\r\n        return rgb2hwb(cmyk2rgb(args));\r\n    }\r\n\r\n    function cmyk2keyword(args) {\r\n        return rgb2keyword(cmyk2rgb(args));\r\n    }\r\n\r\n\r\n    function xyz2rgb(xyz) {\r\n        var x = xyz[0] / 100,\r\n            y = xyz[1] / 100,\r\n            z = xyz[2] / 100,\r\n            r, g, b;\r\n\r\n        r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\r\n        g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\r\n        b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\r\n\r\n        // assume sRGB\r\n        r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\r\n            : r = (r * 12.92);\r\n\r\n        g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\r\n            : g = (g * 12.92);\r\n\r\n        b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\r\n            : b = (b * 12.92);\r\n\r\n        r = Math.min(Math.max(0, r), 1);\r\n        g = Math.min(Math.max(0, g), 1);\r\n        b = Math.min(Math.max(0, b), 1);\r\n\r\n        return [r * 255, g * 255, b * 255];\r\n    }\r\n\r\n    function xyz2lab(xyz) {\r\n        var x = xyz[0],\r\n            y = xyz[1],\r\n            z = xyz[2],\r\n            l, a, b;\r\n\r\n        x /= 95.047;\r\n        y /= 100;\r\n        z /= 108.883;\r\n\r\n        x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\r\n        y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\r\n        z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\r\n\r\n        l = (116 * y) - 16;\r\n        a = 500 * (x - y);\r\n        b = 200 * (y - z);\r\n\r\n        return [l, a, b];\r\n    }\r\n\r\n    function xyz2lch(args) {\r\n        return lab2lch(xyz2lab(args));\r\n    }\r\n\r\n    function lab2xyz(lab) {\r\n        var l = lab[0],\r\n            a = lab[1],\r\n            b = lab[2],\r\n            x, y, z, y2;\r\n\r\n        if (l <= 8) {\r\n            y = (l * 100) / 903.3;\r\n            y2 = (7.787 * (y / 100)) + (16 / 116);\r\n        } else {\r\n            y = 100 * Math.pow((l + 16) / 116, 3);\r\n            y2 = Math.pow(y / 100, 1/3);\r\n        }\r\n\r\n        x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\r\n\r\n        z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\r\n\r\n        return [x, y, z];\r\n    }\r\n\r\n    function lab2lch(lab) {\r\n        var l = lab[0],\r\n            a = lab[1],\r\n            b = lab[2],\r\n            hr, h, c;\r\n\r\n        hr = Math.atan2(b, a);\r\n        h = hr * 360 / 2 / Math.PI;\r\n        if (h < 0) {\r\n            h += 360;\r\n        }\r\n        c = Math.sqrt(a * a + b * b);\r\n        return [l, c, h];\r\n    }\r\n\r\n    function lab2rgb(args) {\r\n        return xyz2rgb(lab2xyz(args));\r\n    }\r\n\r\n    function lch2lab(lch) {\r\n        var l = lch[0],\r\n            c = lch[1],\r\n            h = lch[2],\r\n            a, b, hr;\r\n\r\n        hr = h / 360 * 2 * Math.PI;\r\n        a = c * Math.cos(hr);\r\n        b = c * Math.sin(hr);\r\n        return [l, a, b];\r\n    }\r\n\r\n    function lch2xyz(args) {\r\n        return lab2xyz(lch2lab(args));\r\n    }\r\n\r\n    function lch2rgb(args) {\r\n        return lab2rgb(lch2lab(args));\r\n    }\r\n\r\n    function keyword2rgb(keyword) {\r\n        return cssKeywords[keyword];\r\n    }\r\n\r\n    function keyword2hsl(args) {\r\n        return rgb2hsl(keyword2rgb(args));\r\n    }\r\n\r\n    function keyword2hsv(args) {\r\n        return rgb2hsv(keyword2rgb(args));\r\n    }\r\n\r\n    function keyword2hwb(args) {\r\n        return rgb2hwb(keyword2rgb(args));\r\n    }\r\n\r\n    function keyword2cmyk(args) {\r\n        return rgb2cmyk(keyword2rgb(args));\r\n    }\r\n\r\n    function keyword2lab(args) {\r\n        return rgb2lab(keyword2rgb(args));\r\n    }\r\n\r\n    function keyword2xyz(args) {\r\n        return rgb2xyz(keyword2rgb(args));\r\n    }\r\n\r\n    var cssKeywords = {\r\n        aliceblue:  [240,248,255],\r\n        antiquewhite: [250,235,215],\r\n        aqua: [0,255,255],\r\n        aquamarine: [127,255,212],\r\n        azure:  [240,255,255],\r\n        beige:  [245,245,220],\r\n        bisque: [255,228,196],\r\n        black:  [0,0,0],\r\n        blanchedalmond: [255,235,205],\r\n        blue: [0,0,255],\r\n        blueviolet: [138,43,226],\r\n        brown:  [165,42,42],\r\n        burlywood:  [222,184,135],\r\n        cadetblue:  [95,158,160],\r\n        chartreuse: [127,255,0],\r\n        chocolate:  [210,105,30],\r\n        coral:  [255,127,80],\r\n        cornflowerblue: [100,149,237],\r\n        cornsilk: [255,248,220],\r\n        crimson:  [220,20,60],\r\n        cyan: [0,255,255],\r\n        darkblue: [0,0,139],\r\n        darkcyan: [0,139,139],\r\n        darkgoldenrod:  [184,134,11],\r\n        darkgray: [169,169,169],\r\n        darkgreen:  [0,100,0],\r\n        darkgrey: [169,169,169],\r\n        darkkhaki:  [189,183,107],\r\n        darkmagenta:  [139,0,139],\r\n        darkolivegreen: [85,107,47],\r\n        darkorange: [255,140,0],\r\n        darkorchid: [153,50,204],\r\n        darkred:  [139,0,0],\r\n        darksalmon: [233,150,122],\r\n        darkseagreen: [143,188,143],\r\n        darkslateblue:  [72,61,139],\r\n        darkslategray:  [47,79,79],\r\n        darkslategrey:  [47,79,79],\r\n        darkturquoise:  [0,206,209],\r\n        darkviolet: [148,0,211],\r\n        deeppink: [255,20,147],\r\n        deepskyblue:  [0,191,255],\r\n        dimgray:  [105,105,105],\r\n        dimgrey:  [105,105,105],\r\n        dodgerblue: [30,144,255],\r\n        firebrick:  [178,34,34],\r\n        floralwhite:  [255,250,240],\r\n        forestgreen:  [34,139,34],\r\n        fuchsia:  [255,0,255],\r\n        gainsboro:  [220,220,220],\r\n        ghostwhite: [248,248,255],\r\n        gold: [255,215,0],\r\n        goldenrod:  [218,165,32],\r\n        gray: [128,128,128],\r\n        green:  [0,128,0],\r\n        greenyellow:  [173,255,47],\r\n        grey: [128,128,128],\r\n        honeydew: [240,255,240],\r\n        hotpink:  [255,105,180],\r\n        indianred:  [205,92,92],\r\n        indigo: [75,0,130],\r\n        ivory:  [255,255,240],\r\n        khaki:  [240,230,140],\r\n        lavender: [230,230,250],\r\n        lavenderblush:  [255,240,245],\r\n        lawngreen:  [124,252,0],\r\n        lemonchiffon: [255,250,205],\r\n        lightblue:  [173,216,230],\r\n        lightcoral: [240,128,128],\r\n        lightcyan:  [224,255,255],\r\n        lightgoldenrodyellow: [250,250,210],\r\n        lightgray:  [211,211,211],\r\n        lightgreen: [144,238,144],\r\n        lightgrey:  [211,211,211],\r\n        lightpink:  [255,182,193],\r\n        lightsalmon:  [255,160,122],\r\n        lightseagreen:  [32,178,170],\r\n        lightskyblue: [135,206,250],\r\n        lightslategray: [119,136,153],\r\n        lightslategrey: [119,136,153],\r\n        lightsteelblue: [176,196,222],\r\n        lightyellow:  [255,255,224],\r\n        lime: [0,255,0],\r\n        limegreen:  [50,205,50],\r\n        linen:  [250,240,230],\r\n        magenta:  [255,0,255],\r\n        maroon: [128,0,0],\r\n        mediumaquamarine: [102,205,170],\r\n        mediumblue: [0,0,205],\r\n        mediumorchid: [186,85,211],\r\n        mediumpurple: [147,112,219],\r\n        mediumseagreen: [60,179,113],\r\n        mediumslateblue:  [123,104,238],\r\n        mediumspringgreen:  [0,250,154],\r\n        mediumturquoise:  [72,209,204],\r\n        mediumvioletred:  [199,21,133],\r\n        midnightblue: [25,25,112],\r\n        mintcream:  [245,255,250],\r\n        mistyrose:  [255,228,225],\r\n        moccasin: [255,228,181],\r\n        navajowhite:  [255,222,173],\r\n        navy: [0,0,128],\r\n        oldlace:  [253,245,230],\r\n        olive:  [128,128,0],\r\n        olivedrab:  [107,142,35],\r\n        orange: [255,165,0],\r\n        orangered:  [255,69,0],\r\n        orchid: [218,112,214],\r\n        palegoldenrod:  [238,232,170],\r\n        palegreen:  [152,251,152],\r\n        paleturquoise:  [175,238,238],\r\n        palevioletred:  [219,112,147],\r\n        papayawhip: [255,239,213],\r\n        peachpuff:  [255,218,185],\r\n        peru: [205,133,63],\r\n        pink: [255,192,203],\r\n        plum: [221,160,221],\r\n        powderblue: [176,224,230],\r\n        purple: [128,0,128],\r\n        rebeccapurple: [102, 51, 153],\r\n        red:  [255,0,0],\r\n        rosybrown:  [188,143,143],\r\n        royalblue:  [65,105,225],\r\n        saddlebrown:  [139,69,19],\r\n        salmon: [250,128,114],\r\n        sandybrown: [244,164,96],\r\n        seagreen: [46,139,87],\r\n        seashell: [255,245,238],\r\n        sienna: [160,82,45],\r\n        silver: [192,192,192],\r\n        skyblue:  [135,206,235],\r\n        slateblue:  [106,90,205],\r\n        slategray:  [112,128,144],\r\n        slategrey:  [112,128,144],\r\n        snow: [255,250,250],\r\n        springgreen:  [0,255,127],\r\n        steelblue:  [70,130,180],\r\n        tan:  [210,180,140],\r\n        teal: [0,128,128],\r\n        thistle:  [216,191,216],\r\n        tomato: [255,99,71],\r\n        turquoise:  [64,224,208],\r\n        violet: [238,130,238],\r\n        wheat:  [245,222,179],\r\n        white:  [255,255,255],\r\n        whitesmoke: [245,245,245],\r\n        yellow: [255,255,0],\r\n        yellowgreen:  [154,205,50]\r\n    };\r\n\r\n    var reverseKeywords = {};\r\n    for (var key in cssKeywords) {\r\n        reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\r\n    }\r\n\r\n},{}],5:[function(require,module,exports){\r\n    var conversions = require(4);\r\n\r\n    var convert = function() {\r\n        return new Converter();\r\n    }\r\n\r\n    for (var func in conversions) {\r\n        // export Raw versions\r\n        convert[func + \"Raw\"] =  (function(func) {\r\n            // accept array or plain args\r\n            return function(arg) {\r\n                if (typeof arg == \"number\")\r\n                    arg = Array.prototype.slice.call(arguments);\r\n                return conversions[func](arg);\r\n            }\r\n        })(func);\r\n\r\n        var pair = /(\\w+)2(\\w+)/.exec(func),\r\n            from = pair[1],\r\n            to = pair[2];\r\n\r\n        // export rgb2hsl and [\"rgb\"][\"hsl\"]\r\n        convert[from] = convert[from] || {};\r\n\r\n        convert[from][to] = convert[func] = (function(func) {\r\n            return function(arg) {\r\n                if (typeof arg == \"number\")\r\n                    arg = Array.prototype.slice.call(arguments);\r\n\r\n                var val = conversions[func](arg);\r\n                if (typeof val == \"string\" || val === undefined)\r\n                    return val; // keyword\r\n\r\n                for (var i = 0; i < val.length; i++)\r\n                    val[i] = Math.round(val[i]);\r\n                return val;\r\n            }\r\n        })(func);\r\n    }\r\n\r\n\r\n    /* Converter does lazy conversion and caching */\r\n    var Converter = function() {\r\n        this.convs = {};\r\n    };\r\n\r\n    /* Either get the values for a space or\r\n     set the values for a space, depending on args */\r\n    Converter.prototype.routeSpace = function(space, args) {\r\n        var values = args[0];\r\n        if (values === undefined) {\r\n            // color.rgb()\r\n            return this.getValues(space);\r\n        }\r\n        // color.rgb(10, 10, 10)\r\n        if (typeof values == \"number\") {\r\n            values = Array.prototype.slice.call(args);\r\n        }\r\n\r\n        return this.setValues(space, values);\r\n    };\r\n\r\n    /* Set the values for a space, invalidating cache */\r\n    Converter.prototype.setValues = function(space, values) {\r\n        this.space = space;\r\n        this.convs = {};\r\n        this.convs[space] = values;\r\n        return this;\r\n    };\r\n\r\n    /* Get the values for a space. If there's already\r\n     a conversion for the space, fetch it, otherwise\r\n     compute it */\r\n    Converter.prototype.getValues = function(space) {\r\n        var vals = this.convs[space];\r\n        if (!vals) {\r\n            var fspace = this.space,\r\n                from = this.convs[fspace];\r\n            vals = convert[fspace][space](from);\r\n\r\n            this.convs[space] = vals;\r\n        }\r\n        return vals;\r\n    };\r\n\r\n    [\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\r\n        Converter.prototype[space] = function(vals) {\r\n            return this.routeSpace(space, arguments);\r\n        }\r\n    });\r\n\r\n    module.exports = convert;\r\n},{\"4\":4}],6:[function(require,module,exports){\r\n    module.exports = {\r\n        \"aliceblue\": [240, 248, 255],\r\n        \"antiquewhite\": [250, 235, 215],\r\n        \"aqua\": [0, 255, 255],\r\n        \"aquamarine\": [127, 255, 212],\r\n        \"azure\": [240, 255, 255],\r\n        \"beige\": [245, 245, 220],\r\n        \"bisque\": [255, 228, 196],\r\n        \"black\": [0, 0, 0],\r\n        \"blanchedalmond\": [255, 235, 205],\r\n        \"blue\": [0, 0, 255],\r\n        \"blueviolet\": [138, 43, 226],\r\n        \"brown\": [165, 42, 42],\r\n        \"burlywood\": [222, 184, 135],\r\n        \"cadetblue\": [95, 158, 160],\r\n        \"chartreuse\": [127, 255, 0],\r\n        \"chocolate\": [210, 105, 30],\r\n        \"coral\": [255, 127, 80],\r\n        \"cornflowerblue\": [100, 149, 237],\r\n        \"cornsilk\": [255, 248, 220],\r\n        \"crimson\": [220, 20, 60],\r\n        \"cyan\": [0, 255, 255],\r\n        \"darkblue\": [0, 0, 139],\r\n        \"darkcyan\": [0, 139, 139],\r\n        \"darkgoldenrod\": [184, 134, 11],\r\n        \"darkgray\": [169, 169, 169],\r\n        \"darkgreen\": [0, 100, 0],\r\n        \"darkgrey\": [169, 169, 169],\r\n        \"darkkhaki\": [189, 183, 107],\r\n        \"darkmagenta\": [139, 0, 139],\r\n        \"darkolivegreen\": [85, 107, 47],\r\n        \"darkorange\": [255, 140, 0],\r\n        \"darkorchid\": [153, 50, 204],\r\n        \"darkred\": [139, 0, 0],\r\n        \"darksalmon\": [233, 150, 122],\r\n        \"darkseagreen\": [143, 188, 143],\r\n        \"darkslateblue\": [72, 61, 139],\r\n        \"darkslategray\": [47, 79, 79],\r\n        \"darkslategrey\": [47, 79, 79],\r\n        \"darkturquoise\": [0, 206, 209],\r\n        \"darkviolet\": [148, 0, 211],\r\n        \"deeppink\": [255, 20, 147],\r\n        \"deepskyblue\": [0, 191, 255],\r\n        \"dimgray\": [105, 105, 105],\r\n        \"dimgrey\": [105, 105, 105],\r\n        \"dodgerblue\": [30, 144, 255],\r\n        \"firebrick\": [178, 34, 34],\r\n        \"floralwhite\": [255, 250, 240],\r\n        \"forestgreen\": [34, 139, 34],\r\n        \"fuchsia\": [255, 0, 255],\r\n        \"gainsboro\": [220, 220, 220],\r\n        \"ghostwhite\": [248, 248, 255],\r\n        \"gold\": [255, 215, 0],\r\n        \"goldenrod\": [218, 165, 32],\r\n        \"gray\": [128, 128, 128],\r\n        \"green\": [0, 128, 0],\r\n        \"greenyellow\": [173, 255, 47],\r\n        \"grey\": [128, 128, 128],\r\n        \"honeydew\": [240, 255, 240],\r\n        \"hotpink\": [255, 105, 180],\r\n        \"indianred\": [205, 92, 92],\r\n        \"indigo\": [75, 0, 130],\r\n        \"ivory\": [255, 255, 240],\r\n        \"khaki\": [240, 230, 140],\r\n        \"lavender\": [230, 230, 250],\r\n        \"lavenderblush\": [255, 240, 245],\r\n        \"lawngreen\": [124, 252, 0],\r\n        \"lemonchiffon\": [255, 250, 205],\r\n        \"lightblue\": [173, 216, 230],\r\n        \"lightcoral\": [240, 128, 128],\r\n        \"lightcyan\": [224, 255, 255],\r\n        \"lightgoldenrodyellow\": [250, 250, 210],\r\n        \"lightgray\": [211, 211, 211],\r\n        \"lightgreen\": [144, 238, 144],\r\n        \"lightgrey\": [211, 211, 211],\r\n        \"lightpink\": [255, 182, 193],\r\n        \"lightsalmon\": [255, 160, 122],\r\n        \"lightseagreen\": [32, 178, 170],\r\n        \"lightskyblue\": [135, 206, 250],\r\n        \"lightslategray\": [119, 136, 153],\r\n        \"lightslategrey\": [119, 136, 153],\r\n        \"lightsteelblue\": [176, 196, 222],\r\n        \"lightyellow\": [255, 255, 224],\r\n        \"lime\": [0, 255, 0],\r\n        \"limegreen\": [50, 205, 50],\r\n        \"linen\": [250, 240, 230],\r\n        \"magenta\": [255, 0, 255],\r\n        \"maroon\": [128, 0, 0],\r\n        \"mediumaquamarine\": [102, 205, 170],\r\n        \"mediumblue\": [0, 0, 205],\r\n        \"mediumorchid\": [186, 85, 211],\r\n        \"mediumpurple\": [147, 112, 219],\r\n        \"mediumseagreen\": [60, 179, 113],\r\n        \"mediumslateblue\": [123, 104, 238],\r\n        \"mediumspringgreen\": [0, 250, 154],\r\n        \"mediumturquoise\": [72, 209, 204],\r\n        \"mediumvioletred\": [199, 21, 133],\r\n        \"midnightblue\": [25, 25, 112],\r\n        \"mintcream\": [245, 255, 250],\r\n        \"mistyrose\": [255, 228, 225],\r\n        \"moccasin\": [255, 228, 181],\r\n        \"navajowhite\": [255, 222, 173],\r\n        \"navy\": [0, 0, 128],\r\n        \"oldlace\": [253, 245, 230],\r\n        \"olive\": [128, 128, 0],\r\n        \"olivedrab\": [107, 142, 35],\r\n        \"orange\": [255, 165, 0],\r\n        \"orangered\": [255, 69, 0],\r\n        \"orchid\": [218, 112, 214],\r\n        \"palegoldenrod\": [238, 232, 170],\r\n        \"palegreen\": [152, 251, 152],\r\n        \"paleturquoise\": [175, 238, 238],\r\n        \"palevioletred\": [219, 112, 147],\r\n        \"papayawhip\": [255, 239, 213],\r\n        \"peachpuff\": [255, 218, 185],\r\n        \"peru\": [205, 133, 63],\r\n        \"pink\": [255, 192, 203],\r\n        \"plum\": [221, 160, 221],\r\n        \"powderblue\": [176, 224, 230],\r\n        \"purple\": [128, 0, 128],\r\n        \"rebeccapurple\": [102, 51, 153],\r\n        \"red\": [255, 0, 0],\r\n        \"rosybrown\": [188, 143, 143],\r\n        \"royalblue\": [65, 105, 225],\r\n        \"saddlebrown\": [139, 69, 19],\r\n        \"salmon\": [250, 128, 114],\r\n        \"sandybrown\": [244, 164, 96],\r\n        \"seagreen\": [46, 139, 87],\r\n        \"seashell\": [255, 245, 238],\r\n        \"sienna\": [160, 82, 45],\r\n        \"silver\": [192, 192, 192],\r\n        \"skyblue\": [135, 206, 235],\r\n        \"slateblue\": [106, 90, 205],\r\n        \"slategray\": [112, 128, 144],\r\n        \"slategrey\": [112, 128, 144],\r\n        \"snow\": [255, 250, 250],\r\n        \"springgreen\": [0, 255, 127],\r\n        \"steelblue\": [70, 130, 180],\r\n        \"tan\": [210, 180, 140],\r\n        \"teal\": [0, 128, 128],\r\n        \"thistle\": [216, 191, 216],\r\n        \"tomato\": [255, 99, 71],\r\n        \"turquoise\": [64, 224, 208],\r\n        \"violet\": [238, 130, 238],\r\n        \"wheat\": [245, 222, 179],\r\n        \"white\": [255, 255, 255],\r\n        \"whitesmoke\": [245, 245, 245],\r\n        \"yellow\": [255, 255, 0],\r\n        \"yellowgreen\": [154, 205, 50]\r\n    };\r\n},{}],7:[function(require,module,exports){\r\n    /**\r\n     * @namespace Chart\r\n     */\r\n    var Chart = require(28)();\r\n\r\n    require(26)(Chart);\r\n    require(22)(Chart);\r\n    require(25)(Chart);\r\n    require(21)(Chart);\r\n    require(23)(Chart);\r\n    require(24)(Chart);\r\n    require(29)(Chart);\r\n    require(33)(Chart);\r\n    require(31)(Chart);\r\n    require(34)(Chart);\r\n    require(32)(Chart);\r\n    require(35)(Chart);\r\n    require(30)(Chart);\r\n    require(27)(Chart);\r\n    require(36)(Chart);\r\n\r\n    require(37)(Chart);\r\n    require(38)(Chart);\r\n    require(39)(Chart);\r\n    require(40)(Chart);\r\n\r\n    require(43)(Chart);\r\n    require(41)(Chart);\r\n    require(42)(Chart);\r\n    require(44)(Chart);\r\n    require(45)(Chart);\r\n    require(46)(Chart);\r\n\r\n// Controllers must be loaded after elements\r\n// See Chart.core.datasetController.dataElementType\r\n    require(15)(Chart);\r\n    require(16)(Chart);\r\n    require(17)(Chart);\r\n    require(18)(Chart);\r\n    require(19)(Chart);\r\n    require(20)(Chart);\r\n\r\n    require(8)(Chart);\r\n    require(9)(Chart);\r\n    require(10)(Chart);\r\n    require(11)(Chart);\r\n    require(12)(Chart);\r\n    require(13)(Chart);\r\n    require(14)(Chart);\r\n\r\n    window.Chart = module.exports = Chart;\r\n\r\n},{\"10\":10,\"11\":11,\"12\":12,\"13\":13,\"14\":14,\"15\":15,\"16\":16,\"17\":17,\"18\":18,\"19\":19,\"20\":20,\"21\":21,\"22\":22,\"23\":23,\"24\":24,\"25\":25,\"26\":26,\"27\":27,\"28\":28,\"29\":29,\"30\":30,\"31\":31,\"32\":32,\"33\":33,\"34\":34,\"35\":35,\"36\":36,\"37\":37,\"38\":38,\"39\":39,\"40\":40,\"41\":41,\"42\":42,\"43\":43,\"44\":44,\"45\":45,\"46\":46,\"8\":8,\"9\":9}],8:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        Chart.Bar = function(context, config) {\r\n            config.type = 'bar';\r\n\r\n            return new Chart(context, config);\r\n        };\r\n\r\n    };\r\n\r\n},{}],9:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        Chart.Bubble = function(context, config) {\r\n            config.type = 'bubble';\r\n            return new Chart(context, config);\r\n        };\r\n\r\n    };\r\n\r\n},{}],10:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        Chart.Doughnut = function(context, config) {\r\n            config.type = 'doughnut';\r\n\r\n            return new Chart(context, config);\r\n        };\r\n\r\n    };\r\n\r\n},{}],11:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        Chart.Line = function(context, config) {\r\n            config.type = 'line';\r\n\r\n            return new Chart(context, config);\r\n        };\r\n\r\n    };\r\n\r\n},{}],12:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        Chart.PolarArea = function(context, config) {\r\n            config.type = 'polarArea';\r\n\r\n            return new Chart(context, config);\r\n        };\r\n\r\n    };\r\n\r\n},{}],13:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        Chart.Radar = function(context, config) {\r\n            config.type = 'radar';\r\n\r\n            return new Chart(context, config);\r\n        };\r\n\r\n    };\r\n\r\n},{}],14:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var defaultConfig = {\r\n            hover: {\r\n                mode: 'single'\r\n            },\r\n\r\n            scales: {\r\n                xAxes: [{\r\n                    type: 'linear', // scatter should not use a category axis\r\n                    position: 'bottom',\r\n                    id: 'x-axis-1' // need an ID so datasets can reference the scale\r\n                }],\r\n                yAxes: [{\r\n                    type: 'linear',\r\n                    position: 'left',\r\n                    id: 'y-axis-1'\r\n                }]\r\n            },\r\n\r\n            tooltips: {\r\n                callbacks: {\r\n                    title: function() {\r\n                        // Title doesn't make sense for scatter since we format the data as a point\r\n                        return '';\r\n                    },\r\n                    label: function(tooltipItem) {\r\n                        return '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        // Register the default config for this type\r\n        Chart.defaults.scatter = defaultConfig;\r\n\r\n        // Scatter charts use line controllers\r\n        Chart.controllers.scatter = Chart.controllers.line;\r\n\r\n        Chart.Scatter = function(context, config) {\r\n            config.type = 'scatter';\r\n            return new Chart(context, config);\r\n        };\r\n\r\n    };\r\n\r\n},{}],15:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        Chart.defaults.bar = {\r\n            hover: {\r\n                mode: 'label'\r\n            },\r\n\r\n            scales: {\r\n                xAxes: [{\r\n                    type: 'category',\r\n\r\n                    // Specific to Bar Controller\r\n                    categoryPercentage: 0.8,\r\n                    barPercentage: 0.9,\r\n\r\n                    // grid line settings\r\n                    gridLines: {\r\n                        offsetGridLines: true\r\n                    }\r\n                }],\r\n                yAxes: [{\r\n                    type: 'linear'\r\n                }]\r\n            }\r\n        };\r\n\r\n        Chart.controllers.bar = Chart.DatasetController.extend({\r\n\r\n            dataElementType: Chart.elements.Rectangle,\r\n\r\n            initialize: function(chart, datasetIndex) {\r\n                Chart.DatasetController.prototype.initialize.call(this, chart, datasetIndex);\r\n\r\n                // Use this to indicate that this is a bar dataset.\r\n                this.getMeta().bar = true;\r\n            },\r\n\r\n            // Get the number of datasets that display bars. We use this to correctly calculate the bar width\r\n            getBarCount: function() {\r\n                var me = this;\r\n                var barCount = 0;\r\n                helpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\r\n                    var meta = me.chart.getDatasetMeta(datasetIndex);\r\n                    if (meta.bar && me.chart.isDatasetVisible(datasetIndex)) {\r\n                        ++barCount;\r\n                    }\r\n                }, me);\r\n                return barCount;\r\n            },\r\n\r\n            update: function(reset) {\r\n                var me = this;\r\n                helpers.each(me.getMeta().data, function(rectangle, index) {\r\n                    me.updateElement(rectangle, index, reset);\r\n                }, me);\r\n            },\r\n\r\n            updateElement: function(rectangle, index, reset) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var xScale = me.getScaleForId(meta.xAxisID);\r\n                var yScale = me.getScaleForId(meta.yAxisID);\r\n                var scaleBase = yScale.getBasePixel();\r\n                var rectangleElementOptions = me.chart.options.elements.rectangle;\r\n                var custom = rectangle.custom || {};\r\n                var dataset = me.getDataset();\r\n\r\n                rectangle._xScale = xScale;\r\n                rectangle._yScale = yScale;\r\n                rectangle._datasetIndex = me.index;\r\n                rectangle._index = index;\r\n\r\n                var ruler = me.getRuler(index);\r\n                rectangle._model = {\r\n                    x: me.calculateBarX(index, me.index, ruler),\r\n                    y: reset ? scaleBase : me.calculateBarY(index, me.index),\r\n\r\n                    // Tooltip\r\n                    label: me.chart.data.labels[index],\r\n                    datasetLabel: dataset.label,\r\n\r\n                    // Appearance\r\n                    base: reset ? scaleBase : me.calculateBarBase(me.index, index),\r\n                    width: me.calculateBarWidth(ruler),\r\n                    backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\r\n                    borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\r\n                    borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\r\n                    borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\r\n                };\r\n\r\n                rectangle.pivot();\r\n            },\r\n\r\n            calculateBarBase: function(datasetIndex, index) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var yScale = me.getScaleForId(meta.yAxisID);\r\n                var base = 0;\r\n\r\n                if (yScale.options.stacked) {\r\n                    var chart = me.chart;\r\n                    var datasets = chart.data.datasets;\r\n                    var value = Number(datasets[datasetIndex].data[index]);\r\n\r\n                    for (var i = 0; i < datasetIndex; i++) {\r\n                        var currentDs = datasets[i];\r\n                        var currentDsMeta = chart.getDatasetMeta(i);\r\n                        if (currentDsMeta.bar && currentDsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\r\n                            var currentVal = Number(currentDs.data[index]);\r\n                            base += value < 0 ? Math.min(currentVal, 0) : Math.max(currentVal, 0);\r\n                        }\r\n                    }\r\n\r\n                    return yScale.getPixelForValue(base);\r\n                }\r\n\r\n                return yScale.getBasePixel();\r\n            },\r\n\r\n            getRuler: function(index) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var xScale = me.getScaleForId(meta.xAxisID);\r\n                var datasetCount = me.getBarCount();\r\n\r\n                var tickWidth;\r\n\r\n                if (xScale.options.type === 'category') {\r\n                    tickWidth = xScale.getPixelForTick(index + 1) - xScale.getPixelForTick(index);\r\n                } else {\r\n                    // Average width\r\n                    tickWidth = xScale.width / xScale.ticks.length;\r\n                }\r\n                var categoryWidth = tickWidth * xScale.options.categoryPercentage;\r\n                var categorySpacing = (tickWidth - (tickWidth * xScale.options.categoryPercentage)) / 2;\r\n                var fullBarWidth = categoryWidth / datasetCount;\r\n\r\n                if (xScale.ticks.length !== me.chart.data.labels.length) {\r\n                    var perc = xScale.ticks.length / me.chart.data.labels.length;\r\n                    fullBarWidth = fullBarWidth * perc;\r\n                }\r\n\r\n                var barWidth = fullBarWidth * xScale.options.barPercentage;\r\n                var barSpacing = fullBarWidth - (fullBarWidth * xScale.options.barPercentage);\r\n\r\n                return {\r\n                    datasetCount: datasetCount,\r\n                    tickWidth: tickWidth,\r\n                    categoryWidth: categoryWidth,\r\n                    categorySpacing: categorySpacing,\r\n                    fullBarWidth: fullBarWidth,\r\n                    barWidth: barWidth,\r\n                    barSpacing: barSpacing\r\n                };\r\n            },\r\n\r\n            calculateBarWidth: function(ruler) {\r\n                var xScale = this.getScaleForId(this.getMeta().xAxisID);\r\n                if (xScale.options.barThickness) {\r\n                    return xScale.options.barThickness;\r\n                }\r\n                return xScale.options.stacked ? ruler.categoryWidth : ruler.barWidth;\r\n            },\r\n\r\n            // Get bar index from the given dataset index accounting for the fact that not all bars are visible\r\n            getBarIndex: function(datasetIndex) {\r\n                var barIndex = 0;\r\n                var meta, j;\r\n\r\n                for (j = 0; j < datasetIndex; ++j) {\r\n                    meta = this.chart.getDatasetMeta(j);\r\n                    if (meta.bar && this.chart.isDatasetVisible(j)) {\r\n                        ++barIndex;\r\n                    }\r\n                }\r\n\r\n                return barIndex;\r\n            },\r\n\r\n            calculateBarX: function(index, datasetIndex, ruler) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var xScale = me.getScaleForId(meta.xAxisID);\r\n                var barIndex = me.getBarIndex(datasetIndex);\r\n                var leftTick = xScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\r\n                leftTick -= me.chart.isCombo ? (ruler.tickWidth / 2) : 0;\r\n\r\n                if (xScale.options.stacked) {\r\n                    return leftTick + (ruler.categoryWidth / 2) + ruler.categorySpacing;\r\n                }\r\n\r\n                return leftTick +\r\n                    (ruler.barWidth / 2) +\r\n                    ruler.categorySpacing +\r\n                    (ruler.barWidth * barIndex) +\r\n                    (ruler.barSpacing / 2) +\r\n                    (ruler.barSpacing * barIndex);\r\n            },\r\n\r\n            calculateBarY: function(index, datasetIndex) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var yScale = me.getScaleForId(meta.yAxisID);\r\n                var value = Number(me.getDataset().data[index]);\r\n\r\n                if (yScale.options.stacked) {\r\n\r\n                    var sumPos = 0,\r\n                        sumNeg = 0;\r\n\r\n                    for (var i = 0; i < datasetIndex; i++) {\r\n                        var ds = me.chart.data.datasets[i];\r\n                        var dsMeta = me.chart.getDatasetMeta(i);\r\n                        if (dsMeta.bar && dsMeta.yAxisID === yScale.id && me.chart.isDatasetVisible(i)) {\r\n                            var stackedVal = Number(ds.data[index]);\r\n                            if (stackedVal < 0) {\r\n                                sumNeg += stackedVal || 0;\r\n                            } else {\r\n                                sumPos += stackedVal || 0;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (value < 0) {\r\n                        return yScale.getPixelForValue(sumNeg + value);\r\n                    }\r\n                    return yScale.getPixelForValue(sumPos + value);\r\n                }\r\n\r\n                return yScale.getPixelForValue(value);\r\n            },\r\n\r\n            draw: function(ease) {\r\n                var me = this;\r\n                var easingDecimal = ease || 1;\r\n                var metaData = me.getMeta().data;\r\n                var dataset = me.getDataset();\r\n                var i, len;\r\n\r\n                for (i = 0, len = metaData.length; i < len; ++i) {\r\n                    var d = dataset.data[i];\r\n                    if (d !== null && d !== undefined && !isNaN(d)) {\r\n                        metaData[i].transition(easingDecimal).draw();\r\n                    }\r\n                }\r\n            },\r\n\r\n            setHoverStyle: function(rectangle) {\r\n                var dataset = this.chart.data.datasets[rectangle._datasetIndex];\r\n                var index = rectangle._index;\r\n\r\n                var custom = rectangle.custom || {};\r\n                var model = rectangle._model;\r\n                model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\r\n                model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\r\n                model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\r\n            },\r\n\r\n            removeHoverStyle: function(rectangle) {\r\n                var dataset = this.chart.data.datasets[rectangle._datasetIndex];\r\n                var index = rectangle._index;\r\n                var custom = rectangle.custom || {};\r\n                var model = rectangle._model;\r\n                var rectangleElementOptions = this.chart.options.elements.rectangle;\r\n\r\n                model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\r\n                model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\r\n                model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\r\n            }\r\n\r\n        });\r\n\r\n\r\n        // including horizontalBar in the bar file, instead of a file of its own\r\n        // it extends bar (like pie extends doughnut)\r\n        Chart.defaults.horizontalBar = {\r\n            hover: {\r\n                mode: 'label'\r\n            },\r\n\r\n            scales: {\r\n                xAxes: [{\r\n                    type: 'linear',\r\n                    position: 'bottom'\r\n                }],\r\n                yAxes: [{\r\n                    position: 'left',\r\n                    type: 'category',\r\n\r\n                    // Specific to Horizontal Bar Controller\r\n                    categoryPercentage: 0.8,\r\n                    barPercentage: 0.9,\r\n\r\n                    // grid line settings\r\n                    gridLines: {\r\n                        offsetGridLines: true\r\n                    }\r\n                }]\r\n            },\r\n            elements: {\r\n                rectangle: {\r\n                    borderSkipped: 'left'\r\n                }\r\n            },\r\n            tooltips: {\r\n                callbacks: {\r\n                    title: function(tooltipItems, data) {\r\n                        // Pick first xLabel for now\r\n                        var title = '';\r\n\r\n                        if (tooltipItems.length > 0) {\r\n                            if (tooltipItems[0].yLabel) {\r\n                                title = tooltipItems[0].yLabel;\r\n                            } else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {\r\n                                title = data.labels[tooltipItems[0].index];\r\n                            }\r\n                        }\r\n\r\n                        return title;\r\n                    },\r\n                    label: function(tooltipItem, data) {\r\n                        var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\r\n                        return datasetLabel + ': ' + tooltipItem.xLabel;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        Chart.controllers.horizontalBar = Chart.controllers.bar.extend({\r\n            updateElement: function(rectangle, index, reset) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var xScale = me.getScaleForId(meta.xAxisID);\r\n                var yScale = me.getScaleForId(meta.yAxisID);\r\n                var scaleBase = xScale.getBasePixel();\r\n                var custom = rectangle.custom || {};\r\n                var dataset = me.getDataset();\r\n                var rectangleElementOptions = me.chart.options.elements.rectangle;\r\n\r\n                rectangle._xScale = xScale;\r\n                rectangle._yScale = yScale;\r\n                rectangle._datasetIndex = me.index;\r\n                rectangle._index = index;\r\n\r\n                var ruler = me.getRuler(index);\r\n                rectangle._model = {\r\n                    x: reset ? scaleBase : me.calculateBarX(index, me.index),\r\n                    y: me.calculateBarY(index, me.index, ruler),\r\n\r\n                    // Tooltip\r\n                    label: me.chart.data.labels[index],\r\n                    datasetLabel: dataset.label,\r\n\r\n                    // Appearance\r\n                    base: reset ? scaleBase : me.calculateBarBase(me.index, index),\r\n                    height: me.calculateBarHeight(ruler),\r\n                    backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor),\r\n                    borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\r\n                    borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\r\n                    borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth)\r\n                };\r\n                rectangle.draw = function() {\r\n                    var ctx = this._chart.ctx;\r\n                    var vm = this._view;\r\n\r\n                    var halfHeight = vm.height / 2,\r\n                        topY = vm.y - halfHeight,\r\n                        bottomY = vm.y + halfHeight,\r\n                        right = vm.base - (vm.base - vm.x),\r\n                        halfStroke = vm.borderWidth / 2;\r\n\r\n                    // Canvas doesn't allow us to stroke inside the width so we can\r\n                    // adjust the sizes to fit if we're setting a stroke on the line\r\n                    if (vm.borderWidth) {\r\n                        topY += halfStroke;\r\n                        bottomY -= halfStroke;\r\n                        right += halfStroke;\r\n                    }\r\n\r\n                    ctx.beginPath();\r\n\r\n                    ctx.fillStyle = vm.backgroundColor;\r\n                    ctx.strokeStyle = vm.borderColor;\r\n                    ctx.lineWidth = vm.borderWidth;\r\n\r\n                    // Corner points, from bottom-left to bottom-right clockwise\r\n                    // | 1 2 |\r\n                    // | 0 3 |\r\n                    var corners = [\r\n                        [vm.base, bottomY],\r\n                        [vm.base, topY],\r\n                        [right, topY],\r\n                        [right, bottomY]\r\n                    ];\r\n\r\n                    // Find first (starting) corner with fallback to 'bottom'\r\n                    var borders = ['bottom', 'left', 'top', 'right'];\r\n                    var startCorner = borders.indexOf(vm.borderSkipped, 0);\r\n                    if (startCorner === -1) {\r\n                        startCorner = 0;\r\n                    }\r\n\r\n                    function cornerAt(cornerIndex) {\r\n                        return corners[(startCorner + cornerIndex) % 4];\r\n                    }\r\n\r\n                    // Draw rectangle from 'startCorner'\r\n                    ctx.moveTo.apply(ctx, cornerAt(0));\r\n                    for (var i = 1; i < 4; i++) {\r\n                        ctx.lineTo.apply(ctx, cornerAt(i));\r\n                    }\r\n\r\n                    ctx.fill();\r\n                    if (vm.borderWidth) {\r\n                        ctx.stroke();\r\n                    }\r\n                };\r\n\r\n                rectangle.pivot();\r\n            },\r\n\r\n            calculateBarBase: function(datasetIndex, index) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var xScale = me.getScaleForId(meta.xAxisID);\r\n                var base = 0;\r\n\r\n                if (xScale.options.stacked) {\r\n                    var chart = me.chart;\r\n                    var datasets = chart.data.datasets;\r\n                    var value = Number(datasets[datasetIndex].data[index]);\r\n\r\n                    for (var i = 0; i < datasetIndex; i++) {\r\n                        var currentDs = datasets[i];\r\n                        var currentDsMeta = chart.getDatasetMeta(i);\r\n                        if (currentDsMeta.bar && currentDsMeta.xAxisID === xScale.id && chart.isDatasetVisible(i)) {\r\n                            var currentVal = Number(currentDs.data[index]);\r\n                            base += value < 0 ? Math.min(currentVal, 0) : Math.max(currentVal, 0);\r\n                        }\r\n                    }\r\n\r\n                    return xScale.getPixelForValue(base);\r\n                }\r\n\r\n                return xScale.getBasePixel();\r\n            },\r\n\r\n            getRuler: function(index) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var yScale = me.getScaleForId(meta.yAxisID);\r\n                var datasetCount = me.getBarCount();\r\n\r\n                var tickHeight;\r\n                if (yScale.options.type === 'category') {\r\n                    tickHeight = yScale.getPixelForTick(index + 1) - yScale.getPixelForTick(index);\r\n                } else {\r\n                    // Average width\r\n                    tickHeight = yScale.width / yScale.ticks.length;\r\n                }\r\n                var categoryHeight = tickHeight * yScale.options.categoryPercentage;\r\n                var categorySpacing = (tickHeight - (tickHeight * yScale.options.categoryPercentage)) / 2;\r\n                var fullBarHeight = categoryHeight / datasetCount;\r\n\r\n                if (yScale.ticks.length !== me.chart.data.labels.length) {\r\n                    var perc = yScale.ticks.length / me.chart.data.labels.length;\r\n                    fullBarHeight = fullBarHeight * perc;\r\n                }\r\n\r\n                var barHeight = fullBarHeight * yScale.options.barPercentage;\r\n                var barSpacing = fullBarHeight - (fullBarHeight * yScale.options.barPercentage);\r\n\r\n                return {\r\n                    datasetCount: datasetCount,\r\n                    tickHeight: tickHeight,\r\n                    categoryHeight: categoryHeight,\r\n                    categorySpacing: categorySpacing,\r\n                    fullBarHeight: fullBarHeight,\r\n                    barHeight: barHeight,\r\n                    barSpacing: barSpacing\r\n                };\r\n            },\r\n\r\n            calculateBarHeight: function(ruler) {\r\n                var me = this;\r\n                var yScale = me.getScaleForId(me.getMeta().yAxisID);\r\n                if (yScale.options.barThickness) {\r\n                    return yScale.options.barThickness;\r\n                }\r\n                return yScale.options.stacked ? ruler.categoryHeight : ruler.barHeight;\r\n            },\r\n\r\n            calculateBarX: function(index, datasetIndex) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var xScale = me.getScaleForId(meta.xAxisID);\r\n                var value = Number(me.getDataset().data[index]);\r\n\r\n                if (xScale.options.stacked) {\r\n\r\n                    var sumPos = 0,\r\n                        sumNeg = 0;\r\n\r\n                    for (var i = 0; i < datasetIndex; i++) {\r\n                        var ds = me.chart.data.datasets[i];\r\n                        var dsMeta = me.chart.getDatasetMeta(i);\r\n                        if (dsMeta.bar && dsMeta.xAxisID === xScale.id && me.chart.isDatasetVisible(i)) {\r\n                            var stackedVal = Number(ds.data[index]);\r\n                            if (stackedVal < 0) {\r\n                                sumNeg += stackedVal || 0;\r\n                            } else {\r\n                                sumPos += stackedVal || 0;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (value < 0) {\r\n                        return xScale.getPixelForValue(sumNeg + value);\r\n                    }\r\n                    return xScale.getPixelForValue(sumPos + value);\r\n                }\r\n\r\n                return xScale.getPixelForValue(value);\r\n            },\r\n\r\n            calculateBarY: function(index, datasetIndex, ruler) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var yScale = me.getScaleForId(meta.yAxisID);\r\n                var barIndex = me.getBarIndex(datasetIndex);\r\n                var topTick = yScale.getPixelForValue(null, index, datasetIndex, me.chart.isCombo);\r\n                topTick -= me.chart.isCombo ? (ruler.tickHeight / 2) : 0;\r\n\r\n                if (yScale.options.stacked) {\r\n                    return topTick + (ruler.categoryHeight / 2) + ruler.categorySpacing;\r\n                }\r\n\r\n                return topTick +\r\n                    (ruler.barHeight / 2) +\r\n                    ruler.categorySpacing +\r\n                    (ruler.barHeight * barIndex) +\r\n                    (ruler.barSpacing / 2) +\r\n                    (ruler.barSpacing * barIndex);\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],16:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        Chart.defaults.bubble = {\r\n            hover: {\r\n                mode: 'single'\r\n            },\r\n\r\n            scales: {\r\n                xAxes: [{\r\n                    type: 'linear', // bubble should probably use a linear scale by default\r\n                    position: 'bottom',\r\n                    id: 'x-axis-0' // need an ID so datasets can reference the scale\r\n                }],\r\n                yAxes: [{\r\n                    type: 'linear',\r\n                    position: 'left',\r\n                    id: 'y-axis-0'\r\n                }]\r\n            },\r\n\r\n            tooltips: {\r\n                callbacks: {\r\n                    title: function() {\r\n                        // Title doesn't make sense for scatter since we format the data as a point\r\n                        return '';\r\n                    },\r\n                    label: function(tooltipItem, data) {\r\n                        var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\r\n                        var dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\r\n                        return datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        Chart.controllers.bubble = Chart.DatasetController.extend({\r\n\r\n            dataElementType: Chart.elements.Point,\r\n\r\n            update: function(reset) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var points = meta.data;\r\n\r\n                // Update Points\r\n                helpers.each(points, function(point, index) {\r\n                    me.updateElement(point, index, reset);\r\n                });\r\n            },\r\n\r\n            updateElement: function(point, index, reset) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var xScale = me.getScaleForId(meta.xAxisID);\r\n                var yScale = me.getScaleForId(meta.yAxisID);\r\n\r\n                var custom = point.custom || {};\r\n                var dataset = me.getDataset();\r\n                var data = dataset.data[index];\r\n                var pointElementOptions = me.chart.options.elements.point;\r\n                var dsIndex = me.index;\r\n\r\n                helpers.extend(point, {\r\n                    // Utility\r\n                    _xScale: xScale,\r\n                    _yScale: yScale,\r\n                    _datasetIndex: dsIndex,\r\n                    _index: index,\r\n\r\n                    // Desired view properties\r\n                    _model: {\r\n                        x: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),\r\n                        y: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),\r\n                        // Appearance\r\n                        radius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),\r\n\r\n                        // Tooltip\r\n                        hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\r\n                    }\r\n                });\r\n\r\n                // Trick to reset the styles of the point\r\n                Chart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);\r\n\r\n                var model = point._model;\r\n                model.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));\r\n\r\n                point.pivot();\r\n            },\r\n\r\n            getRadius: function(value) {\r\n                return value.r || this.chart.options.elements.point.radius;\r\n            },\r\n\r\n            setHoverStyle: function(point) {\r\n                var me = this;\r\n                Chart.DatasetController.prototype.setHoverStyle.call(me, point);\r\n\r\n                // Radius\r\n                var dataset = me.chart.data.datasets[point._datasetIndex];\r\n                var index = point._index;\r\n                var custom = point.custom || {};\r\n                var model = point._model;\r\n                model.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);\r\n            },\r\n\r\n            removeHoverStyle: function(point) {\r\n                var me = this;\r\n                Chart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);\r\n\r\n                var dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];\r\n                var custom = point.custom || {};\r\n                var model = point._model;\r\n\r\n                model.radius = custom.radius ? custom.radius : me.getRadius(dataVal);\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],17:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers,\r\n            defaults = Chart.defaults;\r\n\r\n        defaults.doughnut = {\r\n            animation: {\r\n                // Boolean - Whether we animate the rotation of the Doughnut\r\n                animateRotate: true,\r\n                // Boolean - Whether we animate scaling the Doughnut from the centre\r\n                animateScale: false\r\n            },\r\n            aspectRatio: 1,\r\n            hover: {\r\n                mode: 'single'\r\n            },\r\n            legendCallback: function(chart) {\r\n                var text = [];\r\n                text.push('<ul class=\"' + chart.id + '-legend\">');\r\n\r\n                var data = chart.data;\r\n                var datasets = data.datasets;\r\n                var labels = data.labels;\r\n\r\n                if (datasets.length) {\r\n                    for (var i = 0; i < datasets[0].data.length; ++i) {\r\n                        text.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\r\n                        if (labels[i]) {\r\n                            text.push(labels[i]);\r\n                        }\r\n                        text.push('</li>');\r\n                    }\r\n                }\r\n\r\n                text.push('</ul>');\r\n                return text.join('');\r\n            },\r\n            legend: {\r\n                labels: {\r\n                    generateLabels: function(chart) {\r\n                        var data = chart.data;\r\n                        if (data.labels.length && data.datasets.length) {\r\n                            return data.labels.map(function(label, i) {\r\n                                var meta = chart.getDatasetMeta(0);\r\n                                var ds = data.datasets[0];\r\n                                var arc = meta.data[i];\r\n                                var custom = arc && arc.custom || {};\r\n                                var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\r\n                                var arcOpts = chart.options.elements.arc;\r\n                                var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\r\n                                var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\r\n                                var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\r\n\r\n                                return {\r\n                                    text: label,\r\n                                    fillStyle: fill,\r\n                                    strokeStyle: stroke,\r\n                                    lineWidth: bw,\r\n                                    hidden: isNaN(ds.data[i]) || meta.data[i].hidden,\r\n\r\n                                    // Extra data used for toggling the correct item\r\n                                    index: i\r\n                                };\r\n                            });\r\n                        }\r\n                        return [];\r\n                    }\r\n                },\r\n\r\n                onClick: function(e, legendItem) {\r\n                    var index = legendItem.index;\r\n                    var chart = this.chart;\r\n                    var i, ilen, meta;\r\n\r\n                    for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n                        meta = chart.getDatasetMeta(i);\r\n                        // toggle visibility of index if exists\r\n                        if (meta.data[index]) {\r\n                            meta.data[index].hidden = !meta.data[index].hidden;\r\n                        }\r\n                    }\r\n\r\n                    chart.update();\r\n                }\r\n            },\r\n\r\n            // The percentage of the chart that we cut out of the middle.\r\n            cutoutPercentage: 50,\r\n\r\n            // The rotation of the chart, where the first data arc begins.\r\n            rotation: Math.PI * -0.5,\r\n\r\n            // The total circumference of the chart.\r\n            circumference: Math.PI * 2.0,\r\n\r\n            // Need to override these to give a nice default\r\n            tooltips: {\r\n                callbacks: {\r\n                    title: function() {\r\n                        return '';\r\n                    },\r\n                    label: function(tooltipItem, data) {\r\n                        var dataLabel = data.labels[tooltipItem.index];\r\n                        var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\r\n\r\n                        if (helpers.isArray(dataLabel)) {\r\n                            // show value on first line of multiline label\r\n                            // need to clone because we are changing the value\r\n                            dataLabel = dataLabel.slice();\r\n                            dataLabel[0] += value;\r\n                        } else {\r\n                            dataLabel += value;\r\n                        }\r\n\r\n                        return dataLabel;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        defaults.pie = helpers.clone(defaults.doughnut);\r\n        helpers.extend(defaults.pie, {\r\n            cutoutPercentage: 0\r\n        });\r\n\r\n\r\n        Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\r\n\r\n            dataElementType: Chart.elements.Arc,\r\n\r\n            linkScales: helpers.noop,\r\n\r\n            // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\r\n            getRingIndex: function(datasetIndex) {\r\n                var ringIndex = 0;\r\n\r\n                for (var j = 0; j < datasetIndex; ++j) {\r\n                    if (this.chart.isDatasetVisible(j)) {\r\n                        ++ringIndex;\r\n                    }\r\n                }\r\n\r\n                return ringIndex;\r\n            },\r\n\r\n            update: function(reset) {\r\n                var me = this;\r\n                var chart = me.chart,\r\n                    chartArea = chart.chartArea,\r\n                    opts = chart.options,\r\n                    arcOpts = opts.elements.arc,\r\n                    availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,\r\n                    availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,\r\n                    minSize = Math.min(availableWidth, availableHeight),\r\n                    offset = {\r\n                        x: 0,\r\n                        y: 0\r\n                    },\r\n                    meta = me.getMeta(),\r\n                    cutoutPercentage = opts.cutoutPercentage,\r\n                    circumference = opts.circumference;\r\n\r\n                // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\r\n                if (circumference < Math.PI * 2.0) {\r\n                    var startAngle = opts.rotation % (Math.PI * 2.0);\r\n                    startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\r\n                    var endAngle = startAngle + circumference;\r\n                    var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\r\n                    var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\r\n                    var contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\r\n                    var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\r\n                    var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\r\n                    var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\r\n                    var cutout = cutoutPercentage / 100.0;\r\n                    var min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\r\n                    var max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\r\n                    var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\r\n                    minSize = Math.min(availableWidth / size.width, availableHeight / size.height);\r\n                    offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\r\n                }\r\n\r\n                chart.borderWidth = me.getMaxBorderWidth(meta.data);\r\n                chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\r\n                chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 1, 0);\r\n                chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\r\n                chart.offsetX = offset.x * chart.outerRadius;\r\n                chart.offsetY = offset.y * chart.outerRadius;\r\n\r\n                meta.total = me.calculateTotal();\r\n\r\n                me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\r\n                me.innerRadius = me.outerRadius - chart.radiusLength;\r\n\r\n                helpers.each(meta.data, function(arc, index) {\r\n                    me.updateElement(arc, index, reset);\r\n                });\r\n            },\r\n\r\n            updateElement: function(arc, index, reset) {\r\n                var me = this;\r\n                var chart = me.chart,\r\n                    chartArea = chart.chartArea,\r\n                    opts = chart.options,\r\n                    animationOpts = opts.animation,\r\n                    centerX = (chartArea.left + chartArea.right) / 2,\r\n                    centerY = (chartArea.top + chartArea.bottom) / 2,\r\n                    startAngle = opts.rotation, // non reset case handled later\r\n                    endAngle = opts.rotation, // non reset case handled later\r\n                    dataset = me.getDataset(),\r\n                    circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),\r\n                    innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,\r\n                    outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,\r\n                    valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\r\n\r\n                helpers.extend(arc, {\r\n                    // Utility\r\n                    _datasetIndex: me.index,\r\n                    _index: index,\r\n\r\n                    // Desired view properties\r\n                    _model: {\r\n                        x: centerX + chart.offsetX,\r\n                        y: centerY + chart.offsetY,\r\n                        startAngle: startAngle,\r\n                        endAngle: endAngle,\r\n                        circumference: circumference,\r\n                        outerRadius: outerRadius,\r\n                        innerRadius: innerRadius,\r\n                        label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\r\n                    }\r\n                });\r\n\r\n                var model = arc._model;\r\n                // Resets the visual styles\r\n                this.removeHoverStyle(arc);\r\n\r\n                // Set correct angles if not resetting\r\n                if (!reset || !animationOpts.animateRotate) {\r\n                    if (index === 0) {\r\n                        model.startAngle = opts.rotation;\r\n                    } else {\r\n                        model.startAngle = me.getMeta().data[index - 1]._model.endAngle;\r\n                    }\r\n\r\n                    model.endAngle = model.startAngle + model.circumference;\r\n                }\r\n\r\n                arc.pivot();\r\n            },\r\n\r\n            removeHoverStyle: function(arc) {\r\n                Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\r\n            },\r\n\r\n            calculateTotal: function() {\r\n                var dataset = this.getDataset();\r\n                var meta = this.getMeta();\r\n                var total = 0;\r\n                var value;\r\n\r\n                helpers.each(meta.data, function(element, index) {\r\n                    value = dataset.data[index];\r\n                    if (!isNaN(value) && !element.hidden) {\r\n                        total += Math.abs(value);\r\n                    }\r\n                });\r\n\r\n                /* if (total === 0) {\r\n                 total = NaN;\r\n                 }*/\r\n\r\n                return total;\r\n            },\r\n\r\n            calculateCircumference: function(value) {\r\n                var total = this.getMeta().total;\r\n                if (total > 0 && !isNaN(value)) {\r\n                    return (Math.PI * 2.0) * (value / total);\r\n                }\r\n                return 0;\r\n            },\r\n\r\n            // gets the max border or hover width to properly scale pie charts\r\n            getMaxBorderWidth: function(elements) {\r\n                var max = 0,\r\n                    index = this.index,\r\n                    length = elements.length,\r\n                    borderWidth,\r\n                    hoverWidth;\r\n\r\n                for (var i = 0; i < length; i++) {\r\n                    borderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;\r\n                    hoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\r\n\r\n                    max = borderWidth > max ? borderWidth : max;\r\n                    max = hoverWidth > max ? hoverWidth : max;\r\n                }\r\n                return max;\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],18:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        Chart.defaults.line = {\r\n            showLines: true,\r\n            spanGaps: false,\r\n\r\n            hover: {\r\n                mode: 'label'\r\n            },\r\n\r\n            scales: {\r\n                xAxes: [{\r\n                    type: 'category',\r\n                    id: 'x-axis-0'\r\n                }],\r\n                yAxes: [{\r\n                    type: 'linear',\r\n                    id: 'y-axis-0'\r\n                }]\r\n            }\r\n        };\r\n\r\n        function lineEnabled(dataset, options) {\r\n            return helpers.getValueOrDefault(dataset.showLine, options.showLines);\r\n        }\r\n\r\n        Chart.controllers.line = Chart.DatasetController.extend({\r\n\r\n            datasetElementType: Chart.elements.Line,\r\n\r\n            dataElementType: Chart.elements.Point,\r\n\r\n            update: function(reset) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var line = meta.dataset;\r\n                var points = meta.data || [];\r\n                var options = me.chart.options;\r\n                var lineElementOptions = options.elements.line;\r\n                var scale = me.getScaleForId(meta.yAxisID);\r\n                var i, ilen, custom;\r\n                var dataset = me.getDataset();\r\n                var showLine = lineEnabled(dataset, options);\r\n\r\n                // Update Line\r\n                if (showLine) {\r\n                    custom = line.custom || {};\r\n\r\n                    // Compatibility: If the properties are defined with only the old name, use those values\r\n                    if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\r\n                        dataset.lineTension = dataset.tension;\r\n                    }\r\n\r\n                    // Utility\r\n                    line._scale = scale;\r\n                    line._datasetIndex = me.index;\r\n                    // Data\r\n                    line._children = points;\r\n                    // Model\r\n                    line._model = {\r\n                        // Appearance\r\n                        // The default behavior of lines is to break at null values, according\r\n                        // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\r\n                        // This option gives lines the ability to span gaps\r\n                        spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\r\n                        tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\r\n                        backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\r\n                        borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\r\n                        borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\r\n                        borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\r\n                        borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\r\n                        borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\r\n                        borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\r\n                        fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\r\n                        steppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\r\n                        cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\r\n                        // Scale\r\n                        scaleTop: scale.top,\r\n                        scaleBottom: scale.bottom,\r\n                        scaleZero: scale.getBasePixel()\r\n                    };\r\n\r\n                    line.pivot();\r\n                }\r\n\r\n                // Update Points\r\n                for (i=0, ilen=points.length; i<ilen; ++i) {\r\n                    me.updateElement(points[i], i, reset);\r\n                }\r\n\r\n                if (showLine && line._model.tension !== 0) {\r\n                    me.updateBezierControlPoints();\r\n                }\r\n\r\n                // Now pivot the point for animation\r\n                for (i=0, ilen=points.length; i<ilen; ++i) {\r\n                    points[i].pivot();\r\n                }\r\n            },\r\n\r\n            getPointBackgroundColor: function(point, index) {\r\n                var backgroundColor = this.chart.options.elements.point.backgroundColor;\r\n                var dataset = this.getDataset();\r\n                var custom = point.custom || {};\r\n\r\n                if (custom.backgroundColor) {\r\n                    backgroundColor = custom.backgroundColor;\r\n                } else if (dataset.pointBackgroundColor) {\r\n                    backgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\r\n                } else if (dataset.backgroundColor) {\r\n                    backgroundColor = dataset.backgroundColor;\r\n                }\r\n\r\n                return backgroundColor;\r\n            },\r\n\r\n            getPointBorderColor: function(point, index) {\r\n                var borderColor = this.chart.options.elements.point.borderColor;\r\n                var dataset = this.getDataset();\r\n                var custom = point.custom || {};\r\n\r\n                if (custom.borderColor) {\r\n                    borderColor = custom.borderColor;\r\n                } else if (dataset.pointBorderColor) {\r\n                    borderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\r\n                } else if (dataset.borderColor) {\r\n                    borderColor = dataset.borderColor;\r\n                }\r\n\r\n                return borderColor;\r\n            },\r\n\r\n            getPointBorderWidth: function(point, index) {\r\n                var borderWidth = this.chart.options.elements.point.borderWidth;\r\n                var dataset = this.getDataset();\r\n                var custom = point.custom || {};\r\n\r\n                if (custom.borderWidth) {\r\n                    borderWidth = custom.borderWidth;\r\n                } else if (dataset.pointBorderWidth) {\r\n                    borderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\r\n                } else if (dataset.borderWidth) {\r\n                    borderWidth = dataset.borderWidth;\r\n                }\r\n\r\n                return borderWidth;\r\n            },\r\n\r\n            updateElement: function(point, index, reset) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var custom = point.custom || {};\r\n                var dataset = me.getDataset();\r\n                var datasetIndex = me.index;\r\n                var value = dataset.data[index];\r\n                var yScale = me.getScaleForId(meta.yAxisID);\r\n                var xScale = me.getScaleForId(meta.xAxisID);\r\n                var pointOptions = me.chart.options.elements.point;\r\n                var x, y;\r\n                var labels = me.chart.data.labels || [];\r\n                var includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;\r\n\r\n                // Compatibility: If the properties are defined with only the old name, use those values\r\n                if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\r\n                    dataset.pointRadius = dataset.radius;\r\n                }\r\n                if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\r\n                    dataset.pointHitRadius = dataset.hitRadius;\r\n                }\r\n\r\n                x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);\r\n                y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\r\n\r\n                // Utility\r\n                point._xScale = xScale;\r\n                point._yScale = yScale;\r\n                point._datasetIndex = datasetIndex;\r\n                point._index = index;\r\n\r\n                // Desired view properties\r\n                point._model = {\r\n                    x: x,\r\n                    y: y,\r\n                    skip: custom.skip || isNaN(x) || isNaN(y),\r\n                    // Appearance\r\n                    radius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\r\n                    pointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\r\n                    backgroundColor: me.getPointBackgroundColor(point, index),\r\n                    borderColor: me.getPointBorderColor(point, index),\r\n                    borderWidth: me.getPointBorderWidth(point, index),\r\n                    tension: meta.dataset._model ? meta.dataset._model.tension : 0,\r\n                    steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\r\n                    // Tooltip\r\n                    hitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\r\n                };\r\n            },\r\n\r\n            calculatePointY: function(value, index, datasetIndex) {\r\n                var me = this;\r\n                var chart = me.chart;\r\n                var meta = me.getMeta();\r\n                var yScale = me.getScaleForId(meta.yAxisID);\r\n                var sumPos = 0;\r\n                var sumNeg = 0;\r\n                var i, ds, dsMeta;\r\n\r\n                if (yScale.options.stacked) {\r\n                    for (i = 0; i < datasetIndex; i++) {\r\n                        ds = chart.data.datasets[i];\r\n                        dsMeta = chart.getDatasetMeta(i);\r\n                        if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\r\n                            var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\r\n                            if (stackedRightValue < 0) {\r\n                                sumNeg += stackedRightValue || 0;\r\n                            } else {\r\n                                sumPos += stackedRightValue || 0;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    var rightValue = Number(yScale.getRightValue(value));\r\n                    if (rightValue < 0) {\r\n                        return yScale.getPixelForValue(sumNeg + rightValue);\r\n                    }\r\n                    return yScale.getPixelForValue(sumPos + rightValue);\r\n                }\r\n\r\n                return yScale.getPixelForValue(value);\r\n            },\r\n\r\n            updateBezierControlPoints: function() {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var area = me.chart.chartArea;\r\n                var points = (meta.data || []);\r\n                var i, ilen, point, model, controlPoints;\r\n\r\n                // Only consider points that are drawn in case the spanGaps option is used\r\n                if (meta.dataset._model.spanGaps) {\r\n                    points = points.filter(function(pt) {\r\n                        return !pt._model.skip;\r\n                    });\r\n                }\r\n\r\n                function capControlPoint(pt, min, max) {\r\n                    return Math.max(Math.min(pt, max), min);\r\n                }\r\n\r\n                if (meta.dataset._model.cubicInterpolationMode === 'monotone') {\r\n                    helpers.splineCurveMonotone(points);\r\n                } else {\r\n                    for (i = 0, ilen = points.length; i < ilen; ++i) {\r\n                        point = points[i];\r\n                        model = point._model;\r\n                        controlPoints = helpers.splineCurve(\r\n                            helpers.previousItem(points, i)._model,\r\n                            model,\r\n                            helpers.nextItem(points, i)._model,\r\n                            meta.dataset._model.tension\r\n                        );\r\n                        model.controlPointPreviousX = controlPoints.previous.x;\r\n                        model.controlPointPreviousY = controlPoints.previous.y;\r\n                        model.controlPointNextX = controlPoints.next.x;\r\n                        model.controlPointNextY = controlPoints.next.y;\r\n                    }\r\n                }\r\n\r\n                if (me.chart.options.elements.line.capBezierPoints) {\r\n                    for (i = 0, ilen = points.length; i < ilen; ++i) {\r\n                        model = points[i]._model;\r\n                        model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\r\n                        model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\r\n                        model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\r\n                        model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\r\n                    }\r\n                }\r\n            },\r\n\r\n            draw: function(ease) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var points = meta.data || [];\r\n                var easingDecimal = ease || 1;\r\n                var i, ilen;\r\n\r\n                // Transition Point Locations\r\n                for (i=0, ilen=points.length; i<ilen; ++i) {\r\n                    points[i].transition(easingDecimal);\r\n                }\r\n\r\n                // Transition and Draw the line\r\n                if (lineEnabled(me.getDataset(), me.chart.options)) {\r\n                    meta.dataset.transition(easingDecimal).draw();\r\n                }\r\n\r\n                // Draw the points\r\n                for (i=0, ilen=points.length; i<ilen; ++i) {\r\n                    points[i].draw();\r\n                }\r\n            },\r\n\r\n            setHoverStyle: function(point) {\r\n                // Point\r\n                var dataset = this.chart.data.datasets[point._datasetIndex];\r\n                var index = point._index;\r\n                var custom = point.custom || {};\r\n                var model = point._model;\r\n\r\n                model.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\r\n                model.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\r\n                model.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\r\n                model.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\r\n            },\r\n\r\n            removeHoverStyle: function(point) {\r\n                var me = this;\r\n                var dataset = me.chart.data.datasets[point._datasetIndex];\r\n                var index = point._index;\r\n                var custom = point.custom || {};\r\n                var model = point._model;\r\n\r\n                // Compatibility: If the properties are defined with only the old name, use those values\r\n                if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\r\n                    dataset.pointRadius = dataset.radius;\r\n                }\r\n\r\n                model.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\r\n                model.backgroundColor = me.getPointBackgroundColor(point, index);\r\n                model.borderColor = me.getPointBorderColor(point, index);\r\n                model.borderWidth = me.getPointBorderWidth(point, index);\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],19:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        Chart.defaults.polarArea = {\r\n\r\n            scale: {\r\n                type: 'radialLinear',\r\n                lineArc: true, // so that lines are circular\r\n                ticks: {\r\n                    beginAtZero: true\r\n                }\r\n            },\r\n\r\n            // Boolean - Whether to animate the rotation of the chart\r\n            animation: {\r\n                animateRotate: true,\r\n                animateScale: true\r\n            },\r\n\r\n            startAngle: -0.5 * Math.PI,\r\n            aspectRatio: 1,\r\n            legendCallback: function(chart) {\r\n                var text = [];\r\n                text.push('<ul class=\"' + chart.id + '-legend\">');\r\n\r\n                var data = chart.data;\r\n                var datasets = data.datasets;\r\n                var labels = data.labels;\r\n\r\n                if (datasets.length) {\r\n                    for (var i = 0; i < datasets[0].data.length; ++i) {\r\n                        text.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\r\n                        if (labels[i]) {\r\n                            text.push(labels[i]);\r\n                        }\r\n                        text.push('</li>');\r\n                    }\r\n                }\r\n\r\n                text.push('</ul>');\r\n                return text.join('');\r\n            },\r\n            legend: {\r\n                labels: {\r\n                    generateLabels: function(chart) {\r\n                        var data = chart.data;\r\n                        if (data.labels.length && data.datasets.length) {\r\n                            return data.labels.map(function(label, i) {\r\n                                var meta = chart.getDatasetMeta(0);\r\n                                var ds = data.datasets[0];\r\n                                var arc = meta.data[i];\r\n                                var custom = arc.custom || {};\r\n                                var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\r\n                                var arcOpts = chart.options.elements.arc;\r\n                                var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\r\n                                var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\r\n                                var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\r\n\r\n                                return {\r\n                                    text: label,\r\n                                    fillStyle: fill,\r\n                                    strokeStyle: stroke,\r\n                                    lineWidth: bw,\r\n                                    hidden: isNaN(ds.data[i]) || meta.data[i].hidden,\r\n\r\n                                    // Extra data used for toggling the correct item\r\n                                    index: i\r\n                                };\r\n                            });\r\n                        }\r\n                        return [];\r\n                    }\r\n                },\r\n\r\n                onClick: function(e, legendItem) {\r\n                    var index = legendItem.index;\r\n                    var chart = this.chart;\r\n                    var i, ilen, meta;\r\n\r\n                    for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\r\n                        meta = chart.getDatasetMeta(i);\r\n                        meta.data[index].hidden = !meta.data[index].hidden;\r\n                    }\r\n\r\n                    chart.update();\r\n                }\r\n            },\r\n\r\n            // Need to override these to give a nice default\r\n            tooltips: {\r\n                callbacks: {\r\n                    title: function() {\r\n                        return '';\r\n                    },\r\n                    label: function(tooltipItem, data) {\r\n                        return data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        Chart.controllers.polarArea = Chart.DatasetController.extend({\r\n\r\n            dataElementType: Chart.elements.Arc,\r\n\r\n            linkScales: helpers.noop,\r\n\r\n            update: function(reset) {\r\n                var me = this;\r\n                var chart = me.chart;\r\n                var chartArea = chart.chartArea;\r\n                var meta = me.getMeta();\r\n                var opts = chart.options;\r\n                var arcOpts = opts.elements.arc;\r\n                var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\r\n                chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\r\n                chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\r\n                chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\r\n\r\n                me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\r\n                me.innerRadius = me.outerRadius - chart.radiusLength;\r\n\r\n                meta.count = me.countVisibleElements();\r\n\r\n                helpers.each(meta.data, function(arc, index) {\r\n                    me.updateElement(arc, index, reset);\r\n                });\r\n            },\r\n\r\n            updateElement: function(arc, index, reset) {\r\n                var me = this;\r\n                var chart = me.chart;\r\n                var dataset = me.getDataset();\r\n                var opts = chart.options;\r\n                var animationOpts = opts.animation;\r\n                var scale = chart.scale;\r\n                var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\r\n                var labels = chart.data.labels;\r\n\r\n                var circumference = me.calculateCircumference(dataset.data[index]);\r\n                var centerX = scale.xCenter;\r\n                var centerY = scale.yCenter;\r\n\r\n                // If there is NaN data before us, we need to calculate the starting angle correctly.\r\n                // We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\r\n                var visibleCount = 0;\r\n                var meta = me.getMeta();\r\n                for (var i = 0; i < index; ++i) {\r\n                    if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\r\n                        ++visibleCount;\r\n                    }\r\n                }\r\n\r\n                // var negHalfPI = -0.5 * Math.PI;\r\n                var datasetStartAngle = opts.startAngle;\r\n                var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\r\n                var startAngle = datasetStartAngle + (circumference * visibleCount);\r\n                var endAngle = startAngle + (arc.hidden ? 0 : circumference);\r\n\r\n                var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\r\n\r\n                helpers.extend(arc, {\r\n                    // Utility\r\n                    _datasetIndex: me.index,\r\n                    _index: index,\r\n                    _scale: scale,\r\n\r\n                    // Desired view properties\r\n                    _model: {\r\n                        x: centerX,\r\n                        y: centerY,\r\n                        innerRadius: 0,\r\n                        outerRadius: reset ? resetRadius : distance,\r\n                        startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\r\n                        endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\r\n                        label: getValueAtIndexOrDefault(labels, index, labels[index])\r\n                    }\r\n                });\r\n\r\n                // Apply border and fill style\r\n                me.removeHoverStyle(arc);\r\n\r\n                arc.pivot();\r\n            },\r\n\r\n            removeHoverStyle: function(arc) {\r\n                Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\r\n            },\r\n\r\n            countVisibleElements: function() {\r\n                var dataset = this.getDataset();\r\n                var meta = this.getMeta();\r\n                var count = 0;\r\n\r\n                helpers.each(meta.data, function(element, index) {\r\n                    if (!isNaN(dataset.data[index]) && !element.hidden) {\r\n                        count++;\r\n                    }\r\n                });\r\n\r\n                return count;\r\n            },\r\n\r\n            calculateCircumference: function(value) {\r\n                var count = this.getMeta().count;\r\n                if (count > 0 && !isNaN(value)) {\r\n                    return (2 * Math.PI) / count;\r\n                }\r\n                return 0;\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],20:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        Chart.defaults.radar = {\r\n            aspectRatio: 1,\r\n            scale: {\r\n                type: 'radialLinear'\r\n            },\r\n            elements: {\r\n                line: {\r\n                    tension: 0 // no bezier in radar\r\n                }\r\n            }\r\n        };\r\n\r\n        Chart.controllers.radar = Chart.DatasetController.extend({\r\n\r\n            datasetElementType: Chart.elements.Line,\r\n\r\n            dataElementType: Chart.elements.Point,\r\n\r\n            linkScales: helpers.noop,\r\n\r\n            update: function(reset) {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var line = meta.dataset;\r\n                var points = meta.data;\r\n                var custom = line.custom || {};\r\n                var dataset = me.getDataset();\r\n                var lineElementOptions = me.chart.options.elements.line;\r\n                var scale = me.chart.scale;\r\n\r\n                // Compatibility: If the properties are defined with only the old name, use those values\r\n                if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\r\n                    dataset.lineTension = dataset.tension;\r\n                }\r\n\r\n                helpers.extend(meta.dataset, {\r\n                    // Utility\r\n                    _datasetIndex: me.index,\r\n                    // Data\r\n                    _children: points,\r\n                    _loop: true,\r\n                    // Model\r\n                    _model: {\r\n                        // Appearance\r\n                        tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\r\n                        backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\r\n                        borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\r\n                        borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\r\n                        fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\r\n                        borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\r\n                        borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\r\n                        borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\r\n                        borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\r\n\r\n                        // Scale\r\n                        scaleTop: scale.top,\r\n                        scaleBottom: scale.bottom,\r\n                        scaleZero: scale.getBasePosition()\r\n                    }\r\n                });\r\n\r\n                meta.dataset.pivot();\r\n\r\n                // Update Points\r\n                helpers.each(points, function(point, index) {\r\n                    me.updateElement(point, index, reset);\r\n                }, me);\r\n\r\n                // Update bezier control points\r\n                me.updateBezierControlPoints();\r\n            },\r\n            updateElement: function(point, index, reset) {\r\n                var me = this;\r\n                var custom = point.custom || {};\r\n                var dataset = me.getDataset();\r\n                var scale = me.chart.scale;\r\n                var pointElementOptions = me.chart.options.elements.point;\r\n                var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\r\n\r\n                helpers.extend(point, {\r\n                    // Utility\r\n                    _datasetIndex: me.index,\r\n                    _index: index,\r\n                    _scale: scale,\r\n\r\n                    // Desired view properties\r\n                    _model: {\r\n                        x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\r\n                        y: reset ? scale.yCenter : pointPosition.y,\r\n\r\n                        // Appearance\r\n                        tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.tension, me.chart.options.elements.line.tension),\r\n                        radius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\r\n                        backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\r\n                        borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\r\n                        borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\r\n                        pointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\r\n\r\n                        // Tooltip\r\n                        hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\r\n                    }\r\n                });\r\n\r\n                point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\r\n            },\r\n            updateBezierControlPoints: function() {\r\n                var chartArea = this.chart.chartArea;\r\n                var meta = this.getMeta();\r\n\r\n                helpers.each(meta.data, function(point, index) {\r\n                    var model = point._model;\r\n                    var controlPoints = helpers.splineCurve(\r\n                        helpers.previousItem(meta.data, index, true)._model,\r\n                        model,\r\n                        helpers.nextItem(meta.data, index, true)._model,\r\n                        model.tension\r\n                    );\r\n\r\n                    // Prevent the bezier going outside of the bounds of the graph\r\n                    model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\r\n                    model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\r\n\r\n                    model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\r\n                    model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\r\n\r\n                    // Now pivot the point for animation\r\n                    point.pivot();\r\n                });\r\n            },\r\n\r\n            draw: function(ease) {\r\n                var meta = this.getMeta();\r\n                var easingDecimal = ease || 1;\r\n\r\n                // Transition Point Locations\r\n                helpers.each(meta.data, function(point) {\r\n                    point.transition(easingDecimal);\r\n                });\r\n\r\n                // Transition and Draw the line\r\n                meta.dataset.transition(easingDecimal).draw();\r\n\r\n                // Draw the points\r\n                helpers.each(meta.data, function(point) {\r\n                    point.draw();\r\n                });\r\n            },\r\n\r\n            setHoverStyle: function(point) {\r\n                // Point\r\n                var dataset = this.chart.data.datasets[point._datasetIndex];\r\n                var custom = point.custom || {};\r\n                var index = point._index;\r\n                var model = point._model;\r\n\r\n                model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\r\n                model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\r\n                model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\r\n                model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\r\n            },\r\n\r\n            removeHoverStyle: function(point) {\r\n                var dataset = this.chart.data.datasets[point._datasetIndex];\r\n                var custom = point.custom || {};\r\n                var index = point._index;\r\n                var model = point._model;\r\n                var pointElementOptions = this.chart.options.elements.point;\r\n\r\n                model.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.radius, index, pointElementOptions.radius);\r\n                model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\r\n                model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\r\n                model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],21:[function(require,module,exports){\r\n    /* global window: false */\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        Chart.defaults.global.animation = {\r\n            duration: 1000,\r\n            easing: 'easeOutQuart',\r\n            onProgress: helpers.noop,\r\n            onComplete: helpers.noop\r\n        };\r\n\r\n        Chart.Animation = Chart.Element.extend({\r\n            currentStep: null, // the current animation step\r\n            numSteps: 60, // default number of steps\r\n            easing: '', // the easing to use for this animation\r\n            render: null, // render function used by the animation service\r\n\r\n            onAnimationProgress: null, // user specified callback to fire on each step of the animation\r\n            onAnimationComplete: null // user specified callback to fire when the animation finishes\r\n        });\r\n\r\n        Chart.animationService = {\r\n            frameDuration: 17,\r\n            animations: [],\r\n            dropFrames: 0,\r\n            request: null,\r\n\r\n            /**\r\n             * @function Chart.animationService.addAnimation\r\n             * @param chartInstance {ChartController} the chart to animate\r\n             * @param animationObject {IAnimation} the animation that we will animate\r\n             * @param duration {Number} length of animation in ms\r\n             * @param lazy {Boolean} if true, the chart is not marked as animating to enable more responsive interactions\r\n             */\r\n            addAnimation: function(chartInstance, animationObject, duration, lazy) {\r\n                var me = this;\r\n\r\n                if (!lazy) {\r\n                    chartInstance.animating = true;\r\n                }\r\n\r\n                for (var index = 0; index < me.animations.length; ++index) {\r\n                    if (me.animations[index].chartInstance === chartInstance) {\r\n                        // replacing an in progress animation\r\n                        me.animations[index].animationObject = animationObject;\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                me.animations.push({\r\n                    chartInstance: chartInstance,\r\n                    animationObject: animationObject\r\n                });\r\n\r\n                // If there are no animations queued, manually kickstart a digest, for lack of a better word\r\n                if (me.animations.length === 1) {\r\n                    me.requestAnimationFrame();\r\n                }\r\n            },\r\n            // Cancel the animation for a given chart instance\r\n            cancelAnimation: function(chartInstance) {\r\n                var index = helpers.findIndex(this.animations, function(animationWrapper) {\r\n                    return animationWrapper.chartInstance === chartInstance;\r\n                });\r\n\r\n                if (index !== -1) {\r\n                    this.animations.splice(index, 1);\r\n                    chartInstance.animating = false;\r\n                }\r\n            },\r\n            requestAnimationFrame: function() {\r\n                var me = this;\r\n                if (me.request === null) {\r\n                    // Skip animation frame requests until the active one is executed.\r\n                    // This can happen when processing mouse events, e.g. 'mousemove'\r\n                    // and 'mouseout' events will trigger multiple renders.\r\n                    me.request = helpers.requestAnimFrame.call(window, function() {\r\n                        me.request = null;\r\n                        me.startDigest();\r\n                    });\r\n                }\r\n            },\r\n            startDigest: function() {\r\n                var me = this;\r\n\r\n                var startTime = Date.now();\r\n                var framesToDrop = 0;\r\n\r\n                if (me.dropFrames > 1) {\r\n                    framesToDrop = Math.floor(me.dropFrames);\r\n                    me.dropFrames = me.dropFrames % 1;\r\n                }\r\n\r\n                var i = 0;\r\n                while (i < me.animations.length) {\r\n                    if (me.animations[i].animationObject.currentStep === null) {\r\n                        me.animations[i].animationObject.currentStep = 0;\r\n                    }\r\n\r\n                    me.animations[i].animationObject.currentStep += 1 + framesToDrop;\r\n\r\n                    if (me.animations[i].animationObject.currentStep > me.animations[i].animationObject.numSteps) {\r\n                        me.animations[i].animationObject.currentStep = me.animations[i].animationObject.numSteps;\r\n                    }\r\n\r\n                    me.animations[i].animationObject.render(me.animations[i].chartInstance, me.animations[i].animationObject);\r\n                    if (me.animations[i].animationObject.onAnimationProgress && me.animations[i].animationObject.onAnimationProgress.call) {\r\n                        me.animations[i].animationObject.onAnimationProgress.call(me.animations[i].chartInstance, me.animations[i]);\r\n                    }\r\n\r\n                    if (me.animations[i].animationObject.currentStep === me.animations[i].animationObject.numSteps) {\r\n                        if (me.animations[i].animationObject.onAnimationComplete && me.animations[i].animationObject.onAnimationComplete.call) {\r\n                            me.animations[i].animationObject.onAnimationComplete.call(me.animations[i].chartInstance, me.animations[i]);\r\n                        }\r\n\r\n                        // executed the last frame. Remove the animation.\r\n                        me.animations[i].chartInstance.animating = false;\r\n\r\n                        me.animations.splice(i, 1);\r\n                    } else {\r\n                        ++i;\r\n                    }\r\n                }\r\n\r\n                var endTime = Date.now();\r\n                var dropFrames = (endTime - startTime) / me.frameDuration;\r\n\r\n                me.dropFrames += dropFrames;\r\n\r\n                // Do we have more stuff to animate?\r\n                if (me.animations.length > 0) {\r\n                    me.requestAnimationFrame();\r\n                }\r\n            }\r\n        };\r\n    };\r\n\r\n},{}],22:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n        // Global Chart canvas helpers object for drawing items to canvas\r\n        var helpers = Chart.canvasHelpers = {};\r\n\r\n        helpers.drawPoint = function(ctx, pointStyle, radius, x, y) {\r\n            var type, edgeLength, xOffset, yOffset, height, size;\r\n\r\n            if (typeof pointStyle === 'object') {\r\n                type = pointStyle.toString();\r\n                if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\r\n                    ctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (isNaN(radius) || radius <= 0) {\r\n                return;\r\n            }\r\n\r\n            switch (pointStyle) {\r\n                // Default includes circle\r\n                default:\r\n                    ctx.beginPath();\r\n                    ctx.arc(x, y, radius, 0, Math.PI * 2);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                    break;\r\n                case 'triangle':\r\n                    ctx.beginPath();\r\n                    edgeLength = 3 * radius / Math.sqrt(3);\r\n                    height = edgeLength * Math.sqrt(3) / 2;\r\n                    ctx.moveTo(x - edgeLength / 2, y + height / 3);\r\n                    ctx.lineTo(x + edgeLength / 2, y + height / 3);\r\n                    ctx.lineTo(x, y - 2 * height / 3);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                    break;\r\n                case 'rect':\r\n                    size = 1 / Math.SQRT2 * radius;\r\n                    ctx.beginPath();\r\n                    ctx.fillRect(x - size, y - size, 2 * size, 2 * size);\r\n                    ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\r\n                    break;\r\n                case 'rectRot':\r\n                    size = 1 / Math.SQRT2 * radius;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(x - size, y);\r\n                    ctx.lineTo(x, y + size);\r\n                    ctx.lineTo(x + size, y);\r\n                    ctx.lineTo(x, y - size);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                    break;\r\n                case 'cross':\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(x, y + radius);\r\n                    ctx.lineTo(x, y - radius);\r\n                    ctx.moveTo(x - radius, y);\r\n                    ctx.lineTo(x + radius, y);\r\n                    ctx.closePath();\r\n                    break;\r\n                case 'crossRot':\r\n                    ctx.beginPath();\r\n                    xOffset = Math.cos(Math.PI / 4) * radius;\r\n                    yOffset = Math.sin(Math.PI / 4) * radius;\r\n                    ctx.moveTo(x - xOffset, y - yOffset);\r\n                    ctx.lineTo(x + xOffset, y + yOffset);\r\n                    ctx.moveTo(x - xOffset, y + yOffset);\r\n                    ctx.lineTo(x + xOffset, y - yOffset);\r\n                    ctx.closePath();\r\n                    break;\r\n                case 'star':\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(x, y + radius);\r\n                    ctx.lineTo(x, y - radius);\r\n                    ctx.moveTo(x - radius, y);\r\n                    ctx.lineTo(x + radius, y);\r\n                    xOffset = Math.cos(Math.PI / 4) * radius;\r\n                    yOffset = Math.sin(Math.PI / 4) * radius;\r\n                    ctx.moveTo(x - xOffset, y - yOffset);\r\n                    ctx.lineTo(x + xOffset, y + yOffset);\r\n                    ctx.moveTo(x - xOffset, y + yOffset);\r\n                    ctx.lineTo(x + xOffset, y - yOffset);\r\n                    ctx.closePath();\r\n                    break;\r\n                case 'line':\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(x - radius, y);\r\n                    ctx.lineTo(x + radius, y);\r\n                    ctx.closePath();\r\n                    break;\r\n                case 'dash':\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(x, y);\r\n                    ctx.lineTo(x + radius, y);\r\n                    ctx.closePath();\r\n                    break;\r\n            }\r\n\r\n            ctx.stroke();\r\n        };\r\n    };\r\n\r\n},{}],23:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        // Create a dictionary of chart types, to allow for extension of existing types\r\n        Chart.types = {};\r\n\r\n        // Store a reference to each instance - allowing us to globally resize chart instances on window resize.\r\n        // Destroy method on the chart will remove the instance of the chart from this reference.\r\n        Chart.instances = {};\r\n\r\n        // Controllers available for dataset visualization eg. bar, line, slice, etc.\r\n        Chart.controllers = {};\r\n\r\n        /**\r\n         * The \"used\" size is the final value of a dimension property after all calculations have\r\n         * been performed. This method uses the computed style of `element` but returns undefined\r\n         * if the computed style is not expressed in pixels. That can happen in some cases where\r\n         * `element` has a size relative to its parent and this last one is not yet displayed,\r\n         * for example because of `display: none` on a parent node.\r\n         * TODO(SB) Move this method in the upcoming core.platform class.\r\n         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\r\n         * @returns {Number} Size in pixels or undefined if unknown.\r\n         */\r\n        function readUsedSize(element, property) {\r\n            var value = helpers.getStyle(element, property);\r\n            var matches = value && value.match(/(\\d+)px/);\r\n            return matches? Number(matches[1]) : undefined;\r\n        }\r\n\r\n        /**\r\n         * Initializes the canvas style and render size without modifying the canvas display size,\r\n         * since responsiveness is handled by the controller.resize() method. The config is used\r\n         * to determine the aspect ratio to apply in case no explicit height has been specified.\r\n         * TODO(SB) Move this method in the upcoming core.platform class.\r\n         */\r\n        function initCanvas(canvas, config) {\r\n            var style = canvas.style;\r\n\r\n            // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\r\n            // returns null or '' if no explicit value has been set to the canvas attribute.\r\n            var renderHeight = canvas.getAttribute('height');\r\n            var renderWidth = canvas.getAttribute('width');\r\n\r\n            // Chart.js modifies some canvas values that we want to restore on destroy\r\n            canvas._chartjs = {\r\n                initial: {\r\n                    height: renderHeight,\r\n                    width: renderWidth,\r\n                    style: {\r\n                        display: style.display,\r\n                        height: style.height,\r\n                        width: style.width\r\n                    }\r\n                }\r\n            };\r\n\r\n            // Force canvas to display as block to avoid extra space caused by inline\r\n            // elements, which would interfere with the responsive resize process.\r\n            // https://github.com/chartjs/Chart.js/issues/2538\r\n            style.display = style.display || 'block';\r\n\r\n            if (renderWidth === null || renderWidth === '') {\r\n                var displayWidth = readUsedSize(canvas, 'width');\r\n                if (displayWidth !== undefined) {\r\n                    canvas.width = displayWidth;\r\n                }\r\n            }\r\n\r\n            if (renderHeight === null || renderHeight === '') {\r\n                if (canvas.style.height === '') {\r\n                    // If no explicit render height and style height, let's apply the aspect ratio,\r\n                    // which one can be specified by the user but also by charts as default option\r\n                    // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\r\n                    canvas.height = canvas.width / (config.options.aspectRatio || 2);\r\n                } else {\r\n                    var displayHeight = readUsedSize(canvas, 'height');\r\n                    if (displayWidth !== undefined) {\r\n                        canvas.height = displayHeight;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return canvas;\r\n        }\r\n\r\n        /**\r\n         * Restores the canvas initial state, such as render/display sizes and style.\r\n         * TODO(SB) Move this method in the upcoming core.platform class.\r\n         */\r\n        function releaseCanvas(canvas) {\r\n            if (!canvas._chartjs) {\r\n                return;\r\n            }\r\n\r\n            var initial = canvas._chartjs.initial;\r\n            ['height', 'width'].forEach(function(prop) {\r\n                var value = initial[prop];\r\n                if (value === undefined || value === null) {\r\n                    canvas.removeAttribute(prop);\r\n                } else {\r\n                    canvas.setAttribute(prop, value);\r\n                }\r\n            });\r\n\r\n            helpers.each(initial.style || {}, function(value, key) {\r\n                canvas.style[key] = value;\r\n            });\r\n\r\n            // The canvas render size might have been changed (and thus the state stack discarded),\r\n            // we can't use save() and restore() to restore the initial state. So make sure that at\r\n            // least the canvas context is reset to the default state by setting the canvas width.\r\n            // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\r\n            canvas.width = canvas.width;\r\n\r\n            delete canvas._chartjs;\r\n        }\r\n\r\n        /**\r\n         * TODO(SB) Move this method in the upcoming core.platform class.\r\n         */\r\n        function acquireContext(item, config) {\r\n            if (typeof item === 'string') {\r\n                item = document.getElementById(item);\r\n            } else if (item.length) {\r\n                // Support for array based queries (such as jQuery)\r\n                item = item[0];\r\n            }\r\n\r\n            if (item && item.canvas) {\r\n                // Support for any object associated to a canvas (including a context2d)\r\n                item = item.canvas;\r\n            }\r\n\r\n            if (item instanceof HTMLCanvasElement) {\r\n                // To prevent canvas fingerprinting, some add-ons undefine the getContext\r\n                // method, for example: https://github.com/kkapsner/CanvasBlocker\r\n                // https://github.com/chartjs/Chart.js/issues/2807\r\n                var context = item.getContext && item.getContext('2d');\r\n                if (context instanceof CanvasRenderingContext2D) {\r\n                    initCanvas(item, config);\r\n                    return context;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Initializes the given config with global and chart default values.\r\n         */\r\n        function initConfig(config) {\r\n            config = config || {};\r\n\r\n            // Do NOT use configMerge() for the data object because this method merges arrays\r\n            // and so would change references to labels and datasets, preventing data updates.\r\n            var data = config.data = config.data || {};\r\n            data.datasets = data.datasets || [];\r\n            data.labels = data.labels || [];\r\n\r\n            config.options = helpers.configMerge(\r\n                Chart.defaults.global,\r\n                Chart.defaults[config.type],\r\n                config.options || {});\r\n\r\n            return config;\r\n        }\r\n\r\n        /**\r\n         * @class Chart.Controller\r\n         * The main controller of a chart.\r\n         */\r\n        Chart.Controller = function(item, config, instance) {\r\n            var me = this;\r\n\r\n            config = initConfig(config);\r\n\r\n            var context = acquireContext(item, config);\r\n            var canvas = context && context.canvas;\r\n            var height = canvas && canvas.height;\r\n            var width = canvas && canvas.width;\r\n\r\n            instance.ctx = context;\r\n            instance.canvas = canvas;\r\n            instance.config = config;\r\n            instance.width = width;\r\n            instance.height = height;\r\n            instance.aspectRatio = height? width / height : null;\r\n\r\n            me.id = helpers.uid();\r\n            me.chart = instance;\r\n            me.config = config;\r\n            me.options = config.options;\r\n            me._bufferedRender = false;\r\n\r\n            // Add the chart instance to the global namespace\r\n            Chart.instances[me.id] = me;\r\n\r\n            Object.defineProperty(me, 'data', {\r\n                get: function() {\r\n                    return me.config.data;\r\n                }\r\n            });\r\n\r\n            if (!context || !canvas) {\r\n                // The given item is not a compatible context2d element, let's return before finalizing\r\n                // the chart initialization but after setting basic chart / controller properties that\r\n                // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\r\n                // https://github.com/chartjs/Chart.js/issues/2807\r\n                console.error(\"Failed to create chart: can't acquire context from the given item\");\r\n                return me;\r\n            }\r\n\r\n            helpers.retinaScale(instance);\r\n\r\n            // Responsiveness is currently based on the use of an iframe, however this method causes\r\n            // performance issues and could be troublesome when used with ad blockers. So make sure\r\n            // that the user is still able to create a chart without iframe when responsive is false.\r\n            // See https://github.com/chartjs/Chart.js/issues/2210\r\n            if (me.options.responsive) {\r\n                helpers.addResizeListener(canvas.parentNode, function() {\r\n                    me.resize();\r\n                });\r\n\r\n                // Initial resize before chart draws (must be silent to preserve initial animations).\r\n                me.resize(true);\r\n            }\r\n\r\n            me.initialize();\r\n\r\n            return me;\r\n        };\r\n\r\n        helpers.extend(Chart.Controller.prototype, /** @lends Chart.Controller */ {\r\n            initialize: function() {\r\n                var me = this;\r\n\r\n                // Before init plugin notification\r\n                Chart.plugins.notify('beforeInit', [me]);\r\n\r\n                me.bindEvents();\r\n\r\n                // Make sure controllers are built first so that each dataset is bound to an axis before the scales\r\n                // are built\r\n                me.ensureScalesHaveIDs();\r\n                me.buildOrUpdateControllers();\r\n                me.buildScales();\r\n                me.updateLayout();\r\n                me.resetElements();\r\n                me.initToolTip();\r\n                me.update();\r\n\r\n                // After init plugin notification\r\n                Chart.plugins.notify('afterInit', [me]);\r\n\r\n                return me;\r\n            },\r\n\r\n            clear: function() {\r\n                helpers.clear(this.chart);\r\n                return this;\r\n            },\r\n\r\n            stop: function() {\r\n                // Stops any current animation loop occurring\r\n                Chart.animationService.cancelAnimation(this);\r\n                return this;\r\n            },\r\n\r\n            resize: function(silent) {\r\n                var me = this;\r\n                var chart = me.chart;\r\n                var options = me.options;\r\n                var canvas = chart.canvas;\r\n                var aspectRatio = (options.maintainAspectRatio && chart.aspectRatio) || null;\r\n\r\n                // the canvas render width and height will be casted to integers so make sure that\r\n                // the canvas display style uses the same integer values to avoid blurring effect.\r\n                var newWidth = Math.floor(helpers.getMaximumWidth(canvas));\r\n                var newHeight = Math.floor(aspectRatio? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));\r\n\r\n                if (chart.width === newWidth && chart.height === newHeight) {\r\n                    return;\r\n                }\r\n\r\n                canvas.width = chart.width = newWidth;\r\n                canvas.height = chart.height = newHeight;\r\n                canvas.style.width = newWidth + 'px';\r\n                canvas.style.height = newHeight + 'px';\r\n\r\n                helpers.retinaScale(chart);\r\n\r\n                // Notify any plugins about the resize\r\n                var newSize = {width: newWidth, height: newHeight};\r\n                Chart.plugins.notify('resize', [me, newSize]);\r\n\r\n                // Notify of resize\r\n                if (me.options.onResize) {\r\n                    me.options.onResize(me, newSize);\r\n                }\r\n\r\n                if (!silent) {\r\n                    me.stop();\r\n                    me.update(me.options.responsiveAnimationDuration);\r\n                }\r\n            },\r\n\r\n            ensureScalesHaveIDs: function() {\r\n                var options = this.options;\r\n                var scalesOptions = options.scales || {};\r\n                var scaleOptions = options.scale;\r\n\r\n                helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {\r\n                    xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\r\n                });\r\n\r\n                helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {\r\n                    yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\r\n                });\r\n\r\n                if (scaleOptions) {\r\n                    scaleOptions.id = scaleOptions.id || 'scale';\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Builds a map of scale ID to scale object for future lookup.\r\n             */\r\n            buildScales: function() {\r\n                var me = this;\r\n                var options = me.options;\r\n                var scales = me.scales = {};\r\n                var items = [];\r\n\r\n                if (options.scales) {\r\n                    items = items.concat(\r\n                        (options.scales.xAxes || []).map(function(xAxisOptions) {\r\n                            return {options: xAxisOptions, dtype: 'category'};\r\n                        }),\r\n                        (options.scales.yAxes || []).map(function(yAxisOptions) {\r\n                            return {options: yAxisOptions, dtype: 'linear'};\r\n                        })\r\n                    );\r\n                }\r\n\r\n                if (options.scale) {\r\n                    items.push({options: options.scale, dtype: 'radialLinear', isDefault: true});\r\n                }\r\n\r\n                helpers.each(items, function(item) {\r\n                    var scaleOptions = item.options;\r\n                    var scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);\r\n                    var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\r\n                    if (!scaleClass) {\r\n                        return;\r\n                    }\r\n\r\n                    var scale = new scaleClass({\r\n                        id: scaleOptions.id,\r\n                        options: scaleOptions,\r\n                        ctx: me.chart.ctx,\r\n                        chart: me\r\n                    });\r\n\r\n                    scales[scale.id] = scale;\r\n\r\n                    // TODO(SB): I think we should be able to remove this custom case (options.scale)\r\n                    // and consider it as a regular scale part of the \"scales\"\" map only! This would\r\n                    // make the logic easier and remove some useless? custom code.\r\n                    if (item.isDefault) {\r\n                        me.scale = scale;\r\n                    }\r\n                });\r\n\r\n                Chart.scaleService.addScalesToLayout(this);\r\n            },\r\n\r\n            updateLayout: function() {\r\n                Chart.layoutService.update(this, this.chart.width, this.chart.height);\r\n            },\r\n\r\n            buildOrUpdateControllers: function() {\r\n                var me = this;\r\n                var types = [];\r\n                var newControllers = [];\r\n\r\n                helpers.each(me.data.datasets, function(dataset, datasetIndex) {\r\n                    var meta = me.getDatasetMeta(datasetIndex);\r\n                    if (!meta.type) {\r\n                        meta.type = dataset.type || me.config.type;\r\n                    }\r\n\r\n                    types.push(meta.type);\r\n\r\n                    if (meta.controller) {\r\n                        meta.controller.updateIndex(datasetIndex);\r\n                    } else {\r\n                        meta.controller = new Chart.controllers[meta.type](me, datasetIndex);\r\n                        newControllers.push(meta.controller);\r\n                    }\r\n                }, me);\r\n\r\n                if (types.length > 1) {\r\n                    for (var i = 1; i < types.length; i++) {\r\n                        if (types[i] !== types[i - 1]) {\r\n                            me.isCombo = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return newControllers;\r\n            },\r\n\r\n            /**\r\n             * Reset the elements of all datasets\r\n             * @method resetElements\r\n             * @private\r\n             */\r\n            resetElements: function() {\r\n                var me = this;\r\n                helpers.each(me.data.datasets, function(dataset, datasetIndex) {\r\n                    me.getDatasetMeta(datasetIndex).controller.reset();\r\n                }, me);\r\n            },\r\n\r\n            /**\r\n             * Resets the chart back to it's state before the initial animation\r\n             * @method reset\r\n             */\r\n            reset: function() {\r\n                this.resetElements();\r\n                this.tooltip.initialize();\r\n            },\r\n\r\n            update: function(animationDuration, lazy) {\r\n                var me = this;\r\n                Chart.plugins.notify('beforeUpdate', [me]);\r\n\r\n                // In case the entire data object changed\r\n                me.tooltip._data = me.data;\r\n\r\n                // Make sure dataset controllers are updated and new controllers are reset\r\n                var newControllers = me.buildOrUpdateControllers();\r\n\r\n                // Make sure all dataset controllers have correct meta data counts\r\n                helpers.each(me.data.datasets, function(dataset, datasetIndex) {\r\n                    me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\r\n                }, me);\r\n\r\n                Chart.layoutService.update(me, me.chart.width, me.chart.height);\r\n\r\n                // Apply changes to the datasets that require the scales to have been calculated i.e BorderColor changes\r\n                Chart.plugins.notify('afterScaleUpdate', [me]);\r\n\r\n                // Can only reset the new controllers after the scales have been updated\r\n                helpers.each(newControllers, function(controller) {\r\n                    controller.reset();\r\n                });\r\n\r\n                me.updateDatasets();\r\n\r\n                // Do this before render so that any plugins that need final scale updates can use it\r\n                Chart.plugins.notify('afterUpdate', [me]);\r\n\r\n                if (me._bufferedRender) {\r\n                    me._bufferedRequest = {\r\n                        lazy: lazy,\r\n                        duration: animationDuration\r\n                    };\r\n                } else {\r\n                    me.render(animationDuration, lazy);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * @method beforeDatasetsUpdate\r\n             * @description Called before all datasets are updated. If a plugin returns false,\r\n             * the datasets update will be cancelled until another chart update is triggered.\r\n             * @param {Object} instance the chart instance being updated.\r\n             * @returns {Boolean} false to cancel the datasets update.\r\n             * @memberof Chart.PluginBase\r\n             * @since version 2.1.5\r\n             * @instance\r\n             */\r\n\r\n            /**\r\n             * @method afterDatasetsUpdate\r\n             * @description Called after all datasets have been updated. Note that this\r\n             * extension will not be called if the datasets update has been cancelled.\r\n             * @param {Object} instance the chart instance being updated.\r\n             * @memberof Chart.PluginBase\r\n             * @since version 2.1.5\r\n             * @instance\r\n             */\r\n\r\n            /**\r\n             * Updates all datasets unless a plugin returns false to the beforeDatasetsUpdate\r\n             * extension, in which case no datasets will be updated and the afterDatasetsUpdate\r\n             * notification will be skipped.\r\n             * @protected\r\n             * @instance\r\n             */\r\n            updateDatasets: function() {\r\n                var me = this;\r\n                var i, ilen;\r\n\r\n                if (Chart.plugins.notify('beforeDatasetsUpdate', [me])) {\r\n                    for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\r\n                        me.getDatasetMeta(i).controller.update();\r\n                    }\r\n\r\n                    Chart.plugins.notify('afterDatasetsUpdate', [me]);\r\n                }\r\n            },\r\n\r\n            render: function(duration, lazy) {\r\n                var me = this;\r\n                Chart.plugins.notify('beforeRender', [me]);\r\n\r\n                var animationOptions = me.options.animation;\r\n                if (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\r\n                    var animation = new Chart.Animation();\r\n                    animation.numSteps = (duration || animationOptions.duration) / 16.66; // 60 fps\r\n                    animation.easing = animationOptions.easing;\r\n\r\n                    // render function\r\n                    animation.render = function(chartInstance, animationObject) {\r\n                        var easingFunction = helpers.easingEffects[animationObject.easing];\r\n                        var stepDecimal = animationObject.currentStep / animationObject.numSteps;\r\n                        var easeDecimal = easingFunction(stepDecimal);\r\n\r\n                        chartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);\r\n                    };\r\n\r\n                    // user events\r\n                    animation.onAnimationProgress = animationOptions.onProgress;\r\n                    animation.onAnimationComplete = animationOptions.onComplete;\r\n\r\n                    Chart.animationService.addAnimation(me, animation, duration, lazy);\r\n                } else {\r\n                    me.draw();\r\n                    if (animationOptions && animationOptions.onComplete && animationOptions.onComplete.call) {\r\n                        animationOptions.onComplete.call(me);\r\n                    }\r\n                }\r\n                return me;\r\n            },\r\n\r\n            draw: function(ease) {\r\n                var me = this;\r\n                var easingDecimal = ease || 1;\r\n                me.clear();\r\n\r\n                Chart.plugins.notify('beforeDraw', [me, easingDecimal]);\r\n\r\n                // Draw all the scales\r\n                helpers.each(me.boxes, function(box) {\r\n                    box.draw(me.chartArea);\r\n                }, me);\r\n                if (me.scale) {\r\n                    me.scale.draw();\r\n                }\r\n\r\n                Chart.plugins.notify('beforeDatasetsDraw', [me, easingDecimal]);\r\n\r\n                // Draw each dataset via its respective controller (reversed to support proper line stacking)\r\n                helpers.each(me.data.datasets, function(dataset, datasetIndex) {\r\n                    if (me.isDatasetVisible(datasetIndex)) {\r\n                        me.getDatasetMeta(datasetIndex).controller.draw(ease);\r\n                    }\r\n                }, me, true);\r\n\r\n                Chart.plugins.notify('afterDatasetsDraw', [me, easingDecimal]);\r\n\r\n                // Finally draw the tooltip\r\n                me.tooltip.transition(easingDecimal).draw();\r\n\r\n                Chart.plugins.notify('afterDraw', [me, easingDecimal]);\r\n            },\r\n\r\n            // Get the single element that was clicked on\r\n            // @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\r\n            getElementAtEvent: function(e) {\r\n                return Chart.Interaction.modes.single(this, e);\r\n            },\r\n\r\n            getElementsAtEvent: function(e) {\r\n                return Chart.Interaction.modes.label(this, e, {intersect: true});\r\n            },\r\n\r\n            getElementsAtXAxis: function(e) {\r\n                return Chart.Interaction.modes['x-axis'](this, e, {intersect: true});\r\n            },\r\n\r\n            getElementsAtEventForMode: function(e, mode, options) {\r\n                var method = Chart.Interaction.modes[mode];\r\n                if (typeof method === 'function') {\r\n                    return method(this, e, options);\r\n                }\r\n\r\n                return [];\r\n            },\r\n\r\n            getDatasetAtEvent: function(e) {\r\n                return Chart.Interaction.modes.dataset(this, e);\r\n            },\r\n\r\n            getDatasetMeta: function(datasetIndex) {\r\n                var me = this;\r\n                var dataset = me.data.datasets[datasetIndex];\r\n                if (!dataset._meta) {\r\n                    dataset._meta = {};\r\n                }\r\n\r\n                var meta = dataset._meta[me.id];\r\n                if (!meta) {\r\n                    meta = dataset._meta[me.id] = {\r\n                        type: null,\r\n                        data: [],\r\n                        dataset: null,\r\n                        controller: null,\r\n                        hidden: null,\t\t\t// See isDatasetVisible() comment\r\n                        xAxisID: null,\r\n                        yAxisID: null\r\n                    };\r\n                }\r\n\r\n                return meta;\r\n            },\r\n\r\n            getVisibleDatasetCount: function() {\r\n                var count = 0;\r\n                for (var i = 0, ilen = this.data.datasets.length; i<ilen; ++i) {\r\n                    if (this.isDatasetVisible(i)) {\r\n                        count++;\r\n                    }\r\n                }\r\n                return count;\r\n            },\r\n\r\n            isDatasetVisible: function(datasetIndex) {\r\n                var meta = this.getDatasetMeta(datasetIndex);\r\n\r\n                // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\r\n                // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\r\n                return typeof meta.hidden === 'boolean'? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\r\n            },\r\n\r\n            generateLegend: function() {\r\n                return this.options.legendCallback(this);\r\n            },\r\n\r\n            destroy: function() {\r\n                var me = this;\r\n                var canvas = me.chart.canvas;\r\n                var meta, i, ilen;\r\n\r\n                me.stop();\r\n\r\n                // dataset controllers need to cleanup associated data\r\n                for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\r\n                    meta = me.getDatasetMeta(i);\r\n                    if (meta.controller) {\r\n                        meta.controller.destroy();\r\n                        meta.controller = null;\r\n                    }\r\n                }\r\n\r\n                if (canvas) {\r\n                    helpers.unbindEvents(me, me.events);\r\n                    helpers.removeResizeListener(canvas.parentNode);\r\n                    helpers.clear(me.chart);\r\n                    releaseCanvas(canvas);\r\n                    me.chart.canvas = null;\r\n                    me.chart.ctx = null;\r\n                }\r\n\r\n                Chart.plugins.notify('destroy', [me]);\r\n\r\n                delete Chart.instances[me.id];\r\n            },\r\n\r\n            toBase64Image: function() {\r\n                return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);\r\n            },\r\n\r\n            initToolTip: function() {\r\n                var me = this;\r\n                me.tooltip = new Chart.Tooltip({\r\n                    _chart: me.chart,\r\n                    _chartInstance: me,\r\n                    _data: me.data,\r\n                    _options: me.options.tooltips\r\n                }, me);\r\n                me.tooltip.initialize();\r\n            },\r\n\r\n            bindEvents: function() {\r\n                var me = this;\r\n                helpers.bindEvents(me, me.options.events, function(evt) {\r\n                    me.eventHandler(evt);\r\n                });\r\n            },\r\n\r\n            updateHoverStyle: function(elements, mode, enabled) {\r\n                var method = enabled? 'setHoverStyle' : 'removeHoverStyle';\r\n                var element, i, ilen;\r\n\r\n                for (i=0, ilen=elements.length; i<ilen; ++i) {\r\n                    element = elements[i];\r\n                    if (element) {\r\n                        this.getDatasetMeta(element._datasetIndex).controller[method](element);\r\n                    }\r\n                }\r\n            },\r\n\r\n            eventHandler: function(e) {\r\n                var me = this;\r\n                var legend = me.legend;\r\n                var tooltip = me.tooltip;\r\n                var hoverOptions = me.options.hover;\r\n\r\n                // Buffer any update calls so that renders do not occur\r\n                me._bufferedRender = true;\r\n                me._bufferedRequest = null;\r\n\r\n                var changed = me.handleEvent(e);\r\n                changed |= legend && legend.handleEvent(e);\r\n                changed |= tooltip && tooltip.handleEvent(e);\r\n\r\n                var bufferedRequest = me._bufferedRequest;\r\n                if (bufferedRequest) {\r\n                    // If we have an update that was triggered, we need to do a normal render\r\n                    me.render(bufferedRequest.duration, bufferedRequest.lazy);\r\n                } else if (changed && !me.animating) {\r\n                    // If entering, leaving, or changing elements, animate the change via pivot\r\n                    me.stop();\r\n\r\n                    // We only need to render at this point. Updating will cause scales to be\r\n                    // recomputed generating flicker & using more memory than necessary.\r\n                    me.render(hoverOptions.animationDuration, true);\r\n                }\r\n\r\n                me._bufferedRender = false;\r\n                me._bufferedRequest = null;\r\n\r\n                return me;\r\n            },\r\n\r\n            /**\r\n             * Handle an event\r\n             * @private\r\n             * param e {Event} the event to handle\r\n             * @return {Boolean} true if the chart needs to re-render\r\n             */\r\n            handleEvent: function(e) {\r\n                var me = this;\r\n                var options = me.options || {};\r\n                var hoverOptions = options.hover;\r\n                var changed = false;\r\n\r\n                me.lastActive = me.lastActive || [];\r\n\r\n                // Find Active Elements for hover and tooltips\r\n                if (e.type === 'mouseout') {\r\n                    me.active = [];\r\n                } else {\r\n                    me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\r\n                }\r\n\r\n                // On Hover hook\r\n                if (hoverOptions.onHover) {\r\n                    hoverOptions.onHover.call(me, me.active);\r\n                }\r\n\r\n                if (e.type === 'mouseup' || e.type === 'click') {\r\n                    if (options.onClick) {\r\n                        options.onClick.call(me, e, me.active);\r\n                    }\r\n                }\r\n\r\n                // Remove styling for last active (even if it may still be active)\r\n                if (me.lastActive.length) {\r\n                    me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\r\n                }\r\n\r\n                // Built in hover styling\r\n                if (me.active.length && hoverOptions.mode) {\r\n                    me.updateHoverStyle(me.active, hoverOptions.mode, true);\r\n                }\r\n\r\n                changed = !helpers.arrayEquals(me.active, me.lastActive);\r\n\r\n                // Remember Last Actives\r\n                me.lastActive = me.active;\r\n\r\n                return changed;\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],24:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\r\n\r\n        /**\r\n         * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\r\n         * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\r\n         * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\r\n         */\r\n        function listenArrayEvents(array, listener) {\r\n            if (array._chartjs) {\r\n                array._chartjs.listeners.push(listener);\r\n                return;\r\n            }\r\n\r\n            Object.defineProperty(array, '_chartjs', {\r\n                configurable: true,\r\n                enumerable: false,\r\n                value: {\r\n                    listeners: [listener]\r\n                }\r\n            });\r\n\r\n            arrayEvents.forEach(function(key) {\r\n                var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\r\n                var base = array[key];\r\n\r\n                Object.defineProperty(array, key, {\r\n                    configurable: true,\r\n                    enumerable: false,\r\n                    value: function() {\r\n                        var args = Array.prototype.slice.call(arguments);\r\n                        var res = base.apply(this, args);\r\n\r\n                        helpers.each(array._chartjs.listeners, function(object) {\r\n                            if (typeof object[method] === 'function') {\r\n                                object[method].apply(object, args);\r\n                            }\r\n                        });\r\n\r\n                        return res;\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Removes the given array event listener and cleanup extra attached properties (such as\r\n         * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\r\n         */\r\n        function unlistenArrayEvents(array, listener) {\r\n            var stub = array._chartjs;\r\n            if (!stub) {\r\n                return;\r\n            }\r\n\r\n            var listeners = stub.listeners;\r\n            var index = listeners.indexOf(listener);\r\n            if (index !== -1) {\r\n                listeners.splice(index, 1);\r\n            }\r\n\r\n            if (listeners.length > 0) {\r\n                return;\r\n            }\r\n\r\n            arrayEvents.forEach(function(key) {\r\n                delete array[key];\r\n            });\r\n\r\n            delete array._chartjs;\r\n        }\r\n\r\n        // Base class for all dataset controllers (line, bar, etc)\r\n        Chart.DatasetController = function(chart, datasetIndex) {\r\n            this.initialize(chart, datasetIndex);\r\n        };\r\n\r\n        helpers.extend(Chart.DatasetController.prototype, {\r\n\r\n            /**\r\n             * Element type used to generate a meta dataset (e.g. Chart.element.Line).\r\n             * @type {Chart.core.element}\r\n             */\r\n            datasetElementType: null,\r\n\r\n            /**\r\n             * Element type used to generate a meta data (e.g. Chart.element.Point).\r\n             * @type {Chart.core.element}\r\n             */\r\n            dataElementType: null,\r\n\r\n            initialize: function(chart, datasetIndex) {\r\n                var me = this;\r\n                me.chart = chart;\r\n                me.index = datasetIndex;\r\n                me.linkScales();\r\n                me.addElements();\r\n            },\r\n\r\n            updateIndex: function(datasetIndex) {\r\n                this.index = datasetIndex;\r\n            },\r\n\r\n            linkScales: function() {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var dataset = me.getDataset();\r\n\r\n                if (meta.xAxisID === null) {\r\n                    meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\r\n                }\r\n                if (meta.yAxisID === null) {\r\n                    meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\r\n                }\r\n            },\r\n\r\n            getDataset: function() {\r\n                return this.chart.data.datasets[this.index];\r\n            },\r\n\r\n            getMeta: function() {\r\n                return this.chart.getDatasetMeta(this.index);\r\n            },\r\n\r\n            getScaleForId: function(scaleID) {\r\n                return this.chart.scales[scaleID];\r\n            },\r\n\r\n            reset: function() {\r\n                this.update(true);\r\n            },\r\n\r\n            /**\r\n             * @private\r\n             */\r\n            destroy: function() {\r\n                if (this._data) {\r\n                    unlistenArrayEvents(this._data, this);\r\n                }\r\n            },\r\n\r\n            createMetaDataset: function() {\r\n                var me = this;\r\n                var type = me.datasetElementType;\r\n                return type && new type({\r\n                        _chart: me.chart.chart,\r\n                        _datasetIndex: me.index\r\n                    });\r\n            },\r\n\r\n            createMetaData: function(index) {\r\n                var me = this;\r\n                var type = me.dataElementType;\r\n                return type && new type({\r\n                        _chart: me.chart.chart,\r\n                        _datasetIndex: me.index,\r\n                        _index: index\r\n                    });\r\n            },\r\n\r\n            addElements: function() {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var data = me.getDataset().data || [];\r\n                var metaData = meta.data;\r\n                var i, ilen;\r\n\r\n                for (i=0, ilen=data.length; i<ilen; ++i) {\r\n                    metaData[i] = metaData[i] || me.createMetaData(i);\r\n                }\r\n\r\n                meta.dataset = meta.dataset || me.createMetaDataset();\r\n            },\r\n\r\n            addElementAndReset: function(index) {\r\n                var element = this.createMetaData(index);\r\n                this.getMeta().data.splice(index, 0, element);\r\n                this.updateElement(element, index, true);\r\n            },\r\n\r\n            buildOrUpdateElements: function() {\r\n                var me = this;\r\n                var dataset = me.getDataset();\r\n                var data = dataset.data || (dataset.data = []);\r\n\r\n                // In order to correctly handle data addition/deletion animation (an thus simulate\r\n                // real-time charts), we need to monitor these data modifications and synchronize\r\n                // the internal meta data accordingly.\r\n                if (me._data !== data) {\r\n                    if (me._data) {\r\n                        // This case happens when the user replaced the data array instance.\r\n                        unlistenArrayEvents(me._data, me);\r\n                    }\r\n\r\n                    listenArrayEvents(data, me);\r\n                    me._data = data;\r\n                }\r\n\r\n                // Re-sync meta data in case the user replaced the data array or if we missed\r\n                // any updates and so make sure that we handle number of datapoints changing.\r\n                me.resyncElements();\r\n            },\r\n\r\n            update: helpers.noop,\r\n\r\n            draw: function(ease) {\r\n                var easingDecimal = ease || 1;\r\n                var i, len;\r\n                var metaData = this.getMeta().data;\r\n                for (i = 0, len = metaData.length; i < len; ++i) {\r\n                    metaData[i].transition(easingDecimal).draw();\r\n                }\r\n            },\r\n\r\n            removeHoverStyle: function(element, elementOpts) {\r\n                var dataset = this.chart.data.datasets[element._datasetIndex],\r\n                    index = element._index,\r\n                    custom = element.custom || {},\r\n                    valueOrDefault = helpers.getValueAtIndexOrDefault,\r\n                    model = element._model;\r\n\r\n                model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\r\n                model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\r\n                model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\r\n            },\r\n\r\n            setHoverStyle: function(element) {\r\n                var dataset = this.chart.data.datasets[element._datasetIndex],\r\n                    index = element._index,\r\n                    custom = element.custom || {},\r\n                    valueOrDefault = helpers.getValueAtIndexOrDefault,\r\n                    getHoverColor = helpers.getHoverColor,\r\n                    model = element._model;\r\n\r\n                model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\r\n                model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\r\n                model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\r\n            },\r\n\r\n            /**\r\n             * @private\r\n             */\r\n            resyncElements: function() {\r\n                var me = this;\r\n                var meta = me.getMeta();\r\n                var data = me.getDataset().data;\r\n                var numMeta = meta.data.length;\r\n                var numData = data.length;\r\n\r\n                if (numData < numMeta) {\r\n                    meta.data.splice(numData, numMeta - numData);\r\n                } else if (numData > numMeta) {\r\n                    me.insertElements(numMeta, numData - numMeta);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * @private\r\n             */\r\n            insertElements: function(start, count) {\r\n                for (var i=0; i<count; ++i) {\r\n                    this.addElementAndReset(start + i);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * @private\r\n             */\r\n            onDataPush: function() {\r\n                this.insertElements(this.getDataset().data.length-1, arguments.length);\r\n            },\r\n\r\n            /**\r\n             * @private\r\n             */\r\n            onDataPop: function() {\r\n                this.getMeta().data.pop();\r\n            },\r\n\r\n            /**\r\n             * @private\r\n             */\r\n            onDataShift: function() {\r\n                this.getMeta().data.shift();\r\n            },\r\n\r\n            /**\r\n             * @private\r\n             */\r\n            onDataSplice: function(start, count) {\r\n                this.getMeta().data.splice(start, count);\r\n                this.insertElements(start, arguments.length - 2);\r\n            },\r\n\r\n            /**\r\n             * @private\r\n             */\r\n            onDataUnshift: function() {\r\n                this.insertElements(0, arguments.length);\r\n            }\r\n        });\r\n\r\n        Chart.DatasetController.extend = helpers.inherits;\r\n    };\r\n\r\n},{}],25:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        Chart.elements = {};\r\n\r\n        Chart.Element = function(configuration) {\r\n            helpers.extend(this, configuration);\r\n            this.initialize.apply(this, arguments);\r\n        };\r\n\r\n        helpers.extend(Chart.Element.prototype, {\r\n\r\n            initialize: function() {\r\n                this.hidden = false;\r\n            },\r\n\r\n            pivot: function() {\r\n                var me = this;\r\n                if (!me._view) {\r\n                    me._view = helpers.clone(me._model);\r\n                }\r\n                me._start = helpers.clone(me._view);\r\n                return me;\r\n            },\r\n\r\n            transition: function(ease) {\r\n                var me = this;\r\n\r\n                if (!me._view) {\r\n                    me._view = helpers.clone(me._model);\r\n                }\r\n\r\n                // No animation -> No Transition\r\n                if (ease === 1) {\r\n                    me._view = me._model;\r\n                    me._start = null;\r\n                    return me;\r\n                }\r\n\r\n                if (!me._start) {\r\n                    me.pivot();\r\n                }\r\n\r\n                helpers.each(me._model, function(value, key) {\r\n\r\n                    if (key[0] === '_') {\r\n                        // Only non-underscored properties\r\n                        // Init if doesn't exist\r\n                    } else if (!me._view.hasOwnProperty(key)) {\r\n                        if (typeof value === 'number' && !isNaN(me._view[key])) {\r\n                            me._view[key] = value * ease;\r\n                        } else {\r\n                            me._view[key] = value;\r\n                        }\r\n                        // No unnecessary computations\r\n                    } else if (value === me._view[key]) {\r\n                        // It's the same! Woohoo!\r\n                        // Color transitions if possible\r\n                    } else if (typeof value === 'string') {\r\n                        try {\r\n                            var color = helpers.color(me._model[key]).mix(helpers.color(me._start[key]), ease);\r\n                            me._view[key] = color.rgbString();\r\n                        } catch (err) {\r\n                            me._view[key] = value;\r\n                        }\r\n                        // Number transitions\r\n                    } else if (typeof value === 'number') {\r\n                        var startVal = me._start[key] !== undefined && isNaN(me._start[key]) === false ? me._start[key] : 0;\r\n                        me._view[key] = ((me._model[key] - startVal) * ease) + startVal;\r\n                        // Everything else\r\n                    } else {\r\n                        me._view[key] = value;\r\n                    }\r\n                }, me);\r\n\r\n                return me;\r\n            },\r\n\r\n            tooltipPosition: function() {\r\n                return {\r\n                    x: this._model.x,\r\n                    y: this._model.y\r\n                };\r\n            },\r\n\r\n            hasValue: function() {\r\n                return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\r\n            }\r\n        });\r\n\r\n        Chart.Element.extend = helpers.inherits;\r\n\r\n    };\r\n\r\n},{}],26:[function(require,module,exports){\r\n    /* global window: false */\r\n    /* global document: false */\r\n    'use strict';\r\n\r\n    var color = require(3);\r\n\r\n    module.exports = function(Chart) {\r\n        // Global Chart helpers object for utility methods and classes\r\n        var helpers = Chart.helpers = {};\r\n\r\n        // -- Basic js utility methods\r\n        helpers.each = function(loopable, callback, self, reverse) {\r\n            // Check to see if null or undefined firstly.\r\n            var i, len;\r\n            if (helpers.isArray(loopable)) {\r\n                len = loopable.length;\r\n                if (reverse) {\r\n                    for (i = len - 1; i >= 0; i--) {\r\n                        callback.call(self, loopable[i], i);\r\n                    }\r\n                } else {\r\n                    for (i = 0; i < len; i++) {\r\n                        callback.call(self, loopable[i], i);\r\n                    }\r\n                }\r\n            } else if (typeof loopable === 'object') {\r\n                var keys = Object.keys(loopable);\r\n                len = keys.length;\r\n                for (i = 0; i < len; i++) {\r\n                    callback.call(self, loopable[keys[i]], keys[i]);\r\n                }\r\n            }\r\n        };\r\n        helpers.clone = function(obj) {\r\n            var objClone = {};\r\n            helpers.each(obj, function(value, key) {\r\n                if (helpers.isArray(value)) {\r\n                    objClone[key] = value.slice(0);\r\n                } else if (typeof value === 'object' && value !== null) {\r\n                    objClone[key] = helpers.clone(value);\r\n                } else {\r\n                    objClone[key] = value;\r\n                }\r\n            });\r\n            return objClone;\r\n        };\r\n        helpers.extend = function(base) {\r\n            var setFn = function(value, key) {\r\n                base[key] = value;\r\n            };\r\n            for (var i = 1, ilen = arguments.length; i < ilen; i++) {\r\n                helpers.each(arguments[i], setFn);\r\n            }\r\n            return base;\r\n        };\r\n        // Need a special merge function to chart configs since they are now grouped\r\n        helpers.configMerge = function(_base) {\r\n            var base = helpers.clone(_base);\r\n            helpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {\r\n                helpers.each(extension, function(value, key) {\r\n                    var baseHasProperty = base.hasOwnProperty(key);\r\n                    var baseVal = baseHasProperty ? base[key] : {};\r\n\r\n                    if (key === 'scales') {\r\n                        // Scale config merging is complex. Add our own function here for that\r\n                        base[key] = helpers.scaleMerge(baseVal, value);\r\n                    } else if (key === 'scale') {\r\n                        // Used in polar area & radar charts since there is only one scale\r\n                        base[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value);\r\n                    } else if (baseHasProperty\r\n                        && typeof baseVal === 'object'\r\n                        && !helpers.isArray(baseVal)\r\n                        && baseVal !== null\r\n                        && typeof value === 'object'\r\n                        && !helpers.isArray(value)) {\r\n                        // If we are overwriting an object with an object, do a merge of the properties.\r\n                        base[key] = helpers.configMerge(baseVal, value);\r\n                    } else {\r\n                        // can just overwrite the value in this case\r\n                        base[key] = value;\r\n                    }\r\n                });\r\n            });\r\n\r\n            return base;\r\n        };\r\n        helpers.scaleMerge = function(_base, extension) {\r\n            var base = helpers.clone(_base);\r\n\r\n            helpers.each(extension, function(value, key) {\r\n                if (key === 'xAxes' || key === 'yAxes') {\r\n                    // These properties are arrays of items\r\n                    if (base.hasOwnProperty(key)) {\r\n                        helpers.each(value, function(valueObj, index) {\r\n                            var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\r\n                            var axisDefaults = Chart.scaleService.getScaleDefaults(axisType);\r\n                            if (index >= base[key].length || !base[key][index].type) {\r\n                                base[key].push(helpers.configMerge(axisDefaults, valueObj));\r\n                            } else if (valueObj.type && valueObj.type !== base[key][index].type) {\r\n                                // Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults\r\n                                base[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);\r\n                            } else {\r\n                                // Type is the same\r\n                                base[key][index] = helpers.configMerge(base[key][index], valueObj);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        base[key] = [];\r\n                        helpers.each(value, function(valueObj) {\r\n                            var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\r\n                            base[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));\r\n                        });\r\n                    }\r\n                } else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {\r\n                    // If we are overwriting an object with an object, do a merge of the properties.\r\n                    base[key] = helpers.configMerge(base[key], value);\r\n\r\n                } else {\r\n                    // can just overwrite the value in this case\r\n                    base[key] = value;\r\n                }\r\n            });\r\n\r\n            return base;\r\n        };\r\n        helpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {\r\n            if (value === undefined || value === null) {\r\n                return defaultValue;\r\n            }\r\n\r\n            if (helpers.isArray(value)) {\r\n                return index < value.length ? value[index] : defaultValue;\r\n            }\r\n\r\n            return value;\r\n        };\r\n        helpers.getValueOrDefault = function(value, defaultValue) {\r\n            return value === undefined ? defaultValue : value;\r\n        };\r\n        helpers.indexOf = Array.prototype.indexOf?\r\n            function(array, item) {\r\n                return array.indexOf(item);\r\n            }:\r\n            function(array, item) {\r\n                for (var i = 0, ilen = array.length; i < ilen; ++i) {\r\n                    if (array[i] === item) {\r\n                        return i;\r\n                    }\r\n                }\r\n                return -1;\r\n            };\r\n        helpers.where = function(collection, filterCallback) {\r\n            if (helpers.isArray(collection) && Array.prototype.filter) {\r\n                return collection.filter(filterCallback);\r\n            }\r\n            var filtered = [];\r\n\r\n            helpers.each(collection, function(item) {\r\n                if (filterCallback(item)) {\r\n                    filtered.push(item);\r\n                }\r\n            });\r\n\r\n            return filtered;\r\n        };\r\n        helpers.findIndex = Array.prototype.findIndex?\r\n            function(array, callback, scope) {\r\n                return array.findIndex(callback, scope);\r\n            } :\r\n            function(array, callback, scope) {\r\n                scope = scope === undefined? array : scope;\r\n                for (var i = 0, ilen = array.length; i < ilen; ++i) {\r\n                    if (callback.call(scope, array[i], i, array)) {\r\n                        return i;\r\n                    }\r\n                }\r\n                return -1;\r\n            };\r\n        helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\r\n            // Default to start of the array\r\n            if (startIndex === undefined || startIndex === null) {\r\n                startIndex = -1;\r\n            }\r\n            for (var i = startIndex + 1; i < arrayToSearch.length; i++) {\r\n                var currentItem = arrayToSearch[i];\r\n                if (filterCallback(currentItem)) {\r\n                    return currentItem;\r\n                }\r\n            }\r\n        };\r\n        helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\r\n            // Default to end of the array\r\n            if (startIndex === undefined || startIndex === null) {\r\n                startIndex = arrayToSearch.length;\r\n            }\r\n            for (var i = startIndex - 1; i >= 0; i--) {\r\n                var currentItem = arrayToSearch[i];\r\n                if (filterCallback(currentItem)) {\r\n                    return currentItem;\r\n                }\r\n            }\r\n        };\r\n        helpers.inherits = function(extensions) {\r\n            // Basic javascript inheritance based on the model created in Backbone.js\r\n            var me = this;\r\n            var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\r\n                return me.apply(this, arguments);\r\n            };\r\n\r\n            var Surrogate = function() {\r\n                this.constructor = ChartElement;\r\n            };\r\n            Surrogate.prototype = me.prototype;\r\n            ChartElement.prototype = new Surrogate();\r\n\r\n            ChartElement.extend = helpers.inherits;\r\n\r\n            if (extensions) {\r\n                helpers.extend(ChartElement.prototype, extensions);\r\n            }\r\n\r\n            ChartElement.__super__ = me.prototype;\r\n\r\n            return ChartElement;\r\n        };\r\n        helpers.noop = function() {};\r\n        helpers.uid = (function() {\r\n            var id = 0;\r\n            return function() {\r\n                return id++;\r\n            };\r\n        }());\r\n        // -- Math methods\r\n        helpers.isNumber = function(n) {\r\n            return !isNaN(parseFloat(n)) && isFinite(n);\r\n        };\r\n        helpers.almostEquals = function(x, y, epsilon) {\r\n            return Math.abs(x - y) < epsilon;\r\n        };\r\n        helpers.max = function(array) {\r\n            return array.reduce(function(max, value) {\r\n                if (!isNaN(value)) {\r\n                    return Math.max(max, value);\r\n                }\r\n                return max;\r\n            }, Number.NEGATIVE_INFINITY);\r\n        };\r\n        helpers.min = function(array) {\r\n            return array.reduce(function(min, value) {\r\n                if (!isNaN(value)) {\r\n                    return Math.min(min, value);\r\n                }\r\n                return min;\r\n            }, Number.POSITIVE_INFINITY);\r\n        };\r\n        helpers.sign = Math.sign?\r\n            function(x) {\r\n                return Math.sign(x);\r\n            } :\r\n            function(x) {\r\n                x = +x; // convert to a number\r\n                if (x === 0 || isNaN(x)) {\r\n                    return x;\r\n                }\r\n                return x > 0 ? 1 : -1;\r\n            };\r\n        helpers.log10 = Math.log10?\r\n            function(x) {\r\n                return Math.log10(x);\r\n            } :\r\n            function(x) {\r\n                return Math.log(x) / Math.LN10;\r\n            };\r\n        helpers.toRadians = function(degrees) {\r\n            return degrees * (Math.PI / 180);\r\n        };\r\n        helpers.toDegrees = function(radians) {\r\n            return radians * (180 / Math.PI);\r\n        };\r\n        // Gets the angle from vertical upright to the point about a centre.\r\n        helpers.getAngleFromPoint = function(centrePoint, anglePoint) {\r\n            var distanceFromXCenter = anglePoint.x - centrePoint.x,\r\n                distanceFromYCenter = anglePoint.y - centrePoint.y,\r\n                radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\r\n\r\n            var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\r\n\r\n            if (angle < (-0.5 * Math.PI)) {\r\n                angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\r\n            }\r\n\r\n            return {\r\n                angle: angle,\r\n                distance: radialDistanceFromCenter\r\n            };\r\n        };\r\n        helpers.distanceBetweenPoints = function(pt1, pt2) {\r\n            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\r\n        };\r\n        helpers.aliasPixel = function(pixelWidth) {\r\n            return (pixelWidth % 2 === 0) ? 0 : 0.5;\r\n        };\r\n        helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\r\n            // Props to Rob Spencer at scaled innovation for his post on splining between points\r\n            // http://scaledinnovation.com/analytics/splines/aboutSplines.html\r\n\r\n            // This function must also respect \"skipped\" points\r\n\r\n            var previous = firstPoint.skip ? middlePoint : firstPoint,\r\n                current = middlePoint,\r\n                next = afterPoint.skip ? middlePoint : afterPoint;\r\n\r\n            var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\r\n            var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\r\n\r\n            var s01 = d01 / (d01 + d12);\r\n            var s12 = d12 / (d01 + d12);\r\n\r\n            // If all points are the same, s01 & s02 will be inf\r\n            s01 = isNaN(s01) ? 0 : s01;\r\n            s12 = isNaN(s12) ? 0 : s12;\r\n\r\n            var fa = t * s01; // scaling factor for triangle Ta\r\n            var fb = t * s12;\r\n\r\n            return {\r\n                previous: {\r\n                    x: current.x - fa * (next.x - previous.x),\r\n                    y: current.y - fa * (next.y - previous.y)\r\n                },\r\n                next: {\r\n                    x: current.x + fb * (next.x - previous.x),\r\n                    y: current.y + fb * (next.y - previous.y)\r\n                }\r\n            };\r\n        };\r\n        helpers.EPSILON = Number.EPSILON || 1e-14;\r\n        helpers.splineCurveMonotone = function(points) {\r\n            // This function calculates Bzier control points in a similar way than |splineCurve|,\r\n            // but preserves monotonicity of the provided data and ensures no local extremums are added\r\n            // between the dataset discrete points due to the interpolation.\r\n            // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\r\n\r\n            var pointsWithTangents = (points || []).map(function(point) {\r\n                return {\r\n                    model: point._model,\r\n                    deltaK: 0,\r\n                    mK: 0\r\n                };\r\n            });\r\n\r\n            // Calculate slopes (deltaK) and initialize tangents (mK)\r\n            var pointsLen = pointsWithTangents.length;\r\n            var i, pointBefore, pointCurrent, pointAfter;\r\n            for (i = 0; i < pointsLen; ++i) {\r\n                pointCurrent = pointsWithTangents[i];\r\n                if (pointCurrent.model.skip) {\r\n                    continue;\r\n                }\r\n\r\n                pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\r\n                pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\r\n                if (pointAfter && !pointAfter.model.skip) {\r\n                    pointCurrent.deltaK = (pointAfter.model.y - pointCurrent.model.y) / (pointAfter.model.x - pointCurrent.model.x);\r\n                }\r\n\r\n                if (!pointBefore || pointBefore.model.skip) {\r\n                    pointCurrent.mK = pointCurrent.deltaK;\r\n                } else if (!pointAfter || pointAfter.model.skip) {\r\n                    pointCurrent.mK = pointBefore.deltaK;\r\n                } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\r\n                    pointCurrent.mK = 0;\r\n                } else {\r\n                    pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\r\n                }\r\n            }\r\n\r\n            // Adjust tangents to ensure monotonic properties\r\n            var alphaK, betaK, tauK, squaredMagnitude;\r\n            for (i = 0; i < pointsLen - 1; ++i) {\r\n                pointCurrent = pointsWithTangents[i];\r\n                pointAfter = pointsWithTangents[i + 1];\r\n                if (pointCurrent.model.skip || pointAfter.model.skip) {\r\n                    continue;\r\n                }\r\n\r\n                if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\r\n                    pointCurrent.mK = pointAfter.mK = 0;\r\n                    continue;\r\n                }\r\n\r\n                alphaK = pointCurrent.mK / pointCurrent.deltaK;\r\n                betaK = pointAfter.mK / pointCurrent.deltaK;\r\n                squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\r\n                if (squaredMagnitude <= 9) {\r\n                    continue;\r\n                }\r\n\r\n                tauK = 3 / Math.sqrt(squaredMagnitude);\r\n                pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\r\n                pointAfter.mK = betaK * tauK * pointCurrent.deltaK;\r\n            }\r\n\r\n            // Compute control points\r\n            var deltaX;\r\n            for (i = 0; i < pointsLen; ++i) {\r\n                pointCurrent = pointsWithTangents[i];\r\n                if (pointCurrent.model.skip) {\r\n                    continue;\r\n                }\r\n\r\n                pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\r\n                pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\r\n                if (pointBefore && !pointBefore.model.skip) {\r\n                    deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\r\n                    pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\r\n                    pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\r\n                }\r\n                if (pointAfter && !pointAfter.model.skip) {\r\n                    deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\r\n                    pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\r\n                    pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\r\n                }\r\n            }\r\n        };\r\n        helpers.nextItem = function(collection, index, loop) {\r\n            if (loop) {\r\n                return index >= collection.length - 1 ? collection[0] : collection[index + 1];\r\n            }\r\n            return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\r\n        };\r\n        helpers.previousItem = function(collection, index, loop) {\r\n            if (loop) {\r\n                return index <= 0 ? collection[collection.length - 1] : collection[index - 1];\r\n            }\r\n            return index <= 0 ? collection[0] : collection[index - 1];\r\n        };\r\n        // Implementation of the nice number algorithm used in determining where axis labels will go\r\n        helpers.niceNum = function(range, round) {\r\n            var exponent = Math.floor(helpers.log10(range));\r\n            var fraction = range / Math.pow(10, exponent);\r\n            var niceFraction;\r\n\r\n            if (round) {\r\n                if (fraction < 1.5) {\r\n                    niceFraction = 1;\r\n                } else if (fraction < 3) {\r\n                    niceFraction = 2;\r\n                } else if (fraction < 7) {\r\n                    niceFraction = 5;\r\n                } else {\r\n                    niceFraction = 10;\r\n                }\r\n            } else if (fraction <= 1.0) {\r\n                niceFraction = 1;\r\n            } else if (fraction <= 2) {\r\n                niceFraction = 2;\r\n            } else if (fraction <= 5) {\r\n                niceFraction = 5;\r\n            } else {\r\n                niceFraction = 10;\r\n            }\r\n\r\n            return niceFraction * Math.pow(10, exponent);\r\n        };\r\n        // Easing functions adapted from Robert Penner's easing equations\r\n        // http://www.robertpenner.com/easing/\r\n        var easingEffects = helpers.easingEffects = {\r\n            linear: function(t) {\r\n                return t;\r\n            },\r\n            easeInQuad: function(t) {\r\n                return t * t;\r\n            },\r\n            easeOutQuad: function(t) {\r\n                return -1 * t * (t - 2);\r\n            },\r\n            easeInOutQuad: function(t) {\r\n                if ((t /= 1 / 2) < 1) {\r\n                    return 1 / 2 * t * t;\r\n                }\r\n                return -1 / 2 * ((--t) * (t - 2) - 1);\r\n            },\r\n            easeInCubic: function(t) {\r\n                return t * t * t;\r\n            },\r\n            easeOutCubic: function(t) {\r\n                return 1 * ((t = t / 1 - 1) * t * t + 1);\r\n            },\r\n            easeInOutCubic: function(t) {\r\n                if ((t /= 1 / 2) < 1) {\r\n                    return 1 / 2 * t * t * t;\r\n                }\r\n                return 1 / 2 * ((t -= 2) * t * t + 2);\r\n            },\r\n            easeInQuart: function(t) {\r\n                return t * t * t * t;\r\n            },\r\n            easeOutQuart: function(t) {\r\n                return -1 * ((t = t / 1 - 1) * t * t * t - 1);\r\n            },\r\n            easeInOutQuart: function(t) {\r\n                if ((t /= 1 / 2) < 1) {\r\n                    return 1 / 2 * t * t * t * t;\r\n                }\r\n                return -1 / 2 * ((t -= 2) * t * t * t - 2);\r\n            },\r\n            easeInQuint: function(t) {\r\n                return 1 * (t /= 1) * t * t * t * t;\r\n            },\r\n            easeOutQuint: function(t) {\r\n                return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\r\n            },\r\n            easeInOutQuint: function(t) {\r\n                if ((t /= 1 / 2) < 1) {\r\n                    return 1 / 2 * t * t * t * t * t;\r\n                }\r\n                return 1 / 2 * ((t -= 2) * t * t * t * t + 2);\r\n            },\r\n            easeInSine: function(t) {\r\n                return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\r\n            },\r\n            easeOutSine: function(t) {\r\n                return 1 * Math.sin(t / 1 * (Math.PI / 2));\r\n            },\r\n            easeInOutSine: function(t) {\r\n                return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);\r\n            },\r\n            easeInExpo: function(t) {\r\n                return (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\r\n            },\r\n            easeOutExpo: function(t) {\r\n                return (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\r\n            },\r\n            easeInOutExpo: function(t) {\r\n                if (t === 0) {\r\n                    return 0;\r\n                }\r\n                if (t === 1) {\r\n                    return 1;\r\n                }\r\n                if ((t /= 1 / 2) < 1) {\r\n                    return 1 / 2 * Math.pow(2, 10 * (t - 1));\r\n                }\r\n                return 1 / 2 * (-Math.pow(2, -10 * --t) + 2);\r\n            },\r\n            easeInCirc: function(t) {\r\n                if (t >= 1) {\r\n                    return t;\r\n                }\r\n                return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\r\n            },\r\n            easeOutCirc: function(t) {\r\n                return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\r\n            },\r\n            easeInOutCirc: function(t) {\r\n                if ((t /= 1 / 2) < 1) {\r\n                    return -1 / 2 * (Math.sqrt(1 - t * t) - 1);\r\n                }\r\n                return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);\r\n            },\r\n            easeInElastic: function(t) {\r\n                var s = 1.70158;\r\n                var p = 0;\r\n                var a = 1;\r\n                if (t === 0) {\r\n                    return 0;\r\n                }\r\n                if ((t /= 1) === 1) {\r\n                    return 1;\r\n                }\r\n                if (!p) {\r\n                    p = 1 * 0.3;\r\n                }\r\n                if (a < Math.abs(1)) {\r\n                    a = 1;\r\n                    s = p / 4;\r\n                } else {\r\n                    s = p / (2 * Math.PI) * Math.asin(1 / a);\r\n                }\r\n                return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\r\n            },\r\n            easeOutElastic: function(t) {\r\n                var s = 1.70158;\r\n                var p = 0;\r\n                var a = 1;\r\n                if (t === 0) {\r\n                    return 0;\r\n                }\r\n                if ((t /= 1) === 1) {\r\n                    return 1;\r\n                }\r\n                if (!p) {\r\n                    p = 1 * 0.3;\r\n                }\r\n                if (a < Math.abs(1)) {\r\n                    a = 1;\r\n                    s = p / 4;\r\n                } else {\r\n                    s = p / (2 * Math.PI) * Math.asin(1 / a);\r\n                }\r\n                return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;\r\n            },\r\n            easeInOutElastic: function(t) {\r\n                var s = 1.70158;\r\n                var p = 0;\r\n                var a = 1;\r\n                if (t === 0) {\r\n                    return 0;\r\n                }\r\n                if ((t /= 1 / 2) === 2) {\r\n                    return 1;\r\n                }\r\n                if (!p) {\r\n                    p = 1 * (0.3 * 1.5);\r\n                }\r\n                if (a < Math.abs(1)) {\r\n                    a = 1;\r\n                    s = p / 4;\r\n                } else {\r\n                    s = p / (2 * Math.PI) * Math.asin(1 / a);\r\n                }\r\n                if (t < 1) {\r\n                    return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\r\n                }\r\n                return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\r\n            },\r\n            easeInBack: function(t) {\r\n                var s = 1.70158;\r\n                return 1 * (t /= 1) * t * ((s + 1) * t - s);\r\n            },\r\n            easeOutBack: function(t) {\r\n                var s = 1.70158;\r\n                return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);\r\n            },\r\n            easeInOutBack: function(t) {\r\n                var s = 1.70158;\r\n                if ((t /= 1 / 2) < 1) {\r\n                    return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));\r\n                }\r\n                return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\r\n            },\r\n            easeInBounce: function(t) {\r\n                return 1 - easingEffects.easeOutBounce(1 - t);\r\n            },\r\n            easeOutBounce: function(t) {\r\n                if ((t /= 1) < (1 / 2.75)) {\r\n                    return 1 * (7.5625 * t * t);\r\n                } else if (t < (2 / 2.75)) {\r\n                    return 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);\r\n                } else if (t < (2.5 / 2.75)) {\r\n                    return 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);\r\n                }\r\n                return 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);\r\n            },\r\n            easeInOutBounce: function(t) {\r\n                if (t < 1 / 2) {\r\n                    return easingEffects.easeInBounce(t * 2) * 0.5;\r\n                }\r\n                return easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;\r\n            }\r\n        };\r\n        // Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n        helpers.requestAnimFrame = (function() {\r\n            return window.requestAnimationFrame ||\r\n                window.webkitRequestAnimationFrame ||\r\n                window.mozRequestAnimationFrame ||\r\n                window.oRequestAnimationFrame ||\r\n                window.msRequestAnimationFrame ||\r\n                function(callback) {\r\n                    return window.setTimeout(callback, 1000 / 60);\r\n                };\r\n        }());\r\n        helpers.cancelAnimFrame = (function() {\r\n            return window.cancelAnimationFrame ||\r\n                window.webkitCancelAnimationFrame ||\r\n                window.mozCancelAnimationFrame ||\r\n                window.oCancelAnimationFrame ||\r\n                window.msCancelAnimationFrame ||\r\n                function(callback) {\r\n                    return window.clearTimeout(callback, 1000 / 60);\r\n                };\r\n        }());\r\n        // -- DOM methods\r\n        helpers.getRelativePosition = function(evt, chart) {\r\n            var mouseX, mouseY;\r\n            var e = evt.originalEvent || evt,\r\n                canvas = evt.currentTarget || evt.srcElement,\r\n                boundingRect = canvas.getBoundingClientRect();\r\n\r\n            var touches = e.touches;\r\n            if (touches && touches.length > 0) {\r\n                mouseX = touches[0].clientX;\r\n                mouseY = touches[0].clientY;\r\n\r\n            } else {\r\n                mouseX = e.clientX;\r\n                mouseY = e.clientY;\r\n            }\r\n\r\n            // Scale mouse coordinates into canvas coordinates\r\n            // by following the pattern laid out by 'jerryj' in the comments of\r\n            // http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\r\n            var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\r\n            var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\r\n            var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\r\n            var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\r\n            var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\r\n            var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\r\n\r\n            // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\r\n            // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\r\n            mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\r\n            mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\r\n\r\n            return {\r\n                x: mouseX,\r\n                y: mouseY\r\n            };\r\n\r\n        };\r\n        helpers.addEvent = function(node, eventType, method) {\r\n            if (node.addEventListener) {\r\n                node.addEventListener(eventType, method);\r\n            } else if (node.attachEvent) {\r\n                node.attachEvent('on' + eventType, method);\r\n            } else {\r\n                node['on' + eventType] = method;\r\n            }\r\n        };\r\n        helpers.removeEvent = function(node, eventType, handler) {\r\n            if (node.removeEventListener) {\r\n                node.removeEventListener(eventType, handler, false);\r\n            } else if (node.detachEvent) {\r\n                node.detachEvent('on' + eventType, handler);\r\n            } else {\r\n                node['on' + eventType] = helpers.noop;\r\n            }\r\n        };\r\n        helpers.bindEvents = function(chartInstance, arrayOfEvents, handler) {\r\n            // Create the events object if it's not already present\r\n            var events = chartInstance.events = chartInstance.events || {};\r\n\r\n            helpers.each(arrayOfEvents, function(eventName) {\r\n                events[eventName] = function() {\r\n                    handler.apply(chartInstance, arguments);\r\n                };\r\n                helpers.addEvent(chartInstance.chart.canvas, eventName, events[eventName]);\r\n            });\r\n        };\r\n        helpers.unbindEvents = function(chartInstance, arrayOfEvents) {\r\n            var canvas = chartInstance.chart.canvas;\r\n            helpers.each(arrayOfEvents, function(handler, eventName) {\r\n                helpers.removeEvent(canvas, eventName, handler);\r\n            });\r\n        };\r\n\r\n        // Private helper function to convert max-width/max-height values that may be percentages into a number\r\n        function parseMaxStyle(styleValue, node, parentProperty) {\r\n            var valueInPixels;\r\n            if (typeof(styleValue) === 'string') {\r\n                valueInPixels = parseInt(styleValue, 10);\r\n\r\n                if (styleValue.indexOf('%') !== -1) {\r\n                    // percentage * size in dimension\r\n                    valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\r\n                }\r\n            } else {\r\n                valueInPixels = styleValue;\r\n            }\r\n\r\n            return valueInPixels;\r\n        }\r\n\r\n        /**\r\n         * Returns if the given value contains an effective constraint.\r\n         * @private\r\n         */\r\n        function isConstrainedValue(value) {\r\n            return value !== undefined && value !== null && value !== 'none';\r\n        }\r\n\r\n        // Private helper to get a constraint dimension\r\n        // @param domNode : the node to check the constraint on\r\n        // @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\r\n        // @param percentageProperty : property of parent to use when calculating width as a percentage\r\n        // @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\r\n        function getConstraintDimension(domNode, maxStyle, percentageProperty) {\r\n            var view = document.defaultView;\r\n            var parentNode = domNode.parentNode;\r\n            var constrainedNode = view.getComputedStyle(domNode)[maxStyle];\r\n            var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\r\n            var hasCNode = isConstrainedValue(constrainedNode);\r\n            var hasCContainer = isConstrainedValue(constrainedContainer);\r\n            var infinity = Number.POSITIVE_INFINITY;\r\n\r\n            if (hasCNode || hasCContainer) {\r\n                return Math.min(\r\n                    hasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\r\n                    hasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\r\n            }\r\n\r\n            return 'none';\r\n        }\r\n        // returns Number or undefined if no constraint\r\n        helpers.getConstraintWidth = function(domNode) {\r\n            return getConstraintDimension(domNode, 'max-width', 'clientWidth');\r\n        };\r\n        // returns Number or undefined if no constraint\r\n        helpers.getConstraintHeight = function(domNode) {\r\n            return getConstraintDimension(domNode, 'max-height', 'clientHeight');\r\n        };\r\n        helpers.getMaximumWidth = function(domNode) {\r\n            var container = domNode.parentNode;\r\n            var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\r\n            var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\r\n            var w = container.clientWidth - paddingLeft - paddingRight;\r\n            var cw = helpers.getConstraintWidth(domNode);\r\n            return isNaN(cw)? w : Math.min(w, cw);\r\n        };\r\n        helpers.getMaximumHeight = function(domNode) {\r\n            var container = domNode.parentNode;\r\n            var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\r\n            var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\r\n            var h = container.clientHeight - paddingTop - paddingBottom;\r\n            var ch = helpers.getConstraintHeight(domNode);\r\n            return isNaN(ch)? h : Math.min(h, ch);\r\n        };\r\n        helpers.getStyle = function(el, property) {\r\n            return el.currentStyle ?\r\n                el.currentStyle[property] :\r\n                document.defaultView.getComputedStyle(el, null).getPropertyValue(property);\r\n        };\r\n        helpers.retinaScale = function(chart) {\r\n            var pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;\r\n            if (pixelRatio === 1) {\r\n                return;\r\n            }\r\n\r\n            var canvas = chart.canvas;\r\n            var height = chart.height;\r\n            var width = chart.width;\r\n\r\n            canvas.height = height * pixelRatio;\r\n            canvas.width = width * pixelRatio;\r\n            chart.ctx.scale(pixelRatio, pixelRatio);\r\n\r\n            // If no style has been set on the canvas, the render size is used as display size,\r\n            // making the chart visually bigger, so let's enforce it to the \"correct\" values.\r\n            // See https://github.com/chartjs/Chart.js/issues/3575\r\n            canvas.style.height = height + 'px';\r\n            canvas.style.width = width + 'px';\r\n        };\r\n        // -- Canvas methods\r\n        helpers.clear = function(chart) {\r\n            chart.ctx.clearRect(0, 0, chart.width, chart.height);\r\n        };\r\n        helpers.fontString = function(pixelSize, fontStyle, fontFamily) {\r\n            return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\r\n        };\r\n        helpers.longestText = function(ctx, font, arrayOfThings, cache) {\r\n            cache = cache || {};\r\n            var data = cache.data = cache.data || {};\r\n            var gc = cache.garbageCollect = cache.garbageCollect || [];\r\n\r\n            if (cache.font !== font) {\r\n                data = cache.data = {};\r\n                gc = cache.garbageCollect = [];\r\n                cache.font = font;\r\n            }\r\n\r\n            ctx.font = font;\r\n            var longest = 0;\r\n            helpers.each(arrayOfThings, function(thing) {\r\n                // Undefined strings and arrays should not be measured\r\n                if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\r\n                    longest = helpers.measureText(ctx, data, gc, longest, thing);\r\n                } else if (helpers.isArray(thing)) {\r\n                    // if it is an array lets measure each element\r\n                    // to do maybe simplify this function a bit so we can do this more recursively?\r\n                    helpers.each(thing, function(nestedThing) {\r\n                        // Undefined strings and arrays should not be measured\r\n                        if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\r\n                            longest = helpers.measureText(ctx, data, gc, longest, nestedThing);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n\r\n            var gcLen = gc.length / 2;\r\n            if (gcLen > arrayOfThings.length) {\r\n                for (var i = 0; i < gcLen; i++) {\r\n                    delete data[gc[i]];\r\n                }\r\n                gc.splice(0, gcLen);\r\n            }\r\n            return longest;\r\n        };\r\n        helpers.measureText = function(ctx, data, gc, longest, string) {\r\n            var textWidth = data[string];\r\n            if (!textWidth) {\r\n                textWidth = data[string] = ctx.measureText(string).width;\r\n                gc.push(string);\r\n            }\r\n            if (textWidth > longest) {\r\n                longest = textWidth;\r\n            }\r\n            return longest;\r\n        };\r\n        helpers.numberOfLabelLines = function(arrayOfThings) {\r\n            var numberOfLines = 1;\r\n            helpers.each(arrayOfThings, function(thing) {\r\n                if (helpers.isArray(thing)) {\r\n                    if (thing.length > numberOfLines) {\r\n                        numberOfLines = thing.length;\r\n                    }\r\n                }\r\n            });\r\n            return numberOfLines;\r\n        };\r\n        helpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {\r\n            ctx.beginPath();\r\n            ctx.moveTo(x + radius, y);\r\n            ctx.lineTo(x + width - radius, y);\r\n            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n            ctx.lineTo(x + width, y + height - radius);\r\n            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n            ctx.lineTo(x + radius, y + height);\r\n            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n            ctx.lineTo(x, y + radius);\r\n            ctx.quadraticCurveTo(x, y, x + radius, y);\r\n            ctx.closePath();\r\n        };\r\n        helpers.color = function(c) {\r\n            if (!color) {\r\n                console.error('Color.js not found!');\r\n                return c;\r\n            }\r\n\r\n            /* global CanvasGradient */\r\n            if (c instanceof CanvasGradient) {\r\n                return color(Chart.defaults.global.defaultColor);\r\n            }\r\n\r\n            return color(c);\r\n        };\r\n        helpers.addResizeListener = function(node, callback) {\r\n            var iframe = document.createElement('iframe');\r\n            iframe.className = 'chartjs-hidden-iframe';\r\n            iframe.style.cssText =\r\n                'display:block;'+\r\n                'overflow:hidden;'+\r\n                'border:0;'+\r\n                'margin:0;'+\r\n                'top:0;'+\r\n                'left:0;'+\r\n                'bottom:0;'+\r\n                'right:0;'+\r\n                'height:100%;'+\r\n                'width:100%;'+\r\n                'position:absolute;'+\r\n                'pointer-events:none;'+\r\n                'z-index:-1;';\r\n\r\n            // Prevent the iframe to gain focus on tab.\r\n            // https://github.com/chartjs/Chart.js/issues/3090\r\n            iframe.tabIndex = -1;\r\n\r\n            // Let's keep track of this added iframe and thus avoid DOM query when removing it.\r\n            var stub = node._chartjs = {\r\n                resizer: iframe,\r\n                ticking: false\r\n            };\r\n\r\n            // Throttle the callback notification until the next animation frame.\r\n            var notify = function() {\r\n                if (!stub.ticking) {\r\n                    stub.ticking = true;\r\n                    helpers.requestAnimFrame.call(window, function() {\r\n                        if (stub.resizer) {\r\n                            stub.ticking = false;\r\n                            return callback();\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n\r\n            // If the iframe is re-attached to the DOM, the resize listener is removed because the\r\n            // content is reloaded, so make sure to install the handler after the iframe is loaded.\r\n            // https://github.com/chartjs/Chart.js/issues/3521\r\n            helpers.addEvent(iframe, 'load', function() {\r\n                helpers.addEvent(iframe.contentWindow || iframe, 'resize', notify);\r\n\r\n                // The iframe size might have changed while loading, which can also\r\n                // happen if the size has been changed while detached from the DOM.\r\n                notify();\r\n            });\r\n\r\n            node.insertBefore(iframe, node.firstChild);\r\n        };\r\n        helpers.removeResizeListener = function(node) {\r\n            if (!node || !node._chartjs) {\r\n                return;\r\n            }\r\n\r\n            var iframe = node._chartjs.resizer;\r\n            if (iframe) {\r\n                iframe.parentNode.removeChild(iframe);\r\n                node._chartjs.resizer = null;\r\n            }\r\n\r\n            delete node._chartjs;\r\n        };\r\n        helpers.isArray = Array.isArray?\r\n            function(obj) {\r\n                return Array.isArray(obj);\r\n            } :\r\n            function(obj) {\r\n                return Object.prototype.toString.call(obj) === '[object Array]';\r\n            };\r\n        // ! @see http://stackoverflow.com/a/14853974\r\n        helpers.arrayEquals = function(a0, a1) {\r\n            var i, ilen, v0, v1;\r\n\r\n            if (!a0 || !a1 || a0.length !== a1.length) {\r\n                return false;\r\n            }\r\n\r\n            for (i = 0, ilen=a0.length; i < ilen; ++i) {\r\n                v0 = a0[i];\r\n                v1 = a1[i];\r\n\r\n                if (v0 instanceof Array && v1 instanceof Array) {\r\n                    if (!helpers.arrayEquals(v0, v1)) {\r\n                        return false;\r\n                    }\r\n                } else if (v0 !== v1) {\r\n                    // NOTE: two different object instances will never be equal: {x:20} != {x:20}\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n        helpers.callCallback = function(fn, args, _tArg) {\r\n            if (fn && typeof fn.call === 'function') {\r\n                fn.apply(_tArg, args);\r\n            }\r\n        };\r\n        helpers.getHoverColor = function(colorValue) {\r\n            /* global CanvasPattern */\r\n            return (colorValue instanceof CanvasPattern) ?\r\n                colorValue :\r\n                helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\r\n        };\r\n    };\r\n\r\n},{\"3\":3}],27:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n        var helpers = Chart.helpers;\r\n\r\n        /**\r\n         * Helper function to traverse all of the visible elements in the chart\r\n         * @param chart {chart} the chart\r\n         * @param handler {Function} the callback to execute for each visible item\r\n         */\r\n        function parseVisibleItems(chart, handler) {\r\n            var datasets = chart.data.datasets;\r\n            var meta, i, j, ilen, jlen;\r\n\r\n            for (i = 0, ilen = datasets.length; i < ilen; ++i) {\r\n                if (!chart.isDatasetVisible(i)) {\r\n                    continue;\r\n                }\r\n\r\n                meta = chart.getDatasetMeta(i);\r\n                for (j = 0, jlen = meta.data.length; j < jlen; ++j) {\r\n                    var element = meta.data[j];\r\n                    if (!element._view.skip) {\r\n                        handler(element);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Helper function to get the items that intersect the event position\r\n         * @param items {ChartElement[]} elements to filter\r\n         * @param position {Point} the point to be nearest to\r\n         * @return {ChartElement[]} the nearest items\r\n         */\r\n        function getIntersectItems(chart, position) {\r\n            var elements = [];\r\n\r\n            parseVisibleItems(chart, function(element) {\r\n                if (element.inRange(position.x, position.y)) {\r\n                    elements.push(element);\r\n                }\r\n            });\r\n\r\n            return elements;\r\n        }\r\n\r\n        /**\r\n         * Helper function to get the items nearest to the event position considering all visible items in teh chart\r\n         * @param chart {Chart} the chart to look at elements from\r\n         * @param position {Point} the point to be nearest to\r\n         * @param intersect {Boolean} if true, only consider items that intersect the position\r\n         * @param distanceMetric {Function} Optional function to provide the distance between\r\n         * @return {ChartElement[]} the nearest items\r\n         */\r\n        function getNearestItems(chart, position, intersect, distanceMetric) {\r\n            var minDistance = Number.POSITIVE_INFINITY;\r\n            var nearestItems = [];\r\n\r\n            if (!distanceMetric) {\r\n                distanceMetric = helpers.distanceBetweenPoints;\r\n            }\r\n\r\n            parseVisibleItems(chart, function(element) {\r\n                if (intersect && !element.inRange(position.x, position.y)) {\r\n                    return;\r\n                }\r\n\r\n                var center = element.getCenterPoint();\r\n                var distance = distanceMetric(position, center);\r\n\r\n                if (distance < minDistance) {\r\n                    nearestItems = [element];\r\n                    minDistance = distance;\r\n                } else if (distance === minDistance) {\r\n                    // Can have multiple items at the same distance in which case we sort by size\r\n                    nearestItems.push(element);\r\n                }\r\n            });\r\n\r\n            return nearestItems;\r\n        }\r\n\r\n        function indexMode(chart, e, options) {\r\n            var position = helpers.getRelativePosition(e, chart.chart);\r\n            var distanceMetric = function(pt1, pt2) {\r\n                return Math.abs(pt1.x - pt2.x);\r\n            };\r\n            var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\r\n            var elements = [];\r\n\r\n            if (!items.length) {\r\n                return [];\r\n            }\r\n\r\n            chart.data.datasets.forEach(function(dataset, datasetIndex) {\r\n                if (chart.isDatasetVisible(datasetIndex)) {\r\n                    var meta = chart.getDatasetMeta(datasetIndex),\r\n                        element = meta.data[items[0]._index];\r\n\r\n                    // don't count items that are skipped (null data)\r\n                    if (element && !element._view.skip) {\r\n                        elements.push(element);\r\n                    }\r\n                }\r\n            });\r\n\r\n            return elements;\r\n        }\r\n\r\n        /**\r\n         * @interface IInteractionOptions\r\n         */\r\n        /**\r\n         * If true, only consider items that intersect the point\r\n         * @name IInterfaceOptions#boolean\r\n         * @type Boolean\r\n         */\r\n\r\n        /**\r\n         * @namespace Chart.Interaction\r\n         * Contains interaction related functions\r\n         */\r\n        Chart.Interaction = {\r\n            // Helper function for different modes\r\n            modes: {\r\n                single: function(chart, e) {\r\n                    var position = helpers.getRelativePosition(e, chart.chart);\r\n                    var elements = [];\r\n\r\n                    parseVisibleItems(chart, function(element) {\r\n                        if (element.inRange(position.x, position.y)) {\r\n                            elements.push(element);\r\n                            return elements;\r\n                        }\r\n                    });\r\n\r\n                    return elements.slice(0, 1);\r\n                },\r\n\r\n                /**\r\n                 * @function Chart.Interaction.modes.label\r\n                 * @deprecated since version 2.4.0\r\n                 */\r\n                label: indexMode,\r\n\r\n                /**\r\n                 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\r\n                 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\r\n                 * @function Chart.Interaction.modes.index\r\n                 * @since v2.4.0\r\n                 * @param chart {chart} the chart we are returning items from\r\n                 * @param e {Event} the event we are find things at\r\n                 * @param options {IInteractionOptions} options to use during interaction\r\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n                 */\r\n                index: indexMode,\r\n\r\n                /**\r\n                 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\r\n                 * If the options.intersect is false, we find the nearest item and return the items in that dataset\r\n                 * @function Chart.Interaction.modes.dataset\r\n                 * @param chart {chart} the chart we are returning items from\r\n                 * @param e {Event} the event we are find things at\r\n                 * @param options {IInteractionOptions} options to use during interaction\r\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n                 */\r\n                dataset: function(chart, e, options) {\r\n                    var position = helpers.getRelativePosition(e, chart.chart);\r\n                    var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\r\n\r\n                    if (items.length > 0) {\r\n                        items = chart.getDatasetMeta(items[0]._datasetIndex).data;\r\n                    }\r\n\r\n                    return items;\r\n                },\r\n\r\n                /**\r\n                 * @function Chart.Interaction.modes.x-axis\r\n                 * @deprecated since version 2.4.0. Use index mode and intersect == true\r\n                 */\r\n                'x-axis': function(chart, e) {\r\n                    return indexMode(chart, e, true);\r\n                },\r\n\r\n                /**\r\n                 * Point mode returns all elements that hit test based on the event position\r\n                 * of the event\r\n                 * @function Chart.Interaction.modes.intersect\r\n                 * @param chart {chart} the chart we are returning items from\r\n                 * @param e {Event} the event we are find things at\r\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n                 */\r\n                point: function(chart, e) {\r\n                    var position = helpers.getRelativePosition(e, chart.chart);\r\n                    return getIntersectItems(chart, position);\r\n                },\r\n\r\n                /**\r\n                 * nearest mode returns the element closest to the point\r\n                 * @function Chart.Interaction.modes.intersect\r\n                 * @param chart {chart} the chart we are returning items from\r\n                 * @param e {Event} the event we are find things at\r\n                 * @param options {IInteractionOptions} options to use\r\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n                 */\r\n                nearest: function(chart, e, options) {\r\n                    var position = helpers.getRelativePosition(e, chart.chart);\r\n                    var nearestItems = getNearestItems(chart, position, options.intersect);\r\n\r\n                    // We have multiple items at the same distance from the event. Now sort by smallest\r\n                    if (nearestItems.length > 1) {\r\n                        nearestItems.sort(function(a, b) {\r\n                            var sizeA = a.getArea();\r\n                            var sizeB = b.getArea();\r\n                            var ret = sizeA - sizeB;\r\n\r\n                            if (ret === 0) {\r\n                                // if equal sort by dataset index\r\n                                ret = a._datasetIndex - b._datasetIndex;\r\n                            }\r\n\r\n                            return ret;\r\n                        });\r\n                    }\r\n\r\n                    // Return only 1 item\r\n                    return nearestItems.slice(0, 1);\r\n                },\r\n\r\n                /**\r\n                 * x mode returns the elements that hit-test at the current x coordinate\r\n                 * @function Chart.Interaction.modes.x\r\n                 * @param chart {chart} the chart we are returning items from\r\n                 * @param e {Event} the event we are find things at\r\n                 * @param options {IInteractionOptions} options to use\r\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n                 */\r\n                x: function(chart, e, options) {\r\n                    var position = helpers.getRelativePosition(e, chart.chart);\r\n                    var items = [];\r\n                    var intersectsItem = false;\r\n\r\n                    parseVisibleItems(chart, function(element) {\r\n                        if (element.inXRange(position.x)) {\r\n                            items.push(element);\r\n                        }\r\n\r\n                        if (element.inRange(position.x, position.y)) {\r\n                            intersectsItem = true;\r\n                        }\r\n                    });\r\n\r\n                    // If we want to trigger on an intersect and we don't have any items\r\n                    // that intersect the position, return nothing\r\n                    if (options.intersect && !intersectsItem) {\r\n                        items = [];\r\n                    }\r\n                    return items;\r\n                },\r\n\r\n                /**\r\n                 * y mode returns the elements that hit-test at the current y coordinate\r\n                 * @function Chart.Interaction.modes.y\r\n                 * @param chart {chart} the chart we are returning items from\r\n                 * @param e {Event} the event we are find things at\r\n                 * @param options {IInteractionOptions} options to use\r\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\r\n                 */\r\n                y: function(chart, e, options) {\r\n                    var position = helpers.getRelativePosition(e, chart.chart);\r\n                    var items = [];\r\n                    var intersectsItem = false;\r\n\r\n                    parseVisibleItems(chart, function(element) {\r\n                        if (element.inYRange(position.y)) {\r\n                            items.push(element);\r\n                        }\r\n\r\n                        if (element.inRange(position.x, position.y)) {\r\n                            intersectsItem = true;\r\n                        }\r\n                    });\r\n\r\n                    // If we want to trigger on an intersect and we don't have any items\r\n                    // that intersect the position, return nothing\r\n                    if (options.intersect && !intersectsItem) {\r\n                        items = [];\r\n                    }\r\n                    return items;\r\n                }\r\n            }\r\n        };\r\n    };\r\n\r\n},{}],28:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function() {\r\n\r\n        // Occupy the global variable of Chart, and create a simple base class\r\n        var Chart = function(item, config) {\r\n            this.controller = new Chart.Controller(item, config, this);\r\n            return this.controller;\r\n        };\r\n\r\n        // Globally expose the defaults to allow for user updating/changing\r\n        Chart.defaults = {\r\n            global: {\r\n                responsive: true,\r\n                responsiveAnimationDuration: 0,\r\n                maintainAspectRatio: true,\r\n                events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\r\n                hover: {\r\n                    onHover: null,\r\n                    mode: 'nearest',\r\n                    intersect: true,\r\n                    animationDuration: 400\r\n                },\r\n                onClick: null,\r\n                defaultColor: 'rgba(0,0,0,0.1)',\r\n                defaultFontColor: '#666',\r\n                defaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\r\n                defaultFontSize: 12,\r\n                defaultFontStyle: 'normal',\r\n                showLines: true,\r\n\r\n                // Element defaults defined in element extensions\r\n                elements: {},\r\n\r\n                // Legend callback string\r\n                legendCallback: function(chart) {\r\n                    var text = [];\r\n                    text.push('<ul class=\"' + chart.id + '-legend\">');\r\n                    for (var i = 0; i < chart.data.datasets.length; i++) {\r\n                        text.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\r\n                        if (chart.data.datasets[i].label) {\r\n                            text.push(chart.data.datasets[i].label);\r\n                        }\r\n                        text.push('</li>');\r\n                    }\r\n                    text.push('</ul>');\r\n\r\n                    return text.join('');\r\n                }\r\n            }\r\n        };\r\n\r\n        Chart.Chart = Chart;\r\n\r\n        return Chart;\r\n    };\r\n\r\n},{}],29:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        // The layout service is very self explanatory.  It's responsible for the layout within a chart.\r\n        // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\r\n        // It is this service's responsibility of carrying out that layout.\r\n        Chart.layoutService = {\r\n            defaults: {},\r\n\r\n            // Register a box to a chartInstance. A box is simply a reference to an object that requires layout. eg. Scales, Legend, Plugins.\r\n            addBox: function(chartInstance, box) {\r\n                if (!chartInstance.boxes) {\r\n                    chartInstance.boxes = [];\r\n                }\r\n                chartInstance.boxes.push(box);\r\n            },\r\n\r\n            removeBox: function(chartInstance, box) {\r\n                if (!chartInstance.boxes) {\r\n                    return;\r\n                }\r\n                chartInstance.boxes.splice(chartInstance.boxes.indexOf(box), 1);\r\n            },\r\n\r\n            // The most important function\r\n            update: function(chartInstance, width, height) {\r\n\r\n                if (!chartInstance) {\r\n                    return;\r\n                }\r\n\r\n                var layoutOptions = chartInstance.options.layout;\r\n                var padding = layoutOptions ? layoutOptions.padding : null;\r\n\r\n                var leftPadding = 0;\r\n                var rightPadding = 0;\r\n                var topPadding = 0;\r\n                var bottomPadding = 0;\r\n\r\n                if (!isNaN(padding)) {\r\n                    // options.layout.padding is a number. assign to all\r\n                    leftPadding = padding;\r\n                    rightPadding = padding;\r\n                    topPadding = padding;\r\n                    bottomPadding = padding;\r\n                } else {\r\n                    leftPadding = padding.left || 0;\r\n                    rightPadding = padding.right || 0;\r\n                    topPadding = padding.top || 0;\r\n                    bottomPadding = padding.bottom || 0;\r\n                }\r\n\r\n                var leftBoxes = helpers.where(chartInstance.boxes, function(box) {\r\n                    return box.options.position === 'left';\r\n                });\r\n                var rightBoxes = helpers.where(chartInstance.boxes, function(box) {\r\n                    return box.options.position === 'right';\r\n                });\r\n                var topBoxes = helpers.where(chartInstance.boxes, function(box) {\r\n                    return box.options.position === 'top';\r\n                });\r\n                var bottomBoxes = helpers.where(chartInstance.boxes, function(box) {\r\n                    return box.options.position === 'bottom';\r\n                });\r\n\r\n                // Boxes that overlay the chartarea such as the radialLinear scale\r\n                var chartAreaBoxes = helpers.where(chartInstance.boxes, function(box) {\r\n                    return box.options.position === 'chartArea';\r\n                });\r\n\r\n                // Ensure that full width boxes are at the very top / bottom\r\n                topBoxes.sort(function(a, b) {\r\n                    return (b.options.fullWidth ? 1 : 0) - (a.options.fullWidth ? 1 : 0);\r\n                });\r\n                bottomBoxes.sort(function(a, b) {\r\n                    return (a.options.fullWidth ? 1 : 0) - (b.options.fullWidth ? 1 : 0);\r\n                });\r\n\r\n                // Essentially we now have any number of boxes on each of the 4 sides.\r\n                // Our canvas looks like the following.\r\n                // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\r\n                // B1 is the bottom axis\r\n                // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\r\n                // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\r\n                // an error will be thrown.\r\n                //\r\n                // |----------------------------------------------------|\r\n                // |                  T1 (Full Width)                   |\r\n                // |----------------------------------------------------|\r\n                // |    |    |                 T2                  |    |\r\n                // |    |----|-------------------------------------|----|\r\n                // |    |    | C1 |                           | C2 |    |\r\n                // |    |    |----|                           |----|    |\r\n                // |    |    |                                     |    |\r\n                // | L1 | L2 |           ChartArea (C0)            | R1 |\r\n                // |    |    |                                     |    |\r\n                // |    |    |----|                           |----|    |\r\n                // |    |    | C3 |                           | C4 |    |\r\n                // |    |----|-------------------------------------|----|\r\n                // |    |    |                 B1                  |    |\r\n                // |----------------------------------------------------|\r\n                // |                  B2 (Full Width)                   |\r\n                // |----------------------------------------------------|\r\n                //\r\n                // What we do to find the best sizing, we do the following\r\n                // 1. Determine the minimum size of the chart area.\r\n                // 2. Split the remaining width equally between each vertical axis\r\n                // 3. Split the remaining height equally between each horizontal axis\r\n                // 4. Give each layout the maximum size it can be. The layout will return it's minimum size\r\n                // 5. Adjust the sizes of each axis based on it's minimum reported size.\r\n                // 6. Refit each axis\r\n                // 7. Position each axis in the final location\r\n                // 8. Tell the chart the final location of the chart area\r\n                // 9. Tell any axes that overlay the chart area the positions of the chart area\r\n\r\n                // Step 1\r\n                var chartWidth = width - leftPadding - rightPadding;\r\n                var chartHeight = height - topPadding - bottomPadding;\r\n                var chartAreaWidth = chartWidth / 2; // min 50%\r\n                var chartAreaHeight = chartHeight / 2; // min 50%\r\n\r\n                // Step 2\r\n                var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\r\n\r\n                // Step 3\r\n                var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\r\n\r\n                // Step 4\r\n                var maxChartAreaWidth = chartWidth;\r\n                var maxChartAreaHeight = chartHeight;\r\n                var minBoxSizes = [];\r\n\r\n                function getMinimumBoxSize(box) {\r\n                    var minSize;\r\n                    var isHorizontal = box.isHorizontal();\r\n\r\n                    if (isHorizontal) {\r\n                        minSize = box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\r\n                        maxChartAreaHeight -= minSize.height;\r\n                    } else {\r\n                        minSize = box.update(verticalBoxWidth, chartAreaHeight);\r\n                        maxChartAreaWidth -= minSize.width;\r\n                    }\r\n\r\n                    minBoxSizes.push({\r\n                        horizontal: isHorizontal,\r\n                        minSize: minSize,\r\n                        box: box\r\n                    });\r\n                }\r\n\r\n                helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\r\n\r\n                // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\r\n                // be if the axes are drawn at their minimum sizes.\r\n\r\n                // Steps 5 & 6\r\n                var totalLeftBoxesWidth = leftPadding;\r\n                var totalRightBoxesWidth = rightPadding;\r\n                var totalTopBoxesHeight = topPadding;\r\n                var totalBottomBoxesHeight = bottomPadding;\r\n\r\n                // Function to fit a box\r\n                function fitBox(box) {\r\n                    var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\r\n                        return minBox.box === box;\r\n                    });\r\n\r\n                    if (minBoxSize) {\r\n                        if (box.isHorizontal()) {\r\n                            var scaleMargin = {\r\n                                left: totalLeftBoxesWidth,\r\n                                right: totalRightBoxesWidth,\r\n                                top: 0,\r\n                                bottom: 0\r\n                            };\r\n\r\n                            // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\r\n                            // on the margin. Sometimes they need to increase in size slightly\r\n                            box.update(box.options.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\r\n                        } else {\r\n                            box.update(minBoxSize.minSize.width, maxChartAreaHeight);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Update, and calculate the left and right margins for the horizontal boxes\r\n                helpers.each(leftBoxes.concat(rightBoxes), fitBox);\r\n\r\n                helpers.each(leftBoxes, function(box) {\r\n                    totalLeftBoxesWidth += box.width;\r\n                });\r\n\r\n                helpers.each(rightBoxes, function(box) {\r\n                    totalRightBoxesWidth += box.width;\r\n                });\r\n\r\n                // Set the Left and Right margins for the horizontal boxes\r\n                helpers.each(topBoxes.concat(bottomBoxes), fitBox);\r\n\r\n                // Figure out how much margin is on the top and bottom of the vertical boxes\r\n                helpers.each(topBoxes, function(box) {\r\n                    totalTopBoxesHeight += box.height;\r\n                });\r\n\r\n                helpers.each(bottomBoxes, function(box) {\r\n                    totalBottomBoxesHeight += box.height;\r\n                });\r\n\r\n                function finalFitVerticalBox(box) {\r\n                    var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\r\n                        return minSize.box === box;\r\n                    });\r\n\r\n                    var scaleMargin = {\r\n                        left: 0,\r\n                        right: 0,\r\n                        top: totalTopBoxesHeight,\r\n                        bottom: totalBottomBoxesHeight\r\n                    };\r\n\r\n                    if (minBoxSize) {\r\n                        box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\r\n                    }\r\n                }\r\n\r\n                // Let the left layout know the final margin\r\n                helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\r\n\r\n                // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\r\n                totalLeftBoxesWidth = leftPadding;\r\n                totalRightBoxesWidth = rightPadding;\r\n                totalTopBoxesHeight = topPadding;\r\n                totalBottomBoxesHeight = bottomPadding;\r\n\r\n                helpers.each(leftBoxes, function(box) {\r\n                    totalLeftBoxesWidth += box.width;\r\n                });\r\n\r\n                helpers.each(rightBoxes, function(box) {\r\n                    totalRightBoxesWidth += box.width;\r\n                });\r\n\r\n                helpers.each(topBoxes, function(box) {\r\n                    totalTopBoxesHeight += box.height;\r\n                });\r\n                helpers.each(bottomBoxes, function(box) {\r\n                    totalBottomBoxesHeight += box.height;\r\n                });\r\n\r\n                // Figure out if our chart area changed. This would occur if the dataset layout label rotation\r\n                // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\r\n                // without calling `fit` again\r\n                var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\r\n                var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\r\n\r\n                if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\r\n                    helpers.each(leftBoxes, function(box) {\r\n                        box.height = newMaxChartAreaHeight;\r\n                    });\r\n\r\n                    helpers.each(rightBoxes, function(box) {\r\n                        box.height = newMaxChartAreaHeight;\r\n                    });\r\n\r\n                    helpers.each(topBoxes, function(box) {\r\n                        if (!box.options.fullWidth) {\r\n                            box.width = newMaxChartAreaWidth;\r\n                        }\r\n                    });\r\n\r\n                    helpers.each(bottomBoxes, function(box) {\r\n                        if (!box.options.fullWidth) {\r\n                            box.width = newMaxChartAreaWidth;\r\n                        }\r\n                    });\r\n\r\n                    maxChartAreaHeight = newMaxChartAreaHeight;\r\n                    maxChartAreaWidth = newMaxChartAreaWidth;\r\n                }\r\n\r\n                // Step 7 - Position the boxes\r\n                var left = leftPadding;\r\n                var top = topPadding;\r\n\r\n                function placeBox(box) {\r\n                    if (box.isHorizontal()) {\r\n                        box.left = box.options.fullWidth ? leftPadding : totalLeftBoxesWidth;\r\n                        box.right = box.options.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\r\n                        box.top = top;\r\n                        box.bottom = top + box.height;\r\n\r\n                        // Move to next point\r\n                        top = box.bottom;\r\n\r\n                    } else {\r\n\r\n                        box.left = left;\r\n                        box.right = left + box.width;\r\n                        box.top = totalTopBoxesHeight;\r\n                        box.bottom = totalTopBoxesHeight + maxChartAreaHeight;\r\n\r\n                        // Move to next point\r\n                        left = box.right;\r\n                    }\r\n                }\r\n\r\n                helpers.each(leftBoxes.concat(topBoxes), placeBox);\r\n\r\n                // Account for chart width and height\r\n                left += maxChartAreaWidth;\r\n                top += maxChartAreaHeight;\r\n\r\n                helpers.each(rightBoxes, placeBox);\r\n                helpers.each(bottomBoxes, placeBox);\r\n\r\n                // Step 8\r\n                chartInstance.chartArea = {\r\n                    left: totalLeftBoxesWidth,\r\n                    top: totalTopBoxesHeight,\r\n                    right: totalLeftBoxesWidth + maxChartAreaWidth,\r\n                    bottom: totalTopBoxesHeight + maxChartAreaHeight\r\n                };\r\n\r\n                // Step 9\r\n                helpers.each(chartAreaBoxes, function(box) {\r\n                    box.left = chartInstance.chartArea.left;\r\n                    box.top = chartInstance.chartArea.top;\r\n                    box.right = chartInstance.chartArea.right;\r\n                    box.bottom = chartInstance.chartArea.bottom;\r\n\r\n                    box.update(maxChartAreaWidth, maxChartAreaHeight);\r\n                });\r\n            }\r\n        };\r\n    };\r\n\r\n},{}],30:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n        var noop = helpers.noop;\r\n\r\n        Chart.defaults.global.legend = {\r\n\r\n            display: true,\r\n            position: 'top',\r\n            fullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\r\n            reverse: false,\r\n\r\n            // a callback that will handle\r\n            onClick: function(e, legendItem) {\r\n                var index = legendItem.datasetIndex;\r\n                var ci = this.chart;\r\n                var meta = ci.getDatasetMeta(index);\r\n\r\n                // See controller.isDatasetVisible comment\r\n                meta.hidden = meta.hidden === null? !ci.data.datasets[index].hidden : null;\r\n\r\n                // We hid a dataset ... rerender the chart\r\n                ci.update();\r\n            },\r\n\r\n            onHover: null,\r\n\r\n            labels: {\r\n                boxWidth: 40,\r\n                padding: 10,\r\n                // Generates labels shown in the legend\r\n                // Valid properties to return:\r\n                // text : text to display\r\n                // fillStyle : fill of coloured box\r\n                // strokeStyle: stroke of coloured box\r\n                // hidden : if this legend item refers to a hidden item\r\n                // lineCap : cap style for line\r\n                // lineDash\r\n                // lineDashOffset :\r\n                // lineJoin :\r\n                // lineWidth :\r\n                generateLabels: function(chart) {\r\n                    var data = chart.data;\r\n                    return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\r\n                        return {\r\n                            text: dataset.label,\r\n                            fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\r\n                            hidden: !chart.isDatasetVisible(i),\r\n                            lineCap: dataset.borderCapStyle,\r\n                            lineDash: dataset.borderDash,\r\n                            lineDashOffset: dataset.borderDashOffset,\r\n                            lineJoin: dataset.borderJoinStyle,\r\n                            lineWidth: dataset.borderWidth,\r\n                            strokeStyle: dataset.borderColor,\r\n                            pointStyle: dataset.pointStyle,\r\n\r\n                            // Below is extra data used for toggling the datasets\r\n                            datasetIndex: i\r\n                        };\r\n                    }, this) : [];\r\n                }\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Helper function to get the box width based on the usePointStyle option\r\n         * @param labelopts {Object} the label options on the legend\r\n         * @param fontSize {Number} the label font size\r\n         * @return {Number} width of the color box area\r\n         */\r\n        function getBoxWidth(labelOpts, fontSize) {\r\n            return labelOpts.usePointStyle ?\r\n            fontSize * Math.SQRT2 :\r\n                labelOpts.boxWidth;\r\n        }\r\n\r\n        Chart.Legend = Chart.Element.extend({\r\n\r\n            initialize: function(config) {\r\n                helpers.extend(this, config);\r\n\r\n                // Contains hit boxes for each dataset (in dataset order)\r\n                this.legendHitBoxes = [];\r\n\r\n                // Are we in doughnut mode which has a different data type\r\n                this.doughnutMode = false;\r\n            },\r\n\r\n            // These methods are ordered by lifecycle. Utilities then follow.\r\n            // Any function defined here is inherited by all legend types.\r\n            // Any function can be extended by the legend type\r\n\r\n            beforeUpdate: noop,\r\n            update: function(maxWidth, maxHeight, margins) {\r\n                var me = this;\r\n\r\n                // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\r\n                me.beforeUpdate();\r\n\r\n                // Absorb the master measurements\r\n                me.maxWidth = maxWidth;\r\n                me.maxHeight = maxHeight;\r\n                me.margins = margins;\r\n\r\n                // Dimensions\r\n                me.beforeSetDimensions();\r\n                me.setDimensions();\r\n                me.afterSetDimensions();\r\n                // Labels\r\n                me.beforeBuildLabels();\r\n                me.buildLabels();\r\n                me.afterBuildLabels();\r\n\r\n                // Fit\r\n                me.beforeFit();\r\n                me.fit();\r\n                me.afterFit();\r\n                //\r\n                me.afterUpdate();\r\n\r\n                return me.minSize;\r\n            },\r\n            afterUpdate: noop,\r\n\r\n            //\r\n\r\n            beforeSetDimensions: noop,\r\n            setDimensions: function() {\r\n                var me = this;\r\n                // Set the unconstrained dimension before label rotation\r\n                if (me.isHorizontal()) {\r\n                    // Reset position before calculating rotation\r\n                    me.width = me.maxWidth;\r\n                    me.left = 0;\r\n                    me.right = me.width;\r\n                } else {\r\n                    me.height = me.maxHeight;\r\n\r\n                    // Reset position before calculating rotation\r\n                    me.top = 0;\r\n                    me.bottom = me.height;\r\n                }\r\n\r\n                // Reset padding\r\n                me.paddingLeft = 0;\r\n                me.paddingTop = 0;\r\n                me.paddingRight = 0;\r\n                me.paddingBottom = 0;\r\n\r\n                // Reset minSize\r\n                me.minSize = {\r\n                    width: 0,\r\n                    height: 0\r\n                };\r\n            },\r\n            afterSetDimensions: noop,\r\n\r\n            //\r\n\r\n            beforeBuildLabels: noop,\r\n            buildLabels: function() {\r\n                var me = this;\r\n                me.legendItems = me.options.labels.generateLabels.call(me, me.chart);\r\n                if (me.options.reverse) {\r\n                    me.legendItems.reverse();\r\n                }\r\n            },\r\n            afterBuildLabels: noop,\r\n\r\n            //\r\n\r\n            beforeFit: noop,\r\n            fit: function() {\r\n                var me = this;\r\n                var opts = me.options;\r\n                var labelOpts = opts.labels;\r\n                var display = opts.display;\r\n\r\n                var ctx = me.ctx;\r\n\r\n                var globalDefault = Chart.defaults.global,\r\n                    itemOrDefault = helpers.getValueOrDefault,\r\n                    fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\r\n                    fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\r\n                    fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\r\n                    labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\r\n\r\n                // Reset hit boxes\r\n                var hitboxes = me.legendHitBoxes = [];\r\n\r\n                var minSize = me.minSize;\r\n                var isHorizontal = me.isHorizontal();\r\n\r\n                if (isHorizontal) {\r\n                    minSize.width = me.maxWidth; // fill all the width\r\n                    minSize.height = display ? 10 : 0;\r\n                } else {\r\n                    minSize.width = display ? 10 : 0;\r\n                    minSize.height = me.maxHeight; // fill all the height\r\n                }\r\n\r\n                // Increase sizes here\r\n                if (display) {\r\n                    ctx.font = labelFont;\r\n\r\n                    if (isHorizontal) {\r\n                        // Labels\r\n\r\n                        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\r\n                        var lineWidths = me.lineWidths = [0];\r\n                        var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\r\n\r\n                        ctx.textAlign = 'left';\r\n                        ctx.textBaseline = 'top';\r\n\r\n                        helpers.each(me.legendItems, function(legendItem, i) {\r\n                            var boxWidth = getBoxWidth(labelOpts, fontSize);\r\n                            var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n                            if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\r\n                                totalHeight += fontSize + (labelOpts.padding);\r\n                                lineWidths[lineWidths.length] = me.left;\r\n                            }\r\n\r\n                            // Store the hitbox width and height here. Final position will be updated in `draw`\r\n                            hitboxes[i] = {\r\n                                left: 0,\r\n                                top: 0,\r\n                                width: width,\r\n                                height: fontSize\r\n                            };\r\n\r\n                            lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\r\n                        });\r\n\r\n                        minSize.height += totalHeight;\r\n\r\n                    } else {\r\n                        var vPadding = labelOpts.padding;\r\n                        var columnWidths = me.columnWidths = [];\r\n                        var totalWidth = labelOpts.padding;\r\n                        var currentColWidth = 0;\r\n                        var currentColHeight = 0;\r\n                        var itemHeight = fontSize + vPadding;\r\n\r\n                        helpers.each(me.legendItems, function(legendItem, i) {\r\n                            var boxWidth = getBoxWidth(labelOpts, fontSize);\r\n                            var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\r\n\r\n                            // If too tall, go to new column\r\n                            if (currentColHeight + itemHeight > minSize.height) {\r\n                                totalWidth += currentColWidth + labelOpts.padding;\r\n                                columnWidths.push(currentColWidth); // previous column width\r\n\r\n                                currentColWidth = 0;\r\n                                currentColHeight = 0;\r\n                            }\r\n\r\n                            // Get max width\r\n                            currentColWidth = Math.max(currentColWidth, itemWidth);\r\n                            currentColHeight += itemHeight;\r\n\r\n                            // Store the hitbox width and height here. Final position will be updated in `draw`\r\n                            hitboxes[i] = {\r\n                                left: 0,\r\n                                top: 0,\r\n                                width: itemWidth,\r\n                                height: fontSize\r\n                            };\r\n                        });\r\n\r\n                        totalWidth += currentColWidth;\r\n                        columnWidths.push(currentColWidth);\r\n                        minSize.width += totalWidth;\r\n                    }\r\n                }\r\n\r\n                me.width = minSize.width;\r\n                me.height = minSize.height;\r\n            },\r\n            afterFit: noop,\r\n\r\n            // Shared Methods\r\n            isHorizontal: function() {\r\n                return this.options.position === 'top' || this.options.position === 'bottom';\r\n            },\r\n\r\n            // Actually draw the legend on the canvas\r\n            draw: function() {\r\n                var me = this;\r\n                var opts = me.options;\r\n                var labelOpts = opts.labels;\r\n                var globalDefault = Chart.defaults.global,\r\n                    lineDefault = globalDefault.elements.line,\r\n                    legendWidth = me.width,\r\n                    lineWidths = me.lineWidths;\r\n\r\n                if (opts.display) {\r\n                    var ctx = me.ctx,\r\n                        cursor,\r\n                        itemOrDefault = helpers.getValueOrDefault,\r\n                        fontColor = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\r\n                        fontSize = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\r\n                        fontStyle = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\r\n                        fontFamily = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\r\n                        labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\r\n\r\n                    // Canvas setup\r\n                    ctx.textAlign = 'left';\r\n                    ctx.textBaseline = 'top';\r\n                    ctx.lineWidth = 0.5;\r\n                    ctx.strokeStyle = fontColor; // for strikethrough effect\r\n                    ctx.fillStyle = fontColor; // render in correct colour\r\n                    ctx.font = labelFont;\r\n\r\n                    var boxWidth = getBoxWidth(labelOpts, fontSize),\r\n                        hitboxes = me.legendHitBoxes;\r\n\r\n                    // current position\r\n                    var drawLegendBox = function(x, y, legendItem) {\r\n                        if (isNaN(boxWidth) || boxWidth <= 0) {\r\n                            return;\r\n                        }\r\n\r\n                        // Set the ctx for the box\r\n                        ctx.save();\r\n\r\n                        ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\r\n                        ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\r\n                        ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\r\n                        ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\r\n                        ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\r\n                        ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\r\n                        var isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\r\n\r\n                        if (ctx.setLineDash) {\r\n                            // IE 9 and 10 do not support line dash\r\n                            ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\r\n                        }\r\n\r\n                        if (opts.labels && opts.labels.usePointStyle) {\r\n                            // Recalculate x and y for drawPoint() because its expecting\r\n                            // x and y to be center of figure (instead of top left)\r\n                            var radius = fontSize * Math.SQRT2 / 2;\r\n                            var offSet = radius / Math.SQRT2;\r\n                            var centerX = x + offSet;\r\n                            var centerY = y + offSet;\r\n\r\n                            // Draw pointStyle as legend symbol\r\n                            Chart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\r\n                        } else {\r\n                            // Draw box as legend symbol\r\n                            if (!isLineWidthZero) {\r\n                                ctx.strokeRect(x, y, boxWidth, fontSize);\r\n                            }\r\n                            ctx.fillRect(x, y, boxWidth, fontSize);\r\n                        }\r\n\r\n                        ctx.restore();\r\n                    };\r\n                    var fillText = function(x, y, legendItem, textWidth) {\r\n                        ctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);\r\n\r\n                        if (legendItem.hidden) {\r\n                            // Strikethrough the text if hidden\r\n                            ctx.beginPath();\r\n                            ctx.lineWidth = 2;\r\n                            ctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));\r\n                            ctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));\r\n                            ctx.stroke();\r\n                        }\r\n                    };\r\n\r\n                    // Horizontal\r\n                    var isHorizontal = me.isHorizontal();\r\n                    if (isHorizontal) {\r\n                        cursor = {\r\n                            x: me.left + ((legendWidth - lineWidths[0]) / 2),\r\n                            y: me.top + labelOpts.padding,\r\n                            line: 0\r\n                        };\r\n                    } else {\r\n                        cursor = {\r\n                            x: me.left + labelOpts.padding,\r\n                            y: me.top + labelOpts.padding,\r\n                            line: 0\r\n                        };\r\n                    }\r\n\r\n                    var itemHeight = fontSize + labelOpts.padding;\r\n                    helpers.each(me.legendItems, function(legendItem, i) {\r\n                        var textWidth = ctx.measureText(legendItem.text).width,\r\n                            width = boxWidth + (fontSize / 2) + textWidth,\r\n                            x = cursor.x,\r\n                            y = cursor.y;\r\n\r\n                        if (isHorizontal) {\r\n                            if (x + width >= legendWidth) {\r\n                                y = cursor.y += itemHeight;\r\n                                cursor.line++;\r\n                                x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\r\n                            }\r\n                        } else if (y + itemHeight > me.bottom) {\r\n                            x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\r\n                            y = cursor.y = me.top;\r\n                            cursor.line++;\r\n                        }\r\n\r\n                        drawLegendBox(x, y, legendItem);\r\n\r\n                        hitboxes[i].left = x;\r\n                        hitboxes[i].top = y;\r\n\r\n                        // Fill the actual label\r\n                        fillText(x, y, legendItem, textWidth);\r\n\r\n                        if (isHorizontal) {\r\n                            cursor.x += width + (labelOpts.padding);\r\n                        } else {\r\n                            cursor.y += itemHeight;\r\n                        }\r\n\r\n                    });\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Handle an event\r\n             * @private\r\n             * @param e {Event} the event to handle\r\n             * @return {Boolean} true if a change occured\r\n             */\r\n            handleEvent: function(e) {\r\n                var me = this;\r\n                var opts = me.options;\r\n                var type = e.type === 'mouseup' ? 'click' : e.type;\r\n                var changed = false;\r\n\r\n                if (type === 'mousemove') {\r\n                    if (!opts.onHover) {\r\n                        return;\r\n                    }\r\n                } else if (type === 'click') {\r\n                    if (!opts.onClick) {\r\n                        return;\r\n                    }\r\n                } else {\r\n                    return;\r\n                }\r\n\r\n                var position = helpers.getRelativePosition(e, me.chart.chart),\r\n                    x = position.x,\r\n                    y = position.y;\r\n\r\n                if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\r\n                    // See if we are touching one of the dataset boxes\r\n                    var lh = me.legendHitBoxes;\r\n                    for (var i = 0; i < lh.length; ++i) {\r\n                        var hitBox = lh[i];\r\n\r\n                        if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\r\n                            // Touching an element\r\n                            if (type === 'click') {\r\n                                opts.onClick.call(me, e, me.legendItems[i]);\r\n                                changed = true;\r\n                                break;\r\n                            } else if (type === 'mousemove') {\r\n                                opts.onHover.call(me, e, me.legendItems[i]);\r\n                                changed = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return changed;\r\n            }\r\n        });\r\n\r\n        // Register the legend plugin\r\n        Chart.plugins.register({\r\n            beforeInit: function(chartInstance) {\r\n                var opts = chartInstance.options;\r\n                var legendOpts = opts.legend;\r\n\r\n                if (legendOpts) {\r\n                    chartInstance.legend = new Chart.Legend({\r\n                        ctx: chartInstance.chart.ctx,\r\n                        options: legendOpts,\r\n                        chart: chartInstance\r\n                    });\r\n\r\n                    Chart.layoutService.addBox(chartInstance, chartInstance.legend);\r\n                }\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],31:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var noop = Chart.helpers.noop;\r\n\r\n        /**\r\n         * The plugin service singleton\r\n         * @namespace Chart.plugins\r\n         * @since 2.1.0\r\n         */\r\n        Chart.plugins = {\r\n            _plugins: [],\r\n\r\n            /**\r\n             * Registers the given plugin(s) if not already registered.\r\n             * @param {Array|Object} plugins plugin instance(s).\r\n             */\r\n            register: function(plugins) {\r\n                var p = this._plugins;\r\n                ([]).concat(plugins).forEach(function(plugin) {\r\n                    if (p.indexOf(plugin) === -1) {\r\n                        p.push(plugin);\r\n                    }\r\n                });\r\n            },\r\n\r\n            /**\r\n             * Unregisters the given plugin(s) only if registered.\r\n             * @param {Array|Object} plugins plugin instance(s).\r\n             */\r\n            unregister: function(plugins) {\r\n                var p = this._plugins;\r\n                ([]).concat(plugins).forEach(function(plugin) {\r\n                    var idx = p.indexOf(plugin);\r\n                    if (idx !== -1) {\r\n                        p.splice(idx, 1);\r\n                    }\r\n                });\r\n            },\r\n\r\n            /**\r\n             * Remove all registered plugins.\r\n             * @since 2.1.5\r\n             */\r\n            clear: function() {\r\n                this._plugins = [];\r\n            },\r\n\r\n            /**\r\n             * Returns the number of registered plugins?\r\n             * @returns {Number}\r\n             * @since 2.1.5\r\n             */\r\n            count: function() {\r\n                return this._plugins.length;\r\n            },\r\n\r\n            /**\r\n             * Returns all registered plugin instances.\r\n             * @returns {Array} array of plugin objects.\r\n             * @since 2.1.5\r\n             */\r\n            getAll: function() {\r\n                return this._plugins;\r\n            },\r\n\r\n            /**\r\n             * Calls registered plugins on the specified extension, with the given args. This\r\n             * method immediately returns as soon as a plugin explicitly returns false. The\r\n             * returned value can be used, for instance, to interrupt the current action.\r\n             * @param {String} extension the name of the plugin method to call (e.g. 'beforeUpdate').\r\n             * @param {Array} [args] extra arguments to apply to the extension call.\r\n             * @returns {Boolean} false if any of the plugins return false, else returns true.\r\n             */\r\n            notify: function(extension, args) {\r\n                var plugins = this._plugins;\r\n                var ilen = plugins.length;\r\n                var i, plugin;\r\n\r\n                for (i=0; i<ilen; ++i) {\r\n                    plugin = plugins[i];\r\n                    if (typeof plugin[extension] === 'function') {\r\n                        if (plugin[extension].apply(plugin, args || []) === false) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Plugin extension methods.\r\n         * @interface Chart.PluginBase\r\n         * @since 2.1.0\r\n         */\r\n        Chart.PluginBase = Chart.Element.extend({\r\n            // Called at start of chart init\r\n            beforeInit: noop,\r\n\r\n            // Called at end of chart init\r\n            afterInit: noop,\r\n\r\n            // Called at start of update\r\n            beforeUpdate: noop,\r\n\r\n            // Called at end of update\r\n            afterUpdate: noop,\r\n\r\n            // Called at start of draw\r\n            beforeDraw: noop,\r\n\r\n            // Called at end of draw\r\n            afterDraw: noop,\r\n\r\n            // Called during destroy\r\n            destroy: noop\r\n        });\r\n\r\n        /**\r\n         * Provided for backward compatibility, use Chart.plugins instead\r\n         * @namespace Chart.pluginService\r\n         * @deprecated since version 2.1.5\r\n         * @todo remove me at version 3\r\n         */\r\n        Chart.pluginService = Chart.plugins;\r\n    };\r\n\r\n},{}],32:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        Chart.defaults.scale = {\r\n            display: true,\r\n            position: 'left',\r\n\r\n            // grid line settings\r\n            gridLines: {\r\n                display: true,\r\n                color: 'rgba(0, 0, 0, 0.1)',\r\n                lineWidth: 1,\r\n                drawBorder: true,\r\n                drawOnChartArea: true,\r\n                drawTicks: true,\r\n                tickMarkLength: 10,\r\n                zeroLineWidth: 1,\r\n                zeroLineColor: 'rgba(0,0,0,0.25)',\r\n                offsetGridLines: false,\r\n                borderDash: [],\r\n                borderDashOffset: 0.0\r\n            },\r\n\r\n            // scale label\r\n            scaleLabel: {\r\n                // actual label\r\n                labelString: '',\r\n\r\n                // display property\r\n                display: false\r\n            },\r\n\r\n            // label settings\r\n            ticks: {\r\n                beginAtZero: false,\r\n                minRotation: 0,\r\n                maxRotation: 50,\r\n                mirror: false,\r\n                padding: 10,\r\n                reverse: false,\r\n                display: true,\r\n                autoSkip: true,\r\n                autoSkipPadding: 0,\r\n                labelOffset: 0,\r\n                // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\r\n                callback: Chart.Ticks.formatters.values\r\n            }\r\n        };\r\n\r\n        Chart.Scale = Chart.Element.extend({\r\n\r\n            // These methods are ordered by lifecycle. Utilities then follow.\r\n            // Any function defined here is inherited by all scale types.\r\n            // Any function can be extended by the scale type\r\n\r\n            beforeUpdate: function() {\r\n                helpers.callCallback(this.options.beforeUpdate, [this]);\r\n            },\r\n            update: function(maxWidth, maxHeight, margins) {\r\n                var me = this;\r\n\r\n                // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\r\n                me.beforeUpdate();\r\n\r\n                // Absorb the master measurements\r\n                me.maxWidth = maxWidth;\r\n                me.maxHeight = maxHeight;\r\n                me.margins = helpers.extend({\r\n                    left: 0,\r\n                    right: 0,\r\n                    top: 0,\r\n                    bottom: 0\r\n                }, margins);\r\n\r\n                // Dimensions\r\n                me.beforeSetDimensions();\r\n                me.setDimensions();\r\n                me.afterSetDimensions();\r\n\r\n                // Data min/max\r\n                me.beforeDataLimits();\r\n                me.determineDataLimits();\r\n                me.afterDataLimits();\r\n\r\n                // Ticks\r\n                me.beforeBuildTicks();\r\n                me.buildTicks();\r\n                me.afterBuildTicks();\r\n\r\n                me.beforeTickToLabelConversion();\r\n                me.convertTicksToLabels();\r\n                me.afterTickToLabelConversion();\r\n\r\n                // Tick Rotation\r\n                me.beforeCalculateTickRotation();\r\n                me.calculateTickRotation();\r\n                me.afterCalculateTickRotation();\r\n                // Fit\r\n                me.beforeFit();\r\n                me.fit();\r\n                me.afterFit();\r\n                //\r\n                me.afterUpdate();\r\n\r\n                return me.minSize;\r\n\r\n            },\r\n            afterUpdate: function() {\r\n                helpers.callCallback(this.options.afterUpdate, [this]);\r\n            },\r\n\r\n            //\r\n\r\n            beforeSetDimensions: function() {\r\n                helpers.callCallback(this.options.beforeSetDimensions, [this]);\r\n            },\r\n            setDimensions: function() {\r\n                var me = this;\r\n                // Set the unconstrained dimension before label rotation\r\n                if (me.isHorizontal()) {\r\n                    // Reset position before calculating rotation\r\n                    me.width = me.maxWidth;\r\n                    me.left = 0;\r\n                    me.right = me.width;\r\n                } else {\r\n                    me.height = me.maxHeight;\r\n\r\n                    // Reset position before calculating rotation\r\n                    me.top = 0;\r\n                    me.bottom = me.height;\r\n                }\r\n\r\n                // Reset padding\r\n                me.paddingLeft = 0;\r\n                me.paddingTop = 0;\r\n                me.paddingRight = 0;\r\n                me.paddingBottom = 0;\r\n            },\r\n            afterSetDimensions: function() {\r\n                helpers.callCallback(this.options.afterSetDimensions, [this]);\r\n            },\r\n\r\n            // Data limits\r\n            beforeDataLimits: function() {\r\n                helpers.callCallback(this.options.beforeDataLimits, [this]);\r\n            },\r\n            determineDataLimits: helpers.noop,\r\n            afterDataLimits: function() {\r\n                helpers.callCallback(this.options.afterDataLimits, [this]);\r\n            },\r\n\r\n            //\r\n            beforeBuildTicks: function() {\r\n                helpers.callCallback(this.options.beforeBuildTicks, [this]);\r\n            },\r\n            buildTicks: helpers.noop,\r\n            afterBuildTicks: function() {\r\n                helpers.callCallback(this.options.afterBuildTicks, [this]);\r\n            },\r\n\r\n            beforeTickToLabelConversion: function() {\r\n                helpers.callCallback(this.options.beforeTickToLabelConversion, [this]);\r\n            },\r\n            convertTicksToLabels: function() {\r\n                var me = this;\r\n                // Convert ticks to strings\r\n                var tickOpts = me.options.ticks;\r\n                me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);\r\n            },\r\n            afterTickToLabelConversion: function() {\r\n                helpers.callCallback(this.options.afterTickToLabelConversion, [this]);\r\n            },\r\n\r\n            //\r\n\r\n            beforeCalculateTickRotation: function() {\r\n                helpers.callCallback(this.options.beforeCalculateTickRotation, [this]);\r\n            },\r\n            calculateTickRotation: function() {\r\n                var me = this;\r\n                var context = me.ctx;\r\n                var globalDefaults = Chart.defaults.global;\r\n                var optionTicks = me.options.ticks;\r\n\r\n                // Get the width of each grid by calculating the difference\r\n                // between x offsets between 0 and 1.\r\n                var tickFontSize = helpers.getValueOrDefault(optionTicks.fontSize, globalDefaults.defaultFontSize);\r\n                var tickFontStyle = helpers.getValueOrDefault(optionTicks.fontStyle, globalDefaults.defaultFontStyle);\r\n                var tickFontFamily = helpers.getValueOrDefault(optionTicks.fontFamily, globalDefaults.defaultFontFamily);\r\n                var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\r\n                context.font = tickLabelFont;\r\n\r\n                var firstWidth = context.measureText(me.ticks[0]).width;\r\n                var lastWidth = context.measureText(me.ticks[me.ticks.length - 1]).width;\r\n                var firstRotated;\r\n\r\n                me.labelRotation = optionTicks.minRotation || 0;\r\n                me.paddingRight = 0;\r\n                me.paddingLeft = 0;\r\n\r\n                if (me.options.display) {\r\n                    if (me.isHorizontal()) {\r\n                        me.paddingRight = lastWidth / 2 + 3;\r\n                        me.paddingLeft = firstWidth / 2 + 3;\r\n\r\n                        if (!me.longestTextCache) {\r\n                            me.longestTextCache = {};\r\n                        }\r\n                        var originalLabelWidth = helpers.longestText(context, tickLabelFont, me.ticks, me.longestTextCache);\r\n                        var labelWidth = originalLabelWidth;\r\n                        var cosRotation;\r\n                        var sinRotation;\r\n\r\n                        // Allow 3 pixels x2 padding either side for label readability\r\n                        // only the index matters for a dataset scale, but we want a consistent interface between scales\r\n                        var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\r\n\r\n                        // Max label rotation can be set or default to 90 - also act as a loop counter\r\n                        while (labelWidth > tickWidth && me.labelRotation < optionTicks.maxRotation) {\r\n                            cosRotation = Math.cos(helpers.toRadians(me.labelRotation));\r\n                            sinRotation = Math.sin(helpers.toRadians(me.labelRotation));\r\n\r\n                            firstRotated = cosRotation * firstWidth;\r\n\r\n                            // We're right aligning the text now.\r\n                            if (firstRotated + tickFontSize / 2 > me.yLabelWidth) {\r\n                                me.paddingLeft = firstRotated + tickFontSize / 2;\r\n                            }\r\n\r\n                            me.paddingRight = tickFontSize / 2;\r\n\r\n                            if (sinRotation * originalLabelWidth > me.maxHeight) {\r\n                                // go back one step\r\n                                me.labelRotation--;\r\n                                break;\r\n                            }\r\n\r\n                            me.labelRotation++;\r\n                            labelWidth = cosRotation * originalLabelWidth;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (me.margins) {\r\n                    me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\r\n                    me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\r\n                }\r\n            },\r\n            afterCalculateTickRotation: function() {\r\n                helpers.callCallback(this.options.afterCalculateTickRotation, [this]);\r\n            },\r\n\r\n            //\r\n\r\n            beforeFit: function() {\r\n                helpers.callCallback(this.options.beforeFit, [this]);\r\n            },\r\n            fit: function() {\r\n                var me = this;\r\n                // Reset\r\n                var minSize = me.minSize = {\r\n                    width: 0,\r\n                    height: 0\r\n                };\r\n\r\n                var opts = me.options;\r\n                var globalDefaults = Chart.defaults.global;\r\n                var tickOpts = opts.ticks;\r\n                var scaleLabelOpts = opts.scaleLabel;\r\n                var gridLineOpts = opts.gridLines;\r\n                var display = opts.display;\r\n                var isHorizontal = me.isHorizontal();\r\n\r\n                var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\r\n                var tickFontStyle = helpers.getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\r\n                var tickFontFamily = helpers.getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\r\n                var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\r\n\r\n                var scaleLabelFontSize = helpers.getValueOrDefault(scaleLabelOpts.fontSize, globalDefaults.defaultFontSize);\r\n\r\n                var tickMarkLength = opts.gridLines.tickMarkLength;\r\n\r\n                // Width\r\n                if (isHorizontal) {\r\n                    // subtract the margins to line up with the chartArea if we are a full width scale\r\n                    minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\r\n                } else {\r\n                    minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\r\n                }\r\n\r\n                // height\r\n                if (isHorizontal) {\r\n                    minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\r\n                } else {\r\n                    minSize.height = me.maxHeight; // fill all the height\r\n                }\r\n\r\n                // Are we showing a title for the scale?\r\n                if (scaleLabelOpts.display && display) {\r\n                    if (isHorizontal) {\r\n                        minSize.height += (scaleLabelFontSize * 1.5);\r\n                    } else {\r\n                        minSize.width += (scaleLabelFontSize * 1.5);\r\n                    }\r\n                }\r\n\r\n                if (tickOpts.display && display) {\r\n                    // Don't bother fitting the ticks if we are not showing them\r\n                    if (!me.longestTextCache) {\r\n                        me.longestTextCache = {};\r\n                    }\r\n\r\n                    var largestTextWidth = helpers.longestText(me.ctx, tickLabelFont, me.ticks, me.longestTextCache);\r\n                    var tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\r\n                    var lineSpace = tickFontSize * 0.5;\r\n\r\n                    if (isHorizontal) {\r\n                        // A horizontal axis is more constrained by the height.\r\n                        me.longestLabelWidth = largestTextWidth;\r\n\r\n                        // TODO - improve this calculation\r\n                        var labelHeight = (Math.sin(helpers.toRadians(me.labelRotation)) * me.longestLabelWidth) + (tickFontSize * tallestLabelHeightInLines) + (lineSpace * tallestLabelHeightInLines);\r\n\r\n                        minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\r\n                        me.ctx.font = tickLabelFont;\r\n\r\n                        var firstLabelWidth = me.ctx.measureText(me.ticks[0]).width;\r\n                        var lastLabelWidth = me.ctx.measureText(me.ticks[me.ticks.length - 1]).width;\r\n\r\n                        // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\r\n                        // by the font height\r\n                        var cosRotation = Math.cos(helpers.toRadians(me.labelRotation));\r\n                        var sinRotation = Math.sin(helpers.toRadians(me.labelRotation));\r\n                        me.paddingLeft = me.labelRotation !== 0 ? (cosRotation * firstLabelWidth) + 3 : firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\r\n                        me.paddingRight = me.labelRotation !== 0 ? (sinRotation * (tickFontSize / 2)) + 3 : lastLabelWidth / 2 + 3; // when rotated\r\n                    } else {\r\n                        // A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\r\n                        var maxLabelWidth = me.maxWidth - minSize.width;\r\n\r\n                        // Account for padding\r\n                        var mirror = tickOpts.mirror;\r\n                        if (!mirror) {\r\n                            largestTextWidth += me.options.ticks.padding;\r\n                        } else {\r\n                            // If mirrored text is on the inside so don't expand\r\n                            largestTextWidth = 0;\r\n                        }\r\n\r\n                        if (largestTextWidth < maxLabelWidth) {\r\n                            // We don't need all the room\r\n                            minSize.width += largestTextWidth;\r\n                        } else {\r\n                            // Expand to max size\r\n                            minSize.width = me.maxWidth;\r\n                        }\r\n\r\n                        me.paddingTop = tickFontSize / 2;\r\n                        me.paddingBottom = tickFontSize / 2;\r\n                    }\r\n                }\r\n\r\n                if (me.margins) {\r\n                    me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\r\n                    me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\r\n                    me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\r\n                    me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\r\n                }\r\n\r\n                me.width = minSize.width;\r\n                me.height = minSize.height;\r\n\r\n            },\r\n            afterFit: function() {\r\n                helpers.callCallback(this.options.afterFit, [this]);\r\n            },\r\n\r\n            // Shared Methods\r\n            isHorizontal: function() {\r\n                return this.options.position === 'top' || this.options.position === 'bottom';\r\n            },\r\n            isFullWidth: function() {\r\n                return (this.options.fullWidth);\r\n            },\r\n\r\n            // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\r\n            getRightValue: function(rawValue) {\r\n                // Null and undefined values first\r\n                if (rawValue === null || typeof(rawValue) === 'undefined') {\r\n                    return NaN;\r\n                }\r\n                // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\r\n                if (typeof(rawValue) === 'number' && !isFinite(rawValue)) {\r\n                    return NaN;\r\n                }\r\n                // If it is in fact an object, dive in one more level\r\n                if (typeof(rawValue) === 'object') {\r\n                    if ((rawValue instanceof Date) || (rawValue.isValid)) {\r\n                        return rawValue;\r\n                    }\r\n                    return this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\r\n                }\r\n\r\n                // Value is good, return it\r\n                return rawValue;\r\n            },\r\n\r\n            // Used to get the value to display in the tooltip for the data at the given index\r\n            // function getLabelForIndex(index, datasetIndex)\r\n            getLabelForIndex: helpers.noop,\r\n\r\n            // Used to get data value locations.  Value can either be an index or a numerical value\r\n            getPixelForValue: helpers.noop,\r\n\r\n            // Used to get the data value from a given pixel. This is the inverse of getPixelForValue\r\n            getValueForPixel: helpers.noop,\r\n\r\n            // Used for tick location, should\r\n            getPixelForTick: function(index, includeOffset) {\r\n                var me = this;\r\n                if (me.isHorizontal()) {\r\n                    var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\r\n                    var tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\r\n                    var pixel = (tickWidth * index) + me.paddingLeft;\r\n\r\n                    if (includeOffset) {\r\n                        pixel += tickWidth / 2;\r\n                    }\r\n\r\n                    var finalVal = me.left + Math.round(pixel);\r\n                    finalVal += me.isFullWidth() ? me.margins.left : 0;\r\n                    return finalVal;\r\n                }\r\n                var innerHeight = me.height - (me.paddingTop + me.paddingBottom);\r\n                return me.top + (index * (innerHeight / (me.ticks.length - 1)));\r\n            },\r\n\r\n            // Utility for getting the pixel location of a percentage of scale\r\n            getPixelForDecimal: function(decimal /* , includeOffset*/) {\r\n                var me = this;\r\n                if (me.isHorizontal()) {\r\n                    var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\r\n                    var valueOffset = (innerWidth * decimal) + me.paddingLeft;\r\n\r\n                    var finalVal = me.left + Math.round(valueOffset);\r\n                    finalVal += me.isFullWidth() ? me.margins.left : 0;\r\n                    return finalVal;\r\n                }\r\n                return me.top + (decimal * me.height);\r\n            },\r\n\r\n            getBasePixel: function() {\r\n                var me = this;\r\n                var min = me.min;\r\n                var max = me.max;\r\n\r\n                return me.getPixelForValue(\r\n                    me.beginAtZero? 0:\r\n                        min < 0 && max < 0? max :\r\n                            min > 0 && max > 0? min :\r\n                                0);\r\n            },\r\n\r\n            // Actually draw the scale on the canvas\r\n            // @param {rectangle} chartArea : the area of the chart to draw full grid lines on\r\n            draw: function(chartArea) {\r\n                var me = this;\r\n                var options = me.options;\r\n                if (!options.display) {\r\n                    return;\r\n                }\r\n\r\n                var context = me.ctx;\r\n                var globalDefaults = Chart.defaults.global;\r\n                var optionTicks = options.ticks;\r\n                var gridLines = options.gridLines;\r\n                var scaleLabel = options.scaleLabel;\r\n\r\n                var isRotated = me.labelRotation !== 0;\r\n                var skipRatio;\r\n                var useAutoskipper = optionTicks.autoSkip;\r\n                var isHorizontal = me.isHorizontal();\r\n\r\n                // figure out the maximum number of gridlines to show\r\n                var maxTicks;\r\n                if (optionTicks.maxTicksLimit) {\r\n                    maxTicks = optionTicks.maxTicksLimit;\r\n                }\r\n\r\n                var tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\r\n                var tickFontSize = helpers.getValueOrDefault(optionTicks.fontSize, globalDefaults.defaultFontSize);\r\n                var tickFontStyle = helpers.getValueOrDefault(optionTicks.fontStyle, globalDefaults.defaultFontStyle);\r\n                var tickFontFamily = helpers.getValueOrDefault(optionTicks.fontFamily, globalDefaults.defaultFontFamily);\r\n                var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\r\n                var tl = gridLines.tickMarkLength;\r\n                var borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\r\n                var borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\r\n\r\n                var scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\r\n                var scaleLabelFontSize = helpers.getValueOrDefault(scaleLabel.fontSize, globalDefaults.defaultFontSize);\r\n                var scaleLabelFontStyle = helpers.getValueOrDefault(scaleLabel.fontStyle, globalDefaults.defaultFontStyle);\r\n                var scaleLabelFontFamily = helpers.getValueOrDefault(scaleLabel.fontFamily, globalDefaults.defaultFontFamily);\r\n                var scaleLabelFont = helpers.fontString(scaleLabelFontSize, scaleLabelFontStyle, scaleLabelFontFamily);\r\n\r\n                var labelRotationRadians = helpers.toRadians(me.labelRotation);\r\n                var cosRotation = Math.cos(labelRotationRadians);\r\n                var longestRotatedLabel = me.longestLabelWidth * cosRotation;\r\n\r\n                // Make sure we draw text in the correct color and font\r\n                context.fillStyle = tickFontColor;\r\n\r\n                var itemsToDraw = [];\r\n\r\n                if (isHorizontal) {\r\n                    skipRatio = false;\r\n\r\n                    // Only calculate the skip ratio with the half width of longestRotateLabel if we got an actual rotation\r\n                    // See #2584\r\n                    if (isRotated) {\r\n                        longestRotatedLabel /= 2;\r\n                    }\r\n\r\n                    if ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {\r\n                        skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));\r\n                    }\r\n\r\n                    // if they defined a max number of optionTicks,\r\n                    // increase skipRatio until that number is met\r\n                    if (maxTicks && me.ticks.length > maxTicks) {\r\n                        while (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\r\n                            if (!skipRatio) {\r\n                                skipRatio = 1;\r\n                            }\r\n                            skipRatio += 1;\r\n                        }\r\n                    }\r\n\r\n                    if (!useAutoskipper) {\r\n                        skipRatio = false;\r\n                    }\r\n                }\r\n\r\n\r\n                var xTickStart = options.position === 'right' ? me.left : me.right - tl;\r\n                var xTickEnd = options.position === 'right' ? me.left + tl : me.right;\r\n                var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\r\n                var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\r\n\r\n                helpers.each(me.ticks, function(label, index) {\r\n                    // If the callback returned a null or undefined value, do not draw this line\r\n                    if (label === undefined || label === null) {\r\n                        return;\r\n                    }\r\n\r\n                    var isLastTick = me.ticks.length === index + 1;\r\n\r\n                    // Since we always show the last tick,we need may need to hide the last shown one before\r\n                    var shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);\r\n                    if (shouldSkip && !isLastTick || (label === undefined || label === null)) {\r\n                        return;\r\n                    }\r\n\r\n                    var lineWidth, lineColor;\r\n                    if (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\r\n                        // Draw the first index specially\r\n                        lineWidth = gridLines.zeroLineWidth;\r\n                        lineColor = gridLines.zeroLineColor;\r\n                    } else {\r\n                        lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\r\n                        lineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\r\n                    }\r\n\r\n                    // Common properties\r\n                    var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\r\n                    var textAlign = 'middle';\r\n                    var textBaseline = 'middle';\r\n\r\n                    if (isHorizontal) {\r\n                        if (!isRotated) {\r\n                            textBaseline = options.position === 'top' ? 'bottom' : 'top';\r\n                        }\r\n\r\n                        textAlign = isRotated ? 'right' : 'center';\r\n\r\n                        var xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\r\n                        labelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\r\n                        labelY = (isRotated) ? me.top + 12 : options.position === 'top' ? me.bottom - tl : me.top + tl;\r\n\r\n                        tx1 = tx2 = x1 = x2 = xLineValue;\r\n                        ty1 = yTickStart;\r\n                        ty2 = yTickEnd;\r\n                        y1 = chartArea.top;\r\n                        y2 = chartArea.bottom;\r\n                    } else {\r\n                        if (options.position === 'left') {\r\n                            if (optionTicks.mirror) {\r\n                                labelX = me.right + optionTicks.padding;\r\n                                textAlign = 'left';\r\n                            } else {\r\n                                labelX = me.right - optionTicks.padding;\r\n                                textAlign = 'right';\r\n                            }\r\n                            // right side\r\n                        } else if (optionTicks.mirror) {\r\n                            labelX = me.left - optionTicks.padding;\r\n                            textAlign = 'right';\r\n                        } else {\r\n                            labelX = me.left + optionTicks.padding;\r\n                            textAlign = 'left';\r\n                        }\r\n\r\n                        var yLineValue = me.getPixelForTick(index); // xvalues for grid lines\r\n                        yLineValue += helpers.aliasPixel(lineWidth);\r\n                        labelY = me.getPixelForTick(index, gridLines.offsetGridLines);\r\n\r\n                        tx1 = xTickStart;\r\n                        tx2 = xTickEnd;\r\n                        x1 = chartArea.left;\r\n                        x2 = chartArea.right;\r\n                        ty1 = ty2 = y1 = y2 = yLineValue;\r\n                    }\r\n\r\n                    itemsToDraw.push({\r\n                        tx1: tx1,\r\n                        ty1: ty1,\r\n                        tx2: tx2,\r\n                        ty2: ty2,\r\n                        x1: x1,\r\n                        y1: y1,\r\n                        x2: x2,\r\n                        y2: y2,\r\n                        labelX: labelX,\r\n                        labelY: labelY,\r\n                        glWidth: lineWidth,\r\n                        glColor: lineColor,\r\n                        glBorderDash: borderDash,\r\n                        glBorderDashOffset: borderDashOffset,\r\n                        rotation: -1 * labelRotationRadians,\r\n                        label: label,\r\n                        textBaseline: textBaseline,\r\n                        textAlign: textAlign\r\n                    });\r\n                });\r\n\r\n                // Draw all of the tick labels, tick marks, and grid lines at the correct places\r\n                helpers.each(itemsToDraw, function(itemToDraw) {\r\n                    if (gridLines.display) {\r\n                        context.save();\r\n                        context.lineWidth = itemToDraw.glWidth;\r\n                        context.strokeStyle = itemToDraw.glColor;\r\n                        if (context.setLineDash) {\r\n                            context.setLineDash(itemToDraw.glBorderDash);\r\n                            context.lineDashOffset = itemToDraw.glBorderDashOffset;\r\n                        }\r\n\r\n                        context.beginPath();\r\n\r\n                        if (gridLines.drawTicks) {\r\n                            context.moveTo(itemToDraw.tx1, itemToDraw.ty1);\r\n                            context.lineTo(itemToDraw.tx2, itemToDraw.ty2);\r\n                        }\r\n\r\n                        if (gridLines.drawOnChartArea) {\r\n                            context.moveTo(itemToDraw.x1, itemToDraw.y1);\r\n                            context.lineTo(itemToDraw.x2, itemToDraw.y2);\r\n                        }\r\n\r\n                        context.stroke();\r\n                        context.restore();\r\n                    }\r\n\r\n                    if (optionTicks.display) {\r\n                        context.save();\r\n                        context.translate(itemToDraw.labelX, itemToDraw.labelY);\r\n                        context.rotate(itemToDraw.rotation);\r\n                        context.font = tickLabelFont;\r\n                        context.textBaseline = itemToDraw.textBaseline;\r\n                        context.textAlign = itemToDraw.textAlign;\r\n\r\n                        var label = itemToDraw.label;\r\n                        if (helpers.isArray(label)) {\r\n                            for (var i = 0, y = -(label.length - 1)*tickFontSize*0.75; i < label.length; ++i) {\r\n                                // We just make sure the multiline element is a string here..\r\n                                context.fillText('' + label[i], 0, y);\r\n                                // apply same lineSpacing as calculated @ L#320\r\n                                y += (tickFontSize * 1.5);\r\n                            }\r\n                        } else {\r\n                            context.fillText(label, 0, 0);\r\n                        }\r\n                        context.restore();\r\n                    }\r\n                });\r\n\r\n                if (scaleLabel.display) {\r\n                    // Draw the scale label\r\n                    var scaleLabelX;\r\n                    var scaleLabelY;\r\n                    var rotation = 0;\r\n\r\n                    if (isHorizontal) {\r\n                        scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\r\n                        scaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFontSize / 2) : me.top + (scaleLabelFontSize / 2);\r\n                    } else {\r\n                        var isLeft = options.position === 'left';\r\n                        scaleLabelX = isLeft ? me.left + (scaleLabelFontSize / 2) : me.right - (scaleLabelFontSize / 2);\r\n                        scaleLabelY = me.top + ((me.bottom - me.top) / 2);\r\n                        rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\r\n                    }\r\n\r\n                    context.save();\r\n                    context.translate(scaleLabelX, scaleLabelY);\r\n                    context.rotate(rotation);\r\n                    context.textAlign = 'center';\r\n                    context.textBaseline = 'middle';\r\n                    context.fillStyle = scaleLabelFontColor; // render in correct colour\r\n                    context.font = scaleLabelFont;\r\n                    context.fillText(scaleLabel.labelString, 0, 0);\r\n                    context.restore();\r\n                }\r\n\r\n                if (gridLines.drawBorder) {\r\n                    // Draw the line at the edge of the axis\r\n                    context.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\r\n                    context.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\r\n                    var x1 = me.left,\r\n                        x2 = me.right,\r\n                        y1 = me.top,\r\n                        y2 = me.bottom;\r\n\r\n                    var aliasPixel = helpers.aliasPixel(context.lineWidth);\r\n                    if (isHorizontal) {\r\n                        y1 = y2 = options.position === 'top' ? me.bottom : me.top;\r\n                        y1 += aliasPixel;\r\n                        y2 += aliasPixel;\r\n                    } else {\r\n                        x1 = x2 = options.position === 'left' ? me.right : me.left;\r\n                        x1 += aliasPixel;\r\n                        x2 += aliasPixel;\r\n                    }\r\n\r\n                    context.beginPath();\r\n                    context.moveTo(x1, y1);\r\n                    context.lineTo(x2, y2);\r\n                    context.stroke();\r\n                }\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],33:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        Chart.scaleService = {\r\n            // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\r\n            // use the new chart options to grab the correct scale\r\n            constructors: {},\r\n            // Use a registration function so that we can move to an ES6 map when we no longer need to support\r\n            // old browsers\r\n\r\n            // Scale config defaults\r\n            defaults: {},\r\n            registerScaleType: function(type, scaleConstructor, defaults) {\r\n                this.constructors[type] = scaleConstructor;\r\n                this.defaults[type] = helpers.clone(defaults);\r\n            },\r\n            getScaleConstructor: function(type) {\r\n                return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\r\n            },\r\n            getScaleDefaults: function(type) {\r\n                // Return the scale defaults merged with the global settings so that we always use the latest ones\r\n                return this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};\r\n            },\r\n            updateScaleDefaults: function(type, additions) {\r\n                var defaults = this.defaults;\r\n                if (defaults.hasOwnProperty(type)) {\r\n                    defaults[type] = helpers.extend(defaults[type], additions);\r\n                }\r\n            },\r\n            addScalesToLayout: function(chartInstance) {\r\n                // Adds each scale to the chart.boxes array to be sized accordingly\r\n                helpers.each(chartInstance.scales, function(scale) {\r\n                    Chart.layoutService.addBox(chartInstance, scale);\r\n                });\r\n            }\r\n        };\r\n    };\r\n\r\n},{}],34:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        /**\r\n         * Namespace to hold static tick generation functions\r\n         * @namespace Chart.Ticks\r\n         */\r\n        Chart.Ticks = {\r\n            /**\r\n             * Namespace to hold generators for different types of ticks\r\n             * @namespace Chart.Ticks.generators\r\n             */\r\n            generators: {\r\n                /**\r\n                 * Interface for the options provided to the numeric tick generator\r\n                 * @interface INumericTickGenerationOptions\r\n                 */\r\n                /**\r\n                 * The maximum number of ticks to display\r\n                 * @name INumericTickGenerationOptions#maxTicks\r\n                 * @type Number\r\n                 */\r\n                /**\r\n                 * The distance between each tick.\r\n                 * @name INumericTickGenerationOptions#stepSize\r\n                 * @type Number\r\n                 * @optional\r\n                 */\r\n                /**\r\n                 * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\r\n                 * @name INumericTickGenerationOptions#min\r\n                 * @type Number\r\n                 * @optional\r\n                 */\r\n                /**\r\n                 * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\r\n                 * @name INumericTickGenerationOptions#max\r\n                 * @type Number\r\n                 * @optional\r\n                 */\r\n\r\n                /**\r\n                 * Generate a set of linear ticks\r\n                 * @method Chart.Ticks.generators.linear\r\n                 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\r\n                 * @param dataRange {IRange} the range of the data\r\n                 * @returns {Array<Number>} array of tick values\r\n                 */\r\n                linear: function(generationOptions, dataRange) {\r\n                    var ticks = [];\r\n                    // To get a \"nice\" value for the tick spacing, we will use the appropriately named\r\n                    // \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\r\n                    // for details.\r\n\r\n                    var spacing;\r\n                    if (generationOptions.stepSize && generationOptions.stepSize > 0) {\r\n                        spacing = generationOptions.stepSize;\r\n                    } else {\r\n                        var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\r\n                        spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\r\n                    }\r\n                    var niceMin = Math.floor(dataRange.min / spacing) * spacing;\r\n                    var niceMax = Math.ceil(dataRange.max / spacing) * spacing;\r\n\r\n                    // If min, max and stepSize is set and they make an evenly spaced scale use it.\r\n                    if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\r\n                        var minMaxDeltaDivisibleByStepSize = ((generationOptions.max - generationOptions.min) % generationOptions.stepSize) === 0;\r\n                        if (minMaxDeltaDivisibleByStepSize) {\r\n                            niceMin = generationOptions.min;\r\n                            niceMax = generationOptions.max;\r\n                        }\r\n                    }\r\n\r\n                    var numSpaces = (niceMax - niceMin) / spacing;\r\n                    // If very close to our rounded value, use it.\r\n                    if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\r\n                        numSpaces = Math.round(numSpaces);\r\n                    } else {\r\n                        numSpaces = Math.ceil(numSpaces);\r\n                    }\r\n\r\n                    // Put the values into the ticks array\r\n                    ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\r\n                    for (var j = 1; j < numSpaces; ++j) {\r\n                        ticks.push(niceMin + (j * spacing));\r\n                    }\r\n                    ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\r\n\r\n                    return ticks;\r\n                },\r\n\r\n                /**\r\n                 * Generate a set of logarithmic ticks\r\n                 * @method Chart.Ticks.generators.logarithmic\r\n                 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\r\n                 * @param dataRange {IRange} the range of the data\r\n                 * @returns {Array<Number>} array of tick values\r\n                 */\r\n                logarithmic: function(generationOptions, dataRange) {\r\n                    var ticks = [];\r\n                    var getValueOrDefault = helpers.getValueOrDefault;\r\n\r\n                    // Figure out what the max number of ticks we can support it is based on the size of\r\n                    // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\r\n                    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\r\n                    // the graph\r\n                    var tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\r\n\r\n                    while (tickVal < dataRange.max) {\r\n                        ticks.push(tickVal);\r\n\r\n                        var exp;\r\n                        var significand;\r\n\r\n                        if (tickVal === 0) {\r\n                            exp = Math.floor(helpers.log10(dataRange.minNotZero));\r\n                            significand = Math.round(dataRange.minNotZero / Math.pow(10, exp));\r\n                        } else {\r\n                            exp = Math.floor(helpers.log10(tickVal));\r\n                            significand = Math.floor(tickVal / Math.pow(10, exp)) + 1;\r\n                        }\r\n\r\n                        if (significand === 10) {\r\n                            significand = 1;\r\n                            ++exp;\r\n                        }\r\n\r\n                        tickVal = significand * Math.pow(10, exp);\r\n                    }\r\n\r\n                    var lastTick = getValueOrDefault(generationOptions.max, tickVal);\r\n                    ticks.push(lastTick);\r\n\r\n                    return ticks;\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Namespace to hold formatters for different types of ticks\r\n             * @namespace Chart.Ticks.formatters\r\n             */\r\n            formatters: {\r\n                /**\r\n                 * Formatter for value labels\r\n                 * @method Chart.Ticks.formatters.values\r\n                 * @param value the value to display\r\n                 * @return {String|Array} the label to display\r\n                 */\r\n                values: function(value) {\r\n                    return helpers.isArray(value) ? value : '' + value;\r\n                },\r\n\r\n                /**\r\n                 * Formatter for linear numeric ticks\r\n                 * @method Chart.Ticks.formatters.linear\r\n                 * @param tickValue {Number} the value to be formatted\r\n                 * @param index {Number} the position of the tickValue parameter in the ticks array\r\n                 * @param ticks {Array<Number>} the list of ticks being converted\r\n                 * @return {String} string representation of the tickValue parameter\r\n                 */\r\n                linear: function(tickValue, index, ticks) {\r\n                    // If we have lots of ticks, don't use the ones\r\n                    var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\r\n\r\n                    // If we have a number like 2.5 as the delta, figure out how many decimal places we need\r\n                    if (Math.abs(delta) > 1) {\r\n                        if (tickValue !== Math.floor(tickValue)) {\r\n                            // not an integer\r\n                            delta = tickValue - Math.floor(tickValue);\r\n                        }\r\n                    }\r\n\r\n                    var logDelta = helpers.log10(Math.abs(delta));\r\n                    var tickString = '';\r\n\r\n                    if (tickValue !== 0) {\r\n                        var numDecimal = -1 * Math.floor(logDelta);\r\n                        numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\r\n                        tickString = tickValue.toFixed(numDecimal);\r\n                    } else {\r\n                        tickString = '0'; // never show decimal places for 0\r\n                    }\r\n\r\n                    return tickString;\r\n                },\r\n\r\n                logarithmic: function(tickValue, index, ticks) {\r\n                    var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\r\n\r\n                    if (tickValue === 0) {\r\n                        return '0';\r\n                    } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\r\n                        return tickValue.toExponential();\r\n                    }\r\n                    return '';\r\n                }\r\n            }\r\n        };\r\n    };\r\n\r\n},{}],35:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        Chart.defaults.global.title = {\r\n            display: false,\r\n            position: 'top',\r\n            fullWidth: true, // marks that this box should take the full width of the canvas (pushing down other boxes)\r\n\r\n            fontStyle: 'bold',\r\n            padding: 10,\r\n\r\n            // actual title\r\n            text: ''\r\n        };\r\n\r\n        var noop = helpers.noop;\r\n        Chart.Title = Chart.Element.extend({\r\n\r\n            initialize: function(config) {\r\n                var me = this;\r\n                helpers.extend(me, config);\r\n                me.options = helpers.configMerge(Chart.defaults.global.title, config.options);\r\n\r\n                // Contains hit boxes for each dataset (in dataset order)\r\n                me.legendHitBoxes = [];\r\n            },\r\n\r\n            // These methods are ordered by lifecycle. Utilities then follow.\r\n\r\n            beforeUpdate: function() {\r\n                var chartOpts = this.chart.options;\r\n                if (chartOpts && chartOpts.title) {\r\n                    this.options = helpers.configMerge(Chart.defaults.global.title, chartOpts.title);\r\n                }\r\n            },\r\n            update: function(maxWidth, maxHeight, margins) {\r\n                var me = this;\r\n\r\n                // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\r\n                me.beforeUpdate();\r\n\r\n                // Absorb the master measurements\r\n                me.maxWidth = maxWidth;\r\n                me.maxHeight = maxHeight;\r\n                me.margins = margins;\r\n\r\n                // Dimensions\r\n                me.beforeSetDimensions();\r\n                me.setDimensions();\r\n                me.afterSetDimensions();\r\n                // Labels\r\n                me.beforeBuildLabels();\r\n                me.buildLabels();\r\n                me.afterBuildLabels();\r\n\r\n                // Fit\r\n                me.beforeFit();\r\n                me.fit();\r\n                me.afterFit();\r\n                //\r\n                me.afterUpdate();\r\n\r\n                return me.minSize;\r\n\r\n            },\r\n            afterUpdate: noop,\r\n\r\n            //\r\n\r\n            beforeSetDimensions: noop,\r\n            setDimensions: function() {\r\n                var me = this;\r\n                // Set the unconstrained dimension before label rotation\r\n                if (me.isHorizontal()) {\r\n                    // Reset position before calculating rotation\r\n                    me.width = me.maxWidth;\r\n                    me.left = 0;\r\n                    me.right = me.width;\r\n                } else {\r\n                    me.height = me.maxHeight;\r\n\r\n                    // Reset position before calculating rotation\r\n                    me.top = 0;\r\n                    me.bottom = me.height;\r\n                }\r\n\r\n                // Reset padding\r\n                me.paddingLeft = 0;\r\n                me.paddingTop = 0;\r\n                me.paddingRight = 0;\r\n                me.paddingBottom = 0;\r\n\r\n                // Reset minSize\r\n                me.minSize = {\r\n                    width: 0,\r\n                    height: 0\r\n                };\r\n            },\r\n            afterSetDimensions: noop,\r\n\r\n            //\r\n\r\n            beforeBuildLabels: noop,\r\n            buildLabels: noop,\r\n            afterBuildLabels: noop,\r\n\r\n            //\r\n\r\n            beforeFit: noop,\r\n            fit: function() {\r\n                var me = this,\r\n                    valueOrDefault = helpers.getValueOrDefault,\r\n                    opts = me.options,\r\n                    globalDefaults = Chart.defaults.global,\r\n                    display = opts.display,\r\n                    fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\r\n                    minSize = me.minSize;\r\n\r\n                if (me.isHorizontal()) {\r\n                    minSize.width = me.maxWidth; // fill all the width\r\n                    minSize.height = display ? fontSize + (opts.padding * 2) : 0;\r\n                } else {\r\n                    minSize.width = display ? fontSize + (opts.padding * 2) : 0;\r\n                    minSize.height = me.maxHeight; // fill all the height\r\n                }\r\n\r\n                me.width = minSize.width;\r\n                me.height = minSize.height;\r\n\r\n            },\r\n            afterFit: noop,\r\n\r\n            // Shared Methods\r\n            isHorizontal: function() {\r\n                var pos = this.options.position;\r\n                return pos === 'top' || pos === 'bottom';\r\n            },\r\n\r\n            // Actually draw the title block on the canvas\r\n            draw: function() {\r\n                var me = this,\r\n                    ctx = me.ctx,\r\n                    valueOrDefault = helpers.getValueOrDefault,\r\n                    opts = me.options,\r\n                    globalDefaults = Chart.defaults.global;\r\n\r\n                if (opts.display) {\r\n                    var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\r\n                        fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),\r\n                        fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),\r\n                        titleFont = helpers.fontString(fontSize, fontStyle, fontFamily),\r\n                        rotation = 0,\r\n                        titleX,\r\n                        titleY,\r\n                        top = me.top,\r\n                        left = me.left,\r\n                        bottom = me.bottom,\r\n                        right = me.right,\r\n                        maxWidth;\r\n\r\n                    ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\r\n                    ctx.font = titleFont;\r\n\r\n                    // Horizontal\r\n                    if (me.isHorizontal()) {\r\n                        titleX = left + ((right - left) / 2); // midpoint of the width\r\n                        titleY = top + ((bottom - top) / 2); // midpoint of the height\r\n                        maxWidth = right - left;\r\n                    } else {\r\n                        titleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);\r\n                        titleY = top + ((bottom - top) / 2);\r\n                        maxWidth = bottom - top;\r\n                        rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\r\n                    }\r\n\r\n                    ctx.save();\r\n                    ctx.translate(titleX, titleY);\r\n                    ctx.rotate(rotation);\r\n                    ctx.textAlign = 'center';\r\n                    ctx.textBaseline = 'middle';\r\n                    ctx.fillText(opts.text, 0, 0, maxWidth);\r\n                    ctx.restore();\r\n                }\r\n            }\r\n        });\r\n\r\n        // Register the title plugin\r\n        Chart.plugins.register({\r\n            beforeInit: function(chartInstance) {\r\n                var opts = chartInstance.options;\r\n                var titleOpts = opts.title;\r\n\r\n                if (titleOpts) {\r\n                    chartInstance.titleBlock = new Chart.Title({\r\n                        ctx: chartInstance.chart.ctx,\r\n                        options: titleOpts,\r\n                        chart: chartInstance\r\n                    });\r\n\r\n                    Chart.layoutService.addBox(chartInstance, chartInstance.titleBlock);\r\n                }\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],36:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        /**\r\n         * Helper method to merge the opacity into a color\r\n         */\r\n        function mergeOpacity(colorString, opacity) {\r\n            var color = helpers.color(colorString);\r\n            return color.alpha(opacity * color.alpha()).rgbaString();\r\n        }\r\n\r\n        Chart.defaults.global.tooltips = {\r\n            enabled: true,\r\n            custom: null,\r\n            mode: 'nearest',\r\n            position: 'average',\r\n            intersect: true,\r\n            backgroundColor: 'rgba(0,0,0,0.8)',\r\n            titleFontStyle: 'bold',\r\n            titleSpacing: 2,\r\n            titleMarginBottom: 6,\r\n            titleFontColor: '#fff',\r\n            titleAlign: 'left',\r\n            bodySpacing: 2,\r\n            bodyFontColor: '#fff',\r\n            bodyAlign: 'left',\r\n            footerFontStyle: 'bold',\r\n            footerSpacing: 2,\r\n            footerMarginTop: 6,\r\n            footerFontColor: '#fff',\r\n            footerAlign: 'left',\r\n            yPadding: 6,\r\n            xPadding: 6,\r\n            caretSize: 5,\r\n            cornerRadius: 6,\r\n            multiKeyBackground: '#fff',\r\n            displayColors: true,\r\n            callbacks: {\r\n                // Args are: (tooltipItems, data)\r\n                beforeTitle: helpers.noop,\r\n                title: function(tooltipItems, data) {\r\n                    // Pick first xLabel for now\r\n                    var title = '';\r\n                    var labels = data.labels;\r\n                    var labelCount = labels ? labels.length : 0;\r\n\r\n                    if (tooltipItems.length > 0) {\r\n                        var item = tooltipItems[0];\r\n\r\n                        if (item.xLabel) {\r\n                            title = item.xLabel;\r\n                        } else if (labelCount > 0 && item.index < labelCount) {\r\n                            title = labels[item.index];\r\n                        }\r\n                    }\r\n\r\n                    return title;\r\n                },\r\n                afterTitle: helpers.noop,\r\n\r\n                // Args are: (tooltipItems, data)\r\n                beforeBody: helpers.noop,\r\n\r\n                // Args are: (tooltipItem, data)\r\n                beforeLabel: helpers.noop,\r\n                label: function(tooltipItem, data) {\r\n                    var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\r\n                    return datasetLabel + ': ' + tooltipItem.yLabel;\r\n                },\r\n                labelColor: function(tooltipItem, chartInstance) {\r\n                    var meta = chartInstance.getDatasetMeta(tooltipItem.datasetIndex);\r\n                    var activeElement = meta.data[tooltipItem.index];\r\n                    var view = activeElement._view;\r\n                    return {\r\n                        borderColor: view.borderColor,\r\n                        backgroundColor: view.backgroundColor\r\n                    };\r\n                },\r\n                afterLabel: helpers.noop,\r\n\r\n                // Args are: (tooltipItems, data)\r\n                afterBody: helpers.noop,\r\n\r\n                // Args are: (tooltipItems, data)\r\n                beforeFooter: helpers.noop,\r\n                footer: helpers.noop,\r\n                afterFooter: helpers.noop\r\n            }\r\n        };\r\n\r\n        // Helper to push or concat based on if the 2nd parameter is an array or not\r\n        function pushOrConcat(base, toPush) {\r\n            if (toPush) {\r\n                if (helpers.isArray(toPush)) {\r\n                    // base = base.concat(toPush);\r\n                    Array.prototype.push.apply(base, toPush);\r\n                } else {\r\n                    base.push(toPush);\r\n                }\r\n            }\r\n\r\n            return base;\r\n        }\r\n\r\n        // Private helper to create a tooltip item model\r\n        // @param element : the chart element (point, arc, bar) to create the tooltip item for\r\n        // @return : new tooltip item\r\n        function createTooltipItem(element) {\r\n            var xScale = element._xScale;\r\n            var yScale = element._yScale || element._scale; // handle radar || polarArea charts\r\n            var index = element._index,\r\n                datasetIndex = element._datasetIndex;\r\n\r\n            return {\r\n                xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\r\n                yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\r\n                index: index,\r\n                datasetIndex: datasetIndex,\r\n                x: element._model.x,\r\n                y: element._model.y\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Helper to get the reset model for the tooltip\r\n         * @param tooltipOpts {Object} the tooltip options\r\n         */\r\n        function getBaseModel(tooltipOpts) {\r\n            var globalDefaults = Chart.defaults.global;\r\n            var getValueOrDefault = helpers.getValueOrDefault;\r\n\r\n            return {\r\n                // Positioning\r\n                xPadding: tooltipOpts.xPadding,\r\n                yPadding: tooltipOpts.yPadding,\r\n                xAlign: tooltipOpts.xAlign,\r\n                yAlign: tooltipOpts.yAlign,\r\n\r\n                // Body\r\n                bodyFontColor: tooltipOpts.bodyFontColor,\r\n                _bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\r\n                _bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\r\n                _bodyAlign: tooltipOpts.bodyAlign,\r\n                bodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\r\n                bodySpacing: tooltipOpts.bodySpacing,\r\n\r\n                // Title\r\n                titleFontColor: tooltipOpts.titleFontColor,\r\n                _titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\r\n                _titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\r\n                titleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\r\n                _titleAlign: tooltipOpts.titleAlign,\r\n                titleSpacing: tooltipOpts.titleSpacing,\r\n                titleMarginBottom: tooltipOpts.titleMarginBottom,\r\n\r\n                // Footer\r\n                footerFontColor: tooltipOpts.footerFontColor,\r\n                _footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\r\n                _footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\r\n                footerFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\r\n                _footerAlign: tooltipOpts.footerAlign,\r\n                footerSpacing: tooltipOpts.footerSpacing,\r\n                footerMarginTop: tooltipOpts.footerMarginTop,\r\n\r\n                // Appearance\r\n                caretSize: tooltipOpts.caretSize,\r\n                cornerRadius: tooltipOpts.cornerRadius,\r\n                backgroundColor: tooltipOpts.backgroundColor,\r\n                opacity: 0,\r\n                legendColorBackground: tooltipOpts.multiKeyBackground,\r\n                displayColors: tooltipOpts.displayColors\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Get the size of the tooltip\r\n         */\r\n        function getTooltipSize(tooltip, model) {\r\n            var ctx = tooltip._chart.ctx;\r\n\r\n            var height = model.yPadding * 2; // Tooltip Padding\r\n            var width = 0;\r\n\r\n            // Count of all lines in the body\r\n            var body = model.body;\r\n            var combinedBodyLength = body.reduce(function(count, bodyItem) {\r\n                return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\r\n            }, 0);\r\n            combinedBodyLength += model.beforeBody.length + model.afterBody.length;\r\n\r\n            var titleLineCount = model.title.length;\r\n            var footerLineCount = model.footer.length;\r\n            var titleFontSize = model.titleFontSize,\r\n                bodyFontSize = model.bodyFontSize,\r\n                footerFontSize = model.footerFontSize;\r\n\r\n            height += titleLineCount * titleFontSize; // Title Lines\r\n            height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\r\n            height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\r\n            height += combinedBodyLength * bodyFontSize; // Body Lines\r\n            height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\r\n            height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\r\n            height += footerLineCount * (footerFontSize); // Footer Lines\r\n            height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\r\n\r\n            // Title width\r\n            var widthPadding = 0;\r\n            var maxLineWidth = function(line) {\r\n                width = Math.max(width, ctx.measureText(line).width + widthPadding);\r\n            };\r\n\r\n            ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\r\n            helpers.each(model.title, maxLineWidth);\r\n\r\n            // Body width\r\n            ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\r\n            helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\r\n\r\n            // Body lines may include some extra width due to the color box\r\n            widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\r\n            helpers.each(body, function(bodyItem) {\r\n                helpers.each(bodyItem.before, maxLineWidth);\r\n                helpers.each(bodyItem.lines, maxLineWidth);\r\n                helpers.each(bodyItem.after, maxLineWidth);\r\n            });\r\n\r\n            // Reset back to 0\r\n            widthPadding = 0;\r\n\r\n            // Footer width\r\n            ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\r\n            helpers.each(model.footer, maxLineWidth);\r\n\r\n            // Add padding\r\n            width += 2 * model.xPadding;\r\n\r\n            return {\r\n                width: width,\r\n                height: height\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Helper to get the alignment of a tooltip given the size\r\n         */\r\n        function determineAlignment(tooltip, size) {\r\n            var model = tooltip._model;\r\n            var chart = tooltip._chart;\r\n            var chartArea = tooltip._chartInstance.chartArea;\r\n            var xAlign = 'center';\r\n            var yAlign = 'center';\r\n\r\n            if (model.y < size.height) {\r\n                yAlign = 'top';\r\n            } else if (model.y > (chart.height - size.height)) {\r\n                yAlign = 'bottom';\r\n            }\r\n\r\n            var lf, rf; // functions to determine left, right alignment\r\n            var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\r\n            var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\r\n            var midX = (chartArea.left + chartArea.right) / 2;\r\n            var midY = (chartArea.top + chartArea.bottom) / 2;\r\n\r\n            if (yAlign === 'center') {\r\n                lf = function(x) {\r\n                    return x <= midX;\r\n                };\r\n                rf = function(x) {\r\n                    return x > midX;\r\n                };\r\n            } else {\r\n                lf = function(x) {\r\n                    return x <= (size.width / 2);\r\n                };\r\n                rf = function(x) {\r\n                    return x >= (chart.width - (size.width / 2));\r\n                };\r\n            }\r\n\r\n            olf = function(x) {\r\n                return x + size.width > chart.width;\r\n            };\r\n            orf = function(x) {\r\n                return x - size.width < 0;\r\n            };\r\n            yf = function(y) {\r\n                return y <= midY ? 'top' : 'bottom';\r\n            };\r\n\r\n            if (lf(model.x)) {\r\n                xAlign = 'left';\r\n\r\n                // Is tooltip too wide and goes over the right side of the chart.?\r\n                if (olf(model.x)) {\r\n                    xAlign = 'center';\r\n                    yAlign = yf(model.y);\r\n                }\r\n            } else if (rf(model.x)) {\r\n                xAlign = 'right';\r\n\r\n                // Is tooltip too wide and goes outside left edge of canvas?\r\n                if (orf(model.x)) {\r\n                    xAlign = 'center';\r\n                    yAlign = yf(model.y);\r\n                }\r\n            }\r\n\r\n            var opts = tooltip._options;\r\n            return {\r\n                xAlign: opts.xAlign ? opts.xAlign : xAlign,\r\n                yAlign: opts.yAlign ? opts.yAlign : yAlign\r\n            };\r\n        }\r\n\r\n        /**\r\n         * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\r\n         */\r\n        function getBackgroundPoint(vm, size, alignment) {\r\n            // Background Position\r\n            var x = vm.x;\r\n            var y = vm.y;\r\n\r\n            var caretSize = vm.caretSize,\r\n                caretPadding = vm.caretPadding,\r\n                cornerRadius = vm.cornerRadius,\r\n                xAlign = alignment.xAlign,\r\n                yAlign = alignment.yAlign,\r\n                paddingAndSize = caretSize + caretPadding,\r\n                radiusAndPadding = cornerRadius + caretPadding;\r\n\r\n            if (xAlign === 'right') {\r\n                x -= size.width;\r\n            } else if (xAlign === 'center') {\r\n                x -= (size.width / 2);\r\n            }\r\n\r\n            if (yAlign === 'top') {\r\n                y += paddingAndSize;\r\n            } else if (yAlign === 'bottom') {\r\n                y -= size.height + paddingAndSize;\r\n            } else {\r\n                y -= (size.height / 2);\r\n            }\r\n\r\n            if (yAlign === 'center') {\r\n                if (xAlign === 'left') {\r\n                    x += paddingAndSize;\r\n                } else if (xAlign === 'right') {\r\n                    x -= paddingAndSize;\r\n                }\r\n            } else if (xAlign === 'left') {\r\n                x -= radiusAndPadding;\r\n            } else if (xAlign === 'right') {\r\n                x += radiusAndPadding;\r\n            }\r\n\r\n            return {\r\n                x: x,\r\n                y: y\r\n            };\r\n        }\r\n\r\n        Chart.Tooltip = Chart.Element.extend({\r\n            initialize: function() {\r\n                this._model = getBaseModel(this._options);\r\n            },\r\n\r\n            // Get the title\r\n            // Args are: (tooltipItem, data)\r\n            getTitle: function() {\r\n                var me = this;\r\n                var opts = me._options;\r\n                var callbacks = opts.callbacks;\r\n\r\n                var beforeTitle = callbacks.beforeTitle.apply(me, arguments),\r\n                    title = callbacks.title.apply(me, arguments),\r\n                    afterTitle = callbacks.afterTitle.apply(me, arguments);\r\n\r\n                var lines = [];\r\n                lines = pushOrConcat(lines, beforeTitle);\r\n                lines = pushOrConcat(lines, title);\r\n                lines = pushOrConcat(lines, afterTitle);\r\n\r\n                return lines;\r\n            },\r\n\r\n            // Args are: (tooltipItem, data)\r\n            getBeforeBody: function() {\r\n                var lines = this._options.callbacks.beforeBody.apply(this, arguments);\r\n                return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\r\n            },\r\n\r\n            // Args are: (tooltipItem, data)\r\n            getBody: function(tooltipItems, data) {\r\n                var me = this;\r\n                var callbacks = me._options.callbacks;\r\n                var bodyItems = [];\r\n\r\n                helpers.each(tooltipItems, function(tooltipItem) {\r\n                    var bodyItem = {\r\n                        before: [],\r\n                        lines: [],\r\n                        after: []\r\n                    };\r\n                    pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\r\n                    pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\r\n                    pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\r\n\r\n                    bodyItems.push(bodyItem);\r\n                });\r\n\r\n                return bodyItems;\r\n            },\r\n\r\n            // Args are: (tooltipItem, data)\r\n            getAfterBody: function() {\r\n                var lines = this._options.callbacks.afterBody.apply(this, arguments);\r\n                return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\r\n            },\r\n\r\n            // Get the footer and beforeFooter and afterFooter lines\r\n            // Args are: (tooltipItem, data)\r\n            getFooter: function() {\r\n                var me = this;\r\n                var callbacks = me._options.callbacks;\r\n\r\n                var beforeFooter = callbacks.beforeFooter.apply(me, arguments);\r\n                var footer = callbacks.footer.apply(me, arguments);\r\n                var afterFooter = callbacks.afterFooter.apply(me, arguments);\r\n\r\n                var lines = [];\r\n                lines = pushOrConcat(lines, beforeFooter);\r\n                lines = pushOrConcat(lines, footer);\r\n                lines = pushOrConcat(lines, afterFooter);\r\n\r\n                return lines;\r\n            },\r\n\r\n            update: function(changed) {\r\n                var me = this;\r\n                var opts = me._options;\r\n\r\n                // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\r\n                // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\r\n                // which breaks any animations.\r\n                var existingModel = me._model;\r\n                var model = me._model = getBaseModel(opts);\r\n                var active = me._active;\r\n\r\n                var data = me._data;\r\n                var chartInstance = me._chartInstance;\r\n\r\n                // In the case where active.length === 0 we need to keep these at existing values for good animations\r\n                var alignment = {\r\n                    xAlign: existingModel.xAlign,\r\n                    yAlign: existingModel.yAlign\r\n                };\r\n                var backgroundPoint = {\r\n                    x: existingModel.x,\r\n                    y: existingModel.y\r\n                };\r\n                var tooltipSize = {\r\n                    width: existingModel.width,\r\n                    height: existingModel.height\r\n                };\r\n                var tooltipPosition = {\r\n                    x: existingModel.caretX,\r\n                    y: existingModel.caretY\r\n                };\r\n\r\n                var i, len;\r\n\r\n                if (active.length) {\r\n                    model.opacity = 1;\r\n\r\n                    var labelColors = [];\r\n                    tooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);\r\n\r\n                    var tooltipItems = [];\r\n                    for (i = 0, len = active.length; i < len; ++i) {\r\n                        tooltipItems.push(createTooltipItem(active[i]));\r\n                    }\r\n\r\n                    // If the user provided a filter function, use it to modify the tooltip items\r\n                    if (opts.filter) {\r\n                        tooltipItems = tooltipItems.filter(function(a) {\r\n                            return opts.filter(a, data);\r\n                        });\r\n                    }\r\n\r\n                    // If the user provided a sorting function, use it to modify the tooltip items\r\n                    if (opts.itemSort) {\r\n                        tooltipItems = tooltipItems.sort(function(a, b) {\r\n                            return opts.itemSort(a, b, data);\r\n                        });\r\n                    }\r\n\r\n                    // Determine colors for boxes\r\n                    helpers.each(tooltipItems, function(tooltipItem) {\r\n                        labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, chartInstance));\r\n                    });\r\n\r\n                    // Build the Text Lines\r\n                    model.title = me.getTitle(tooltipItems, data);\r\n                    model.beforeBody = me.getBeforeBody(tooltipItems, data);\r\n                    model.body = me.getBody(tooltipItems, data);\r\n                    model.afterBody = me.getAfterBody(tooltipItems, data);\r\n                    model.footer = me.getFooter(tooltipItems, data);\r\n\r\n                    // Initial positioning and colors\r\n                    model.x = Math.round(tooltipPosition.x);\r\n                    model.y = Math.round(tooltipPosition.y);\r\n                    model.caretPadding = helpers.getValueOrDefault(tooltipPosition.padding, 2);\r\n                    model.labelColors = labelColors;\r\n\r\n                    // data points\r\n                    model.dataPoints = tooltipItems;\r\n\r\n                    // We need to determine alignment of the tooltip\r\n                    tooltipSize = getTooltipSize(this, model);\r\n                    alignment = determineAlignment(this, tooltipSize);\r\n                    // Final Size and Position\r\n                    backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);\r\n                } else {\r\n                    model.opacity = 0;\r\n                }\r\n\r\n                model.xAlign = alignment.xAlign;\r\n                model.yAlign = alignment.yAlign;\r\n                model.x = backgroundPoint.x;\r\n                model.y = backgroundPoint.y;\r\n                model.width = tooltipSize.width;\r\n                model.height = tooltipSize.height;\r\n\r\n                // Point where the caret on the tooltip points to\r\n                model.caretX = tooltipPosition.x;\r\n                model.caretY = tooltipPosition.y;\r\n\r\n                me._model = model;\r\n\r\n                if (changed && opts.custom) {\r\n                    opts.custom.call(me, model);\r\n                }\r\n\r\n                return me;\r\n            },\r\n            drawCaret: function(tooltipPoint, size, opacity) {\r\n                var vm = this._view;\r\n                var ctx = this._chart.ctx;\r\n                var x1, x2, x3;\r\n                var y1, y2, y3;\r\n                var caretSize = vm.caretSize;\r\n                var cornerRadius = vm.cornerRadius;\r\n                var xAlign = vm.xAlign,\r\n                    yAlign = vm.yAlign;\r\n                var ptX = tooltipPoint.x,\r\n                    ptY = tooltipPoint.y;\r\n                var width = size.width,\r\n                    height = size.height;\r\n\r\n                if (yAlign === 'center') {\r\n                    // Left or right side\r\n                    if (xAlign === 'left') {\r\n                        x1 = ptX;\r\n                        x2 = x1 - caretSize;\r\n                        x3 = x1;\r\n                    } else {\r\n                        x1 = ptX + width;\r\n                        x2 = x1 + caretSize;\r\n                        x3 = x1;\r\n                    }\r\n\r\n                    y2 = ptY + (height / 2);\r\n                    y1 = y2 - caretSize;\r\n                    y3 = y2 + caretSize;\r\n                } else {\r\n                    if (xAlign === 'left') {\r\n                        x1 = ptX + cornerRadius;\r\n                        x2 = x1 + caretSize;\r\n                        x3 = x2 + caretSize;\r\n                    } else if (xAlign === 'right') {\r\n                        x1 = ptX + width - cornerRadius;\r\n                        x2 = x1 - caretSize;\r\n                        x3 = x2 - caretSize;\r\n                    } else {\r\n                        x2 = ptX + (width / 2);\r\n                        x1 = x2 - caretSize;\r\n                        x3 = x2 + caretSize;\r\n                    }\r\n\r\n                    if (yAlign === 'top') {\r\n                        y1 = ptY;\r\n                        y2 = y1 - caretSize;\r\n                        y3 = y1;\r\n                    } else {\r\n                        y1 = ptY + height;\r\n                        y2 = y1 + caretSize;\r\n                        y3 = y1;\r\n                    }\r\n                }\r\n\r\n                ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\r\n                ctx.beginPath();\r\n                ctx.moveTo(x1, y1);\r\n                ctx.lineTo(x2, y2);\r\n                ctx.lineTo(x3, y3);\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            },\r\n            drawTitle: function(pt, vm, ctx, opacity) {\r\n                var title = vm.title;\r\n\r\n                if (title.length) {\r\n                    ctx.textAlign = vm._titleAlign;\r\n                    ctx.textBaseline = 'top';\r\n\r\n                    var titleFontSize = vm.titleFontSize,\r\n                        titleSpacing = vm.titleSpacing;\r\n\r\n                    ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\r\n                    ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\r\n\r\n                    var i, len;\r\n                    for (i = 0, len = title.length; i < len; ++i) {\r\n                        ctx.fillText(title[i], pt.x, pt.y);\r\n                        pt.y += titleFontSize + titleSpacing; // Line Height and spacing\r\n\r\n                        if (i + 1 === title.length) {\r\n                            pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            drawBody: function(pt, vm, ctx, opacity) {\r\n                var bodyFontSize = vm.bodyFontSize;\r\n                var bodySpacing = vm.bodySpacing;\r\n                var body = vm.body;\r\n\r\n                ctx.textAlign = vm._bodyAlign;\r\n                ctx.textBaseline = 'top';\r\n\r\n                var textColor = mergeOpacity(vm.bodyFontColor, opacity);\r\n                ctx.fillStyle = textColor;\r\n                ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\r\n\r\n                // Before Body\r\n                var xLinePadding = 0;\r\n                var fillLineOfText = function(line) {\r\n                    ctx.fillText(line, pt.x + xLinePadding, pt.y);\r\n                    pt.y += bodyFontSize + bodySpacing;\r\n                };\r\n\r\n                // Before body lines\r\n                helpers.each(vm.beforeBody, fillLineOfText);\r\n\r\n                var drawColorBoxes = vm.displayColors;\r\n                xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\r\n\r\n                // Draw body lines now\r\n                helpers.each(body, function(bodyItem, i) {\r\n                    helpers.each(bodyItem.before, fillLineOfText);\r\n\r\n                    helpers.each(bodyItem.lines, function(line) {\r\n                        // Draw Legend-like boxes if needed\r\n                        if (drawColorBoxes) {\r\n                            // Fill a white rect so that colours merge nicely if the opacity is < 1\r\n                            ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\r\n                            ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\r\n\r\n                            // Border\r\n                            ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\r\n                            ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\r\n\r\n                            // Inner square\r\n                            ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\r\n                            ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\r\n\r\n                            ctx.fillStyle = textColor;\r\n                        }\r\n\r\n                        fillLineOfText(line);\r\n                    });\r\n\r\n                    helpers.each(bodyItem.after, fillLineOfText);\r\n                });\r\n\r\n                // Reset back to 0 for after body\r\n                xLinePadding = 0;\r\n\r\n                // After body lines\r\n                helpers.each(vm.afterBody, fillLineOfText);\r\n                pt.y -= bodySpacing; // Remove last body spacing\r\n            },\r\n            drawFooter: function(pt, vm, ctx, opacity) {\r\n                var footer = vm.footer;\r\n\r\n                if (footer.length) {\r\n                    pt.y += vm.footerMarginTop;\r\n\r\n                    ctx.textAlign = vm._footerAlign;\r\n                    ctx.textBaseline = 'top';\r\n\r\n                    ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\r\n                    ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\r\n\r\n                    helpers.each(footer, function(line) {\r\n                        ctx.fillText(line, pt.x, pt.y);\r\n                        pt.y += vm.footerFontSize + vm.footerSpacing;\r\n                    });\r\n                }\r\n            },\r\n            drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\r\n                ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\r\n                helpers.drawRoundedRectangle(ctx, pt.x, pt.y, tooltipSize.width, tooltipSize.height, vm.cornerRadius);\r\n                ctx.fill();\r\n            },\r\n            draw: function() {\r\n                var ctx = this._chart.ctx;\r\n                var vm = this._view;\r\n\r\n                if (vm.opacity === 0) {\r\n                    return;\r\n                }\r\n\r\n                var tooltipSize = {\r\n                    width: vm.width,\r\n                    height: vm.height\r\n                };\r\n                var pt = {\r\n                    x: vm.x,\r\n                    y: vm.y\r\n                };\r\n\r\n                // IE11/Edge does not like very small opacities, so snap to 0\r\n                var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\r\n\r\n                if (this._options.enabled) {\r\n                    // Draw Background\r\n                    this.drawBackground(pt, vm, ctx, tooltipSize, opacity);\r\n\r\n                    // Draw Caret\r\n                    this.drawCaret(pt, tooltipSize, opacity);\r\n\r\n                    // Draw Title, Body, and Footer\r\n                    pt.x += vm.xPadding;\r\n                    pt.y += vm.yPadding;\r\n\r\n                    // Titles\r\n                    this.drawTitle(pt, vm, ctx, opacity);\r\n\r\n                    // Body\r\n                    this.drawBody(pt, vm, ctx, opacity);\r\n\r\n                    // Footer\r\n                    this.drawFooter(pt, vm, ctx, opacity);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Handle an event\r\n             * @private\r\n             * @param e {Event} the event to handle\r\n             * @returns {Boolean} true if the tooltip changed\r\n             */\r\n            handleEvent: function(e) {\r\n                var me = this;\r\n                var options = me._options;\r\n                var changed = false;\r\n\r\n                me._lastActive = me._lastActive || [];\r\n\r\n                // Find Active Elements for tooltips\r\n                if (e.type === 'mouseout') {\r\n                    me._active = [];\r\n                } else {\r\n                    me._active = me._chartInstance.getElementsAtEventForMode(e, options.mode, options);\r\n                }\r\n\r\n                // Remember Last Actives\r\n                changed = !helpers.arrayEquals(me._active, me._lastActive);\r\n                me._lastActive = me._active;\r\n\r\n                if (options.enabled || options.custom) {\r\n                    me._eventPosition = helpers.getRelativePosition(e, me._chart);\r\n\r\n                    var model = me._model;\r\n                    me.update(true);\r\n                    me.pivot();\r\n\r\n                    // See if our tooltip position changed\r\n                    changed |= (model.x !== me._model.x) || (model.y !== me._model.y);\r\n                }\r\n\r\n                return changed;\r\n            }\r\n        });\r\n\r\n        /**\r\n         * @namespace Chart.Tooltip.positioners\r\n         */\r\n        Chart.Tooltip.positioners = {\r\n            /**\r\n             * Average mode places the tooltip at the average position of the elements shown\r\n             * @function Chart.Tooltip.positioners.average\r\n             * @param elements {ChartElement[]} the elements being displayed in the tooltip\r\n             * @returns {Point} tooltip position\r\n             */\r\n            average: function(elements) {\r\n                if (!elements.length) {\r\n                    return false;\r\n                }\r\n\r\n                var i, len;\r\n                var x = 0;\r\n                var y = 0;\r\n                var count = 0;\r\n\r\n                for (i = 0, len = elements.length; i < len; ++i) {\r\n                    var el = elements[i];\r\n                    if (el && el.hasValue()) {\r\n                        var pos = el.tooltipPosition();\r\n                        x += pos.x;\r\n                        y += pos.y;\r\n                        ++count;\r\n                    }\r\n                }\r\n\r\n                return {\r\n                    x: Math.round(x / count),\r\n                    y: Math.round(y / count)\r\n                };\r\n            },\r\n\r\n            /**\r\n             * Gets the tooltip position nearest of the item nearest to the event position\r\n             * @function Chart.Tooltip.positioners.nearest\r\n             * @param elements {Chart.Element[]} the tooltip elements\r\n             * @param eventPosition {Point} the position of the event in canvas coordinates\r\n             * @returns {Point} the tooltip position\r\n             */\r\n            nearest: function(elements, eventPosition) {\r\n                var x = eventPosition.x;\r\n                var y = eventPosition.y;\r\n\r\n                var nearestElement;\r\n                var minDistance = Number.POSITIVE_INFINITY;\r\n                var i, len;\r\n                for (i = 0, len = elements.length; i < len; ++i) {\r\n                    var el = elements[i];\r\n                    if (el && el.hasValue()) {\r\n                        var center = el.getCenterPoint();\r\n                        var d = helpers.distanceBetweenPoints(eventPosition, center);\r\n\r\n                        if (d < minDistance) {\r\n                            minDistance = d;\r\n                            nearestElement = el;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (nearestElement) {\r\n                    var tp = nearestElement.tooltipPosition();\r\n                    x = tp.x;\r\n                    y = tp.y;\r\n                }\r\n\r\n                return {\r\n                    x: x,\r\n                    y: y\r\n                };\r\n            }\r\n        };\r\n    };\r\n\r\n},{}],37:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers,\r\n            globalOpts = Chart.defaults.global;\r\n\r\n        globalOpts.elements.arc = {\r\n            backgroundColor: globalOpts.defaultColor,\r\n            borderColor: '#fff',\r\n            borderWidth: 2\r\n        };\r\n\r\n        Chart.elements.Arc = Chart.Element.extend({\r\n            inLabelRange: function(mouseX) {\r\n                var vm = this._view;\r\n\r\n                if (vm) {\r\n                    return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\r\n                }\r\n                return false;\r\n            },\r\n            inRange: function(chartX, chartY) {\r\n                var vm = this._view;\r\n\r\n                if (vm) {\r\n                    var pointRelativePosition = helpers.getAngleFromPoint(vm, {\r\n                            x: chartX,\r\n                            y: chartY\r\n                        }),\r\n                        angle = pointRelativePosition.angle,\r\n                        distance = pointRelativePosition.distance;\r\n\r\n                    // Sanitise angle range\r\n                    var startAngle = vm.startAngle;\r\n                    var endAngle = vm.endAngle;\r\n                    while (endAngle < startAngle) {\r\n                        endAngle += 2.0 * Math.PI;\r\n                    }\r\n                    while (angle > endAngle) {\r\n                        angle -= 2.0 * Math.PI;\r\n                    }\r\n                    while (angle < startAngle) {\r\n                        angle += 2.0 * Math.PI;\r\n                    }\r\n\r\n                    // Check if within the range of the open/close angle\r\n                    var betweenAngles = (angle >= startAngle && angle <= endAngle),\r\n                        withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\r\n\r\n                    return (betweenAngles && withinRadius);\r\n                }\r\n                return false;\r\n            },\r\n            getCenterPoint: function() {\r\n                var vm = this._view;\r\n                var halfAngle = (vm.startAngle + vm.endAngle) / 2;\r\n                var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\r\n                return {\r\n                    x: vm.x + Math.cos(halfAngle) * halfRadius,\r\n                    y: vm.y + Math.sin(halfAngle) * halfRadius\r\n                };\r\n            },\r\n            getArea: function() {\r\n                var vm = this._view;\r\n                return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\r\n            },\r\n            tooltipPosition: function() {\r\n                var vm = this._view;\r\n\r\n                var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),\r\n                    rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\r\n                return {\r\n                    x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\r\n                    y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\r\n                };\r\n            },\r\n            draw: function() {\r\n\r\n                var ctx = this._chart.ctx,\r\n                    vm = this._view,\r\n                    sA = vm.startAngle,\r\n                    eA = vm.endAngle;\r\n\r\n                ctx.beginPath();\r\n\r\n                ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\r\n                ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\r\n\r\n                ctx.closePath();\r\n                ctx.strokeStyle = vm.borderColor;\r\n                ctx.lineWidth = vm.borderWidth;\r\n\r\n                ctx.fillStyle = vm.backgroundColor;\r\n\r\n                ctx.fill();\r\n                ctx.lineJoin = 'bevel';\r\n\r\n                if (vm.borderWidth) {\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],38:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n        var globalDefaults = Chart.defaults.global;\r\n\r\n        Chart.defaults.global.elements.line = {\r\n            tension: 0.4,\r\n            backgroundColor: globalDefaults.defaultColor,\r\n            borderWidth: 3,\r\n            borderColor: globalDefaults.defaultColor,\r\n            borderCapStyle: 'butt',\r\n            borderDash: [],\r\n            borderDashOffset: 0.0,\r\n            borderJoinStyle: 'miter',\r\n            capBezierPoints: true,\r\n            fill: true, // do we fill in the area between the line and its base axis\r\n        };\r\n\r\n        Chart.elements.Line = Chart.Element.extend({\r\n            draw: function() {\r\n                var me = this;\r\n                var vm = me._view;\r\n                var spanGaps = vm.spanGaps;\r\n                var fillPoint = vm.scaleZero;\r\n                var loop = me._loop;\r\n\r\n                // Handle different fill modes for cartesian lines\r\n                if (!loop) {\r\n                    if (vm.fill === 'top') {\r\n                        fillPoint = vm.scaleTop;\r\n                    } else if (vm.fill === 'bottom') {\r\n                        fillPoint = vm.scaleBottom;\r\n                    }\r\n                }\r\n\r\n                var ctx = me._chart.ctx;\r\n                ctx.save();\r\n\r\n                // Helper function to draw a line to a point\r\n                function lineToPoint(previousPoint, point) {\r\n                    var pointVM = point._view;\r\n                    if (point._view.steppedLine === true) {\r\n                        ctx.lineTo(pointVM.x, previousPoint._view.y);\r\n                        ctx.lineTo(pointVM.x, pointVM.y);\r\n                    } else if (point._view.tension === 0) {\r\n                        ctx.lineTo(pointVM.x, pointVM.y);\r\n                    } else {\r\n                        ctx.bezierCurveTo(\r\n                            previousPoint._view.controlPointNextX,\r\n                            previousPoint._view.controlPointNextY,\r\n                            pointVM.controlPointPreviousX,\r\n                            pointVM.controlPointPreviousY,\r\n                            pointVM.x,\r\n                            pointVM.y\r\n                        );\r\n                    }\r\n                }\r\n\r\n                var points = me._children.slice(); // clone array\r\n                var lastDrawnIndex = -1;\r\n\r\n                // If we are looping, adding the first point again\r\n                if (loop && points.length) {\r\n                    points.push(points[0]);\r\n                }\r\n\r\n                var index, current, previous, currentVM;\r\n\r\n                // Fill Line\r\n                if (points.length && vm.fill) {\r\n                    ctx.beginPath();\r\n\r\n                    for (index = 0; index < points.length; ++index) {\r\n                        current = points[index];\r\n                        previous = helpers.previousItem(points, index);\r\n                        currentVM = current._view;\r\n\r\n                        // First point moves to it's starting position no matter what\r\n                        if (index === 0) {\r\n                            if (loop) {\r\n                                ctx.moveTo(fillPoint.x, fillPoint.y);\r\n                            } else {\r\n                                ctx.moveTo(currentVM.x, fillPoint);\r\n                            }\r\n\r\n                            if (!currentVM.skip) {\r\n                                lastDrawnIndex = index;\r\n                                ctx.lineTo(currentVM.x, currentVM.y);\r\n                            }\r\n                        } else {\r\n                            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\r\n\r\n                            if (currentVM.skip) {\r\n                                // Only do this if this is the first point that is skipped\r\n                                if (!spanGaps && lastDrawnIndex === (index - 1)) {\r\n                                    if (loop) {\r\n                                        ctx.lineTo(fillPoint.x, fillPoint.y);\r\n                                    } else {\r\n                                        ctx.lineTo(previous._view.x, fillPoint);\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                if (lastDrawnIndex !== (index - 1)) {\r\n                                    // There was a gap and this is the first point after the gap. If we've never drawn a point, this is a special case.\r\n                                    // If the first data point is NaN, then there is no real gap to skip\r\n                                    if (spanGaps && lastDrawnIndex !== -1) {\r\n                                        // We are spanning the gap, so simple draw a line to this point\r\n                                        lineToPoint(previous, current);\r\n                                    } else if (loop) {\r\n                                        ctx.lineTo(currentVM.x, currentVM.y);\r\n                                    } else {\r\n                                        ctx.lineTo(currentVM.x, fillPoint);\r\n                                        ctx.lineTo(currentVM.x, currentVM.y);\r\n                                    }\r\n                                } else {\r\n                                    // Line to next point\r\n                                    lineToPoint(previous, current);\r\n                                }\r\n                                lastDrawnIndex = index;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (!loop && lastDrawnIndex !== -1) {\r\n                        ctx.lineTo(points[lastDrawnIndex]._view.x, fillPoint);\r\n                    }\r\n\r\n                    ctx.fillStyle = vm.backgroundColor || globalDefaults.defaultColor;\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                }\r\n\r\n                // Stroke Line Options\r\n                var globalOptionLineElements = globalDefaults.elements.line;\r\n                ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\r\n\r\n                // IE 9 and 10 do not support line dash\r\n                if (ctx.setLineDash) {\r\n                    ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\r\n                }\r\n\r\n                ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\r\n                ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\r\n                ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\r\n                ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\r\n\r\n                // Stroke Line\r\n                ctx.beginPath();\r\n                lastDrawnIndex = -1;\r\n\r\n                for (index = 0; index < points.length; ++index) {\r\n                    current = points[index];\r\n                    previous = helpers.previousItem(points, index);\r\n                    currentVM = current._view;\r\n\r\n                    // First point moves to it's starting position no matter what\r\n                    if (index === 0) {\r\n                        if (!currentVM.skip) {\r\n                            ctx.moveTo(currentVM.x, currentVM.y);\r\n                            lastDrawnIndex = index;\r\n                        }\r\n                    } else {\r\n                        previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\r\n\r\n                        if (!currentVM.skip) {\r\n                            if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\r\n                                // There was a gap and this is the first point after the gap\r\n                                ctx.moveTo(currentVM.x, currentVM.y);\r\n                            } else {\r\n                                // Line to next point\r\n                                lineToPoint(previous, current);\r\n                            }\r\n                            lastDrawnIndex = index;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                ctx.stroke();\r\n                ctx.restore();\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],39:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers,\r\n            globalOpts = Chart.defaults.global,\r\n            defaultColor = globalOpts.defaultColor;\r\n\r\n        globalOpts.elements.point = {\r\n            radius: 3,\r\n            pointStyle: 'circle',\r\n            backgroundColor: defaultColor,\r\n            borderWidth: 1,\r\n            borderColor: defaultColor,\r\n            // Hover\r\n            hitRadius: 1,\r\n            hoverRadius: 4,\r\n            hoverBorderWidth: 1\r\n        };\r\n\r\n        function xRange(mouseX) {\r\n            var vm = this._view;\r\n            return vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\r\n        }\r\n\r\n        function yRange(mouseY) {\r\n            var vm = this._view;\r\n            return vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\r\n        }\r\n\r\n        Chart.elements.Point = Chart.Element.extend({\r\n            inRange: function(mouseX, mouseY) {\r\n                var vm = this._view;\r\n                return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\r\n            },\r\n\r\n            inLabelRange: xRange,\r\n            inXRange: xRange,\r\n            inYRange: yRange,\r\n\r\n            getCenterPoint: function() {\r\n                var vm = this._view;\r\n                return {\r\n                    x: vm.x,\r\n                    y: vm.y\r\n                };\r\n            },\r\n            getArea: function() {\r\n                return Math.PI * Math.pow(this._view.radius, 2);\r\n            },\r\n            tooltipPosition: function() {\r\n                var vm = this._view;\r\n                return {\r\n                    x: vm.x,\r\n                    y: vm.y,\r\n                    padding: vm.radius + vm.borderWidth\r\n                };\r\n            },\r\n            draw: function() {\r\n                var vm = this._view;\r\n                var ctx = this._chart.ctx;\r\n                var pointStyle = vm.pointStyle;\r\n                var radius = vm.radius;\r\n                var x = vm.x;\r\n                var y = vm.y;\r\n\r\n                if (vm.skip) {\r\n                    return;\r\n                }\r\n\r\n                ctx.strokeStyle = vm.borderColor || defaultColor;\r\n                ctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);\r\n                ctx.fillStyle = vm.backgroundColor || defaultColor;\r\n\r\n                Chart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],40:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var globalOpts = Chart.defaults.global;\r\n\r\n        globalOpts.elements.rectangle = {\r\n            backgroundColor: globalOpts.defaultColor,\r\n            borderWidth: 0,\r\n            borderColor: globalOpts.defaultColor,\r\n            borderSkipped: 'bottom'\r\n        };\r\n\r\n        function isVertical(bar) {\r\n            return bar._view.width !== undefined;\r\n        }\r\n\r\n        /**\r\n         * Helper function to get the bounds of the bar regardless of the orientation\r\n         * @private\r\n         * @param bar {Chart.Element.Rectangle} the bar\r\n         * @return {Bounds} bounds of the bar\r\n         */\r\n        function getBarBounds(bar) {\r\n            var vm = bar._view;\r\n            var x1, x2, y1, y2;\r\n\r\n            if (isVertical(bar)) {\r\n                // vertical\r\n                var halfWidth = vm.width / 2;\r\n                x1 = vm.x - halfWidth;\r\n                x2 = vm.x + halfWidth;\r\n                y1 = Math.min(vm.y, vm.base);\r\n                y2 = Math.max(vm.y, vm.base);\r\n            } else {\r\n                // horizontal bar\r\n                var halfHeight = vm.height / 2;\r\n                x1 = Math.min(vm.x, vm.base);\r\n                x2 = Math.max(vm.x, vm.base);\r\n                y1 = vm.y - halfHeight;\r\n                y2 = vm.y + halfHeight;\r\n            }\r\n\r\n            return {\r\n                left: x1,\r\n                top: y1,\r\n                right: x2,\r\n                bottom: y2\r\n            };\r\n        }\r\n\r\n        Chart.elements.Rectangle = Chart.Element.extend({\r\n            draw: function() {\r\n                var ctx = this._chart.ctx;\r\n                var vm = this._view;\r\n\r\n                var halfWidth = vm.width / 2,\r\n                    leftX = vm.x - halfWidth,\r\n                    rightX = vm.x + halfWidth,\r\n                    top = vm.base - (vm.base - vm.y),\r\n                    halfStroke = vm.borderWidth / 2;\r\n\r\n                // Canvas doesn't allow us to stroke inside the width so we can\r\n                // adjust the sizes to fit if we're setting a stroke on the line\r\n                if (vm.borderWidth) {\r\n                    leftX += halfStroke;\r\n                    rightX -= halfStroke;\r\n                    top += halfStroke;\r\n                }\r\n\r\n                ctx.beginPath();\r\n                ctx.fillStyle = vm.backgroundColor;\r\n                ctx.strokeStyle = vm.borderColor;\r\n                ctx.lineWidth = vm.borderWidth;\r\n\r\n                // Corner points, from bottom-left to bottom-right clockwise\r\n                // | 1 2 |\r\n                // | 0 3 |\r\n                var corners = [\r\n                    [leftX, vm.base],\r\n                    [leftX, top],\r\n                    [rightX, top],\r\n                    [rightX, vm.base]\r\n                ];\r\n\r\n                // Find first (starting) corner with fallback to 'bottom'\r\n                var borders = ['bottom', 'left', 'top', 'right'];\r\n                var startCorner = borders.indexOf(vm.borderSkipped, 0);\r\n                if (startCorner === -1) {\r\n                    startCorner = 0;\r\n                }\r\n\r\n                function cornerAt(index) {\r\n                    return corners[(startCorner + index) % 4];\r\n                }\r\n\r\n                // Draw rectangle from 'startCorner'\r\n                var corner = cornerAt(0);\r\n                ctx.moveTo(corner[0], corner[1]);\r\n\r\n                for (var i = 1; i < 4; i++) {\r\n                    corner = cornerAt(i);\r\n                    ctx.lineTo(corner[0], corner[1]);\r\n                }\r\n\r\n                ctx.fill();\r\n                if (vm.borderWidth) {\r\n                    ctx.stroke();\r\n                }\r\n            },\r\n            height: function() {\r\n                var vm = this._view;\r\n                return vm.base - vm.y;\r\n            },\r\n            inRange: function(mouseX, mouseY) {\r\n                var inRange = false;\r\n\r\n                if (this._view) {\r\n                    var bounds = getBarBounds(this);\r\n                    inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\r\n                }\r\n\r\n                return inRange;\r\n            },\r\n            inLabelRange: function(mouseX, mouseY) {\r\n                var me = this;\r\n                if (!me._view) {\r\n                    return false;\r\n                }\r\n\r\n                var inRange = false;\r\n                var bounds = getBarBounds(me);\r\n\r\n                if (isVertical(me)) {\r\n                    inRange = mouseX >= bounds.left && mouseX <= bounds.right;\r\n                } else {\r\n                    inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\r\n                }\r\n\r\n                return inRange;\r\n            },\r\n            inXRange: function(mouseX) {\r\n                var bounds = getBarBounds(this);\r\n                return mouseX >= bounds.left && mouseX <= bounds.right;\r\n            },\r\n            inYRange: function(mouseY) {\r\n                var bounds = getBarBounds(this);\r\n                return mouseY >= bounds.top && mouseY <= bounds.bottom;\r\n            },\r\n            getCenterPoint: function() {\r\n                var vm = this._view;\r\n                var x, y;\r\n                if (isVertical(this)) {\r\n                    x = vm.x;\r\n                    y = (vm.y + vm.base) / 2;\r\n                } else {\r\n                    x = (vm.x + vm.base) / 2;\r\n                    y = vm.y;\r\n                }\r\n\r\n                return {x: x, y: y};\r\n            },\r\n            getArea: function() {\r\n                var vm = this._view;\r\n                return vm.width * Math.abs(vm.y - vm.base);\r\n            },\r\n            tooltipPosition: function() {\r\n                var vm = this._view;\r\n                return {\r\n                    x: vm.x,\r\n                    y: vm.y\r\n                };\r\n            }\r\n        });\r\n\r\n    };\r\n\r\n},{}],41:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n        // Default config for a category scale\r\n        var defaultConfig = {\r\n            position: 'bottom'\r\n        };\r\n\r\n        var DatasetScale = Chart.Scale.extend({\r\n            /**\r\n             * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\r\n             * else fall back to data.labels\r\n             * @private\r\n             */\r\n            getLabels: function() {\r\n                var data = this.chart.data;\r\n                return (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\r\n            },\r\n            // Implement this so that\r\n            determineDataLimits: function() {\r\n                var me = this;\r\n                var labels = me.getLabels();\r\n                me.minIndex = 0;\r\n                me.maxIndex = labels.length - 1;\r\n                var findIndex;\r\n\r\n                if (me.options.ticks.min !== undefined) {\r\n                    // user specified min value\r\n                    findIndex = helpers.indexOf(labels, me.options.ticks.min);\r\n                    me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\r\n                }\r\n\r\n                if (me.options.ticks.max !== undefined) {\r\n                    // user specified max value\r\n                    findIndex = helpers.indexOf(labels, me.options.ticks.max);\r\n                    me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\r\n                }\r\n\r\n                me.min = labels[me.minIndex];\r\n                me.max = labels[me.maxIndex];\r\n            },\r\n\r\n            buildTicks: function() {\r\n                var me = this;\r\n                var labels = me.getLabels();\r\n                // If we are viewing some subset of labels, slice the original array\r\n                me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\r\n            },\r\n\r\n            getLabelForIndex: function(index, datasetIndex) {\r\n                var me = this;\r\n                var data = me.chart.data;\r\n                var isHorizontal = me.isHorizontal();\r\n\r\n                if ((data.xLabels && isHorizontal) || (data.yLabels && !isHorizontal)) {\r\n                    return me.getRightValue(data.datasets[datasetIndex].data[index]);\r\n                }\r\n                return me.ticks[index];\r\n            },\r\n\r\n            // Used to get data value locations.  Value can either be an index or a numerical value\r\n            getPixelForValue: function(value, index, datasetIndex, includeOffset) {\r\n                var me = this;\r\n                // 1 is added because we need the length but we have the indexes\r\n                var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\r\n\r\n                if (value !== undefined && isNaN(index)) {\r\n                    var labels = me.getLabels();\r\n                    var idx = labels.indexOf(value);\r\n                    index = idx !== -1 ? idx : index;\r\n                }\r\n\r\n                if (me.isHorizontal()) {\r\n                    var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\r\n                    var valueWidth = innerWidth / offsetAmt;\r\n                    var widthOffset = (valueWidth * (index - me.minIndex)) + me.paddingLeft;\r\n\r\n                    if (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\r\n                        widthOffset += (valueWidth / 2);\r\n                    }\r\n\r\n                    return me.left + Math.round(widthOffset);\r\n                }\r\n                var innerHeight = me.height - (me.paddingTop + me.paddingBottom);\r\n                var valueHeight = innerHeight / offsetAmt;\r\n                var heightOffset = (valueHeight * (index - me.minIndex)) + me.paddingTop;\r\n\r\n                if (me.options.gridLines.offsetGridLines && includeOffset) {\r\n                    heightOffset += (valueHeight / 2);\r\n                }\r\n\r\n                return me.top + Math.round(heightOffset);\r\n            },\r\n            getPixelForTick: function(index, includeOffset) {\r\n                return this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\r\n            },\r\n            getValueForPixel: function(pixel) {\r\n                var me = this;\r\n                var value;\r\n                var offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\r\n                var horz = me.isHorizontal();\r\n                var innerDimension = horz ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);\r\n                var valueDimension = innerDimension / offsetAmt;\r\n\r\n                pixel -= horz ? me.left : me.top;\r\n\r\n                if (me.options.gridLines.offsetGridLines) {\r\n                    pixel -= (valueDimension / 2);\r\n                }\r\n                pixel -= horz ? me.paddingLeft : me.paddingTop;\r\n\r\n                if (pixel <= 0) {\r\n                    value = 0;\r\n                } else {\r\n                    value = Math.round(pixel / valueDimension);\r\n                }\r\n\r\n                return value;\r\n            },\r\n            getBasePixel: function() {\r\n                return this.bottom;\r\n            }\r\n        });\r\n\r\n        Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\r\n\r\n    };\r\n\r\n},{}],42:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        var defaultConfig = {\r\n            position: 'left',\r\n            ticks: {\r\n                callback: Chart.Ticks.formatters.linear\r\n            }\r\n        };\r\n\r\n        var LinearScale = Chart.LinearScaleBase.extend({\r\n            determineDataLimits: function() {\r\n                var me = this;\r\n                var opts = me.options;\r\n                var chart = me.chart;\r\n                var data = chart.data;\r\n                var datasets = data.datasets;\r\n                var isHorizontal = me.isHorizontal();\r\n\r\n                function IDMatches(meta) {\r\n                    return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\r\n                }\r\n\r\n                // First Calculate the range\r\n                me.min = null;\r\n                me.max = null;\r\n\r\n                if (opts.stacked) {\r\n                    var valuesPerType = {};\r\n\r\n                    helpers.each(datasets, function(dataset, datasetIndex) {\r\n                        var meta = chart.getDatasetMeta(datasetIndex);\r\n                        if (valuesPerType[meta.type] === undefined) {\r\n                            valuesPerType[meta.type] = {\r\n                                positiveValues: [],\r\n                                negativeValues: []\r\n                            };\r\n                        }\r\n\r\n                        // Store these per type\r\n                        var positiveValues = valuesPerType[meta.type].positiveValues;\r\n                        var negativeValues = valuesPerType[meta.type].negativeValues;\r\n\r\n                        if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n                            helpers.each(dataset.data, function(rawValue, index) {\r\n                                var value = +me.getRightValue(rawValue);\r\n                                if (isNaN(value) || meta.data[index].hidden) {\r\n                                    return;\r\n                                }\r\n\r\n                                positiveValues[index] = positiveValues[index] || 0;\r\n                                negativeValues[index] = negativeValues[index] || 0;\r\n\r\n                                if (opts.relativePoints) {\r\n                                    positiveValues[index] = 100;\r\n                                } else if (value < 0) {\r\n                                    negativeValues[index] += value;\r\n                                } else {\r\n                                    positiveValues[index] += value;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n\r\n                    helpers.each(valuesPerType, function(valuesForType) {\r\n                        var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\r\n                        var minVal = helpers.min(values);\r\n                        var maxVal = helpers.max(values);\r\n                        me.min = me.min === null ? minVal : Math.min(me.min, minVal);\r\n                        me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\r\n                    });\r\n\r\n                } else {\r\n                    helpers.each(datasets, function(dataset, datasetIndex) {\r\n                        var meta = chart.getDatasetMeta(datasetIndex);\r\n                        if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n                            helpers.each(dataset.data, function(rawValue, index) {\r\n                                var value = +me.getRightValue(rawValue);\r\n                                if (isNaN(value) || meta.data[index].hidden) {\r\n                                    return;\r\n                                }\r\n\r\n                                if (me.min === null) {\r\n                                    me.min = value;\r\n                                } else if (value < me.min) {\r\n                                    me.min = value;\r\n                                }\r\n\r\n                                if (me.max === null) {\r\n                                    me.max = value;\r\n                                } else if (value > me.max) {\r\n                                    me.max = value;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\r\n                this.handleTickRangeOptions();\r\n            },\r\n            getTickLimit: function() {\r\n                var maxTicks;\r\n                var me = this;\r\n                var tickOpts = me.options.ticks;\r\n\r\n                if (me.isHorizontal()) {\r\n                    maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\r\n                } else {\r\n                    // The factor of 2 used to scale the font size has been experimentally determined.\r\n                    var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\r\n                    maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\r\n                }\r\n\r\n                return maxTicks;\r\n            },\r\n            // Called after the ticks are built. We need\r\n            handleDirectionalChanges: function() {\r\n                if (!this.isHorizontal()) {\r\n                    // We are in a vertical orientation. The top value is the highest. So reverse the array\r\n                    this.ticks.reverse();\r\n                }\r\n            },\r\n            getLabelForIndex: function(index, datasetIndex) {\r\n                return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\r\n            },\r\n            // Utils\r\n            getPixelForValue: function(value) {\r\n                // This must be called after fit has been run so that\r\n                // this.left, this.top, this.right, and this.bottom have been defined\r\n                var me = this;\r\n                var paddingLeft = me.paddingLeft;\r\n                var paddingBottom = me.paddingBottom;\r\n                var start = me.start;\r\n\r\n                var rightValue = +me.getRightValue(value);\r\n                var pixel;\r\n                var innerDimension;\r\n                var range = me.end - start;\r\n\r\n                if (me.isHorizontal()) {\r\n                    innerDimension = me.width - (paddingLeft + me.paddingRight);\r\n                    pixel = me.left + (innerDimension / range * (rightValue - start));\r\n                    return Math.round(pixel + paddingLeft);\r\n                }\r\n                innerDimension = me.height - (me.paddingTop + paddingBottom);\r\n                pixel = (me.bottom - paddingBottom) - (innerDimension / range * (rightValue - start));\r\n                return Math.round(pixel);\r\n            },\r\n            getValueForPixel: function(pixel) {\r\n                var me = this;\r\n                var isHorizontal = me.isHorizontal();\r\n                var paddingLeft = me.paddingLeft;\r\n                var paddingBottom = me.paddingBottom;\r\n                var innerDimension = isHorizontal ? me.width - (paddingLeft + me.paddingRight) : me.height - (me.paddingTop + paddingBottom);\r\n                var offset = (isHorizontal ? pixel - me.left - paddingLeft : me.bottom - paddingBottom - pixel) / innerDimension;\r\n                return me.start + ((me.end - me.start) * offset);\r\n            },\r\n            getPixelForTick: function(index) {\r\n                return this.getPixelForValue(this.ticksAsNumbers[index]);\r\n            }\r\n        });\r\n        Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\r\n\r\n    };\r\n\r\n},{}],43:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers,\r\n            noop = helpers.noop;\r\n\r\n        Chart.LinearScaleBase = Chart.Scale.extend({\r\n            handleTickRangeOptions: function() {\r\n                var me = this;\r\n                var opts = me.options;\r\n                var tickOpts = opts.ticks;\r\n\r\n                // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\r\n                // do nothing since that would make the chart weird. If the user really wants a weird chart\r\n                // axis, they can manually override it\r\n                if (tickOpts.beginAtZero) {\r\n                    var minSign = helpers.sign(me.min);\r\n                    var maxSign = helpers.sign(me.max);\r\n\r\n                    if (minSign < 0 && maxSign < 0) {\r\n                        // move the top up to 0\r\n                        me.max = 0;\r\n                    } else if (minSign > 0 && maxSign > 0) {\r\n                        // move the bottom down to 0\r\n                        me.min = 0;\r\n                    }\r\n                }\r\n\r\n                if (tickOpts.min !== undefined) {\r\n                    me.min = tickOpts.min;\r\n                } else if (tickOpts.suggestedMin !== undefined) {\r\n                    me.min = Math.min(me.min, tickOpts.suggestedMin);\r\n                }\r\n\r\n                if (tickOpts.max !== undefined) {\r\n                    me.max = tickOpts.max;\r\n                } else if (tickOpts.suggestedMax !== undefined) {\r\n                    me.max = Math.max(me.max, tickOpts.suggestedMax);\r\n                }\r\n\r\n                if (me.min === me.max) {\r\n                    me.max++;\r\n\r\n                    if (!tickOpts.beginAtZero) {\r\n                        me.min--;\r\n                    }\r\n                }\r\n            },\r\n            getTickLimit: noop,\r\n            handleDirectionalChanges: noop,\r\n\r\n            buildTicks: function() {\r\n                var me = this;\r\n                var opts = me.options;\r\n                var tickOpts = opts.ticks;\r\n\r\n                // Figure out what the max number of ticks we can support it is based on the size of\r\n                // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\r\n                // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\r\n                // the graph. Make sure we always have at least 2 ticks\r\n                var maxTicks = me.getTickLimit();\r\n                maxTicks = Math.max(2, maxTicks);\r\n\r\n                var numericGeneratorOptions = {\r\n                    maxTicks: maxTicks,\r\n                    min: tickOpts.min,\r\n                    max: tickOpts.max,\r\n                    stepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\r\n                };\r\n                var ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);\r\n\r\n                me.handleDirectionalChanges();\r\n\r\n                // At this point, we need to update our max and min given the tick values since we have expanded the\r\n                // range of the scale\r\n                me.max = helpers.max(ticks);\r\n                me.min = helpers.min(ticks);\r\n\r\n                if (tickOpts.reverse) {\r\n                    ticks.reverse();\r\n\r\n                    me.start = me.max;\r\n                    me.end = me.min;\r\n                } else {\r\n                    me.start = me.min;\r\n                    me.end = me.max;\r\n                }\r\n            },\r\n            convertTicksToLabels: function() {\r\n                var me = this;\r\n                me.ticksAsNumbers = me.ticks.slice();\r\n                me.zeroLineIndex = me.ticks.indexOf(0);\r\n\r\n                Chart.Scale.prototype.convertTicksToLabels.call(me);\r\n            }\r\n        });\r\n    };\r\n\r\n},{}],44:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n\r\n        var defaultConfig = {\r\n            position: 'left',\r\n\r\n            // label settings\r\n            ticks: {\r\n                callback: Chart.Ticks.formatters.logarithmic\r\n            }\r\n        };\r\n\r\n        var LogarithmicScale = Chart.Scale.extend({\r\n            determineDataLimits: function() {\r\n                var me = this;\r\n                var opts = me.options;\r\n                var tickOpts = opts.ticks;\r\n                var chart = me.chart;\r\n                var data = chart.data;\r\n                var datasets = data.datasets;\r\n                var getValueOrDefault = helpers.getValueOrDefault;\r\n                var isHorizontal = me.isHorizontal();\r\n                function IDMatches(meta) {\r\n                    return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\r\n                }\r\n\r\n                // Calculate Range\r\n                me.min = null;\r\n                me.max = null;\r\n                me.minNotZero = null;\r\n\r\n                if (opts.stacked) {\r\n                    var valuesPerType = {};\r\n\r\n                    helpers.each(datasets, function(dataset, datasetIndex) {\r\n                        var meta = chart.getDatasetMeta(datasetIndex);\r\n                        if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n                            if (valuesPerType[meta.type] === undefined) {\r\n                                valuesPerType[meta.type] = [];\r\n                            }\r\n\r\n                            helpers.each(dataset.data, function(rawValue, index) {\r\n                                var values = valuesPerType[meta.type];\r\n                                var value = +me.getRightValue(rawValue);\r\n                                if (isNaN(value) || meta.data[index].hidden) {\r\n                                    return;\r\n                                }\r\n\r\n                                values[index] = values[index] || 0;\r\n\r\n                                if (opts.relativePoints) {\r\n                                    values[index] = 100;\r\n                                } else {\r\n                                    // Don't need to split positive and negative since the log scale can't handle a 0 crossing\r\n                                    values[index] += value;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n\r\n                    helpers.each(valuesPerType, function(valuesForType) {\r\n                        var minVal = helpers.min(valuesForType);\r\n                        var maxVal = helpers.max(valuesForType);\r\n                        me.min = me.min === null ? minVal : Math.min(me.min, minVal);\r\n                        me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\r\n                    });\r\n\r\n                } else {\r\n                    helpers.each(datasets, function(dataset, datasetIndex) {\r\n                        var meta = chart.getDatasetMeta(datasetIndex);\r\n                        if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\r\n                            helpers.each(dataset.data, function(rawValue, index) {\r\n                                var value = +me.getRightValue(rawValue);\r\n                                if (isNaN(value) || meta.data[index].hidden) {\r\n                                    return;\r\n                                }\r\n\r\n                                if (me.min === null) {\r\n                                    me.min = value;\r\n                                } else if (value < me.min) {\r\n                                    me.min = value;\r\n                                }\r\n\r\n                                if (me.max === null) {\r\n                                    me.max = value;\r\n                                } else if (value > me.max) {\r\n                                    me.max = value;\r\n                                }\r\n\r\n                                if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\r\n                                    me.minNotZero = value;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                me.min = getValueOrDefault(tickOpts.min, me.min);\r\n                me.max = getValueOrDefault(tickOpts.max, me.max);\r\n\r\n                if (me.min === me.max) {\r\n                    if (me.min !== 0 && me.min !== null) {\r\n                        me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\r\n                        me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\r\n                    } else {\r\n                        me.min = 1;\r\n                        me.max = 10;\r\n                    }\r\n                }\r\n            },\r\n            buildTicks: function() {\r\n                var me = this;\r\n                var opts = me.options;\r\n                var tickOpts = opts.ticks;\r\n\r\n                var generationOptions = {\r\n                    min: tickOpts.min,\r\n                    max: tickOpts.max\r\n                };\r\n                var ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\r\n\r\n                if (!me.isHorizontal()) {\r\n                    // We are in a vertical orientation. The top value is the highest. So reverse the array\r\n                    ticks.reverse();\r\n                }\r\n\r\n                // At this point, we need to update our max and min given the tick values since we have expanded the\r\n                // range of the scale\r\n                me.max = helpers.max(ticks);\r\n                me.min = helpers.min(ticks);\r\n\r\n                if (tickOpts.reverse) {\r\n                    ticks.reverse();\r\n\r\n                    me.start = me.max;\r\n                    me.end = me.min;\r\n                } else {\r\n                    me.start = me.min;\r\n                    me.end = me.max;\r\n                }\r\n            },\r\n            convertTicksToLabels: function() {\r\n                this.tickValues = this.ticks.slice();\r\n\r\n                Chart.Scale.prototype.convertTicksToLabels.call(this);\r\n            },\r\n            // Get the correct tooltip label\r\n            getLabelForIndex: function(index, datasetIndex) {\r\n                return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\r\n            },\r\n            getPixelForTick: function(index) {\r\n                return this.getPixelForValue(this.tickValues[index]);\r\n            },\r\n            getPixelForValue: function(value) {\r\n                var me = this;\r\n                var innerDimension;\r\n                var pixel;\r\n\r\n                var start = me.start;\r\n                var newVal = +me.getRightValue(value);\r\n                var range;\r\n                var paddingTop = me.paddingTop;\r\n                var paddingBottom = me.paddingBottom;\r\n                var paddingLeft = me.paddingLeft;\r\n                var opts = me.options;\r\n                var tickOpts = opts.ticks;\r\n\r\n                if (me.isHorizontal()) {\r\n                    range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\r\n                    if (newVal === 0) {\r\n                        pixel = me.left + paddingLeft;\r\n                    } else {\r\n                        innerDimension = me.width - (paddingLeft + me.paddingRight);\r\n                        pixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\r\n                        pixel += paddingLeft;\r\n                    }\r\n                } else {\r\n                    // Bottom - top since pixels increase downward on a screen\r\n                    innerDimension = me.height - (paddingTop + paddingBottom);\r\n                    if (start === 0 && !tickOpts.reverse) {\r\n                        range = helpers.log10(me.end) - helpers.log10(me.minNotZero);\r\n                        if (newVal === start) {\r\n                            pixel = me.bottom - paddingBottom;\r\n                        } else if (newVal === me.minNotZero) {\r\n                            pixel = me.bottom - paddingBottom - innerDimension * 0.02;\r\n                        } else {\r\n                            pixel = me.bottom - paddingBottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\r\n                        }\r\n                    } else if (me.end === 0 && tickOpts.reverse) {\r\n                        range = helpers.log10(me.start) - helpers.log10(me.minNotZero);\r\n                        if (newVal === me.end) {\r\n                            pixel = me.top + paddingTop;\r\n                        } else if (newVal === me.minNotZero) {\r\n                            pixel = me.top + paddingTop + innerDimension * 0.02;\r\n                        } else {\r\n                            pixel = me.top + paddingTop + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\r\n                        }\r\n                    } else {\r\n                        range = helpers.log10(me.end) - helpers.log10(start);\r\n                        innerDimension = me.height - (paddingTop + paddingBottom);\r\n                        pixel = (me.bottom - paddingBottom) - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\r\n                    }\r\n                }\r\n                return pixel;\r\n            },\r\n            getValueForPixel: function(pixel) {\r\n                var me = this;\r\n                var range = helpers.log10(me.end) - helpers.log10(me.start);\r\n                var value, innerDimension;\r\n\r\n                if (me.isHorizontal()) {\r\n                    innerDimension = me.width - (me.paddingLeft + me.paddingRight);\r\n                    value = me.start * Math.pow(10, (pixel - me.left - me.paddingLeft) * range / innerDimension);\r\n                } else {  // todo: if start === 0\r\n                    innerDimension = me.height - (me.paddingTop + me.paddingBottom);\r\n                    value = Math.pow(10, (me.bottom - me.paddingBottom - pixel) * range / innerDimension) / me.start;\r\n                }\r\n                return value;\r\n            }\r\n        });\r\n        Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\r\n\r\n    };\r\n\r\n},{}],45:[function(require,module,exports){\r\n    'use strict';\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n        var globalDefaults = Chart.defaults.global;\r\n\r\n        var defaultConfig = {\r\n            display: true,\r\n\r\n            // Boolean - Whether to animate scaling the chart from the centre\r\n            animate: true,\r\n            lineArc: false,\r\n            position: 'chartArea',\r\n\r\n            angleLines: {\r\n                display: true,\r\n                color: 'rgba(0, 0, 0, 0.1)',\r\n                lineWidth: 1\r\n            },\r\n\r\n            // label settings\r\n            ticks: {\r\n                // Boolean - Show a backdrop to the scale label\r\n                showLabelBackdrop: true,\r\n\r\n                // String - The colour of the label backdrop\r\n                backdropColor: 'rgba(255,255,255,0.75)',\r\n\r\n                // Number - The backdrop padding above & below the label in pixels\r\n                backdropPaddingY: 2,\r\n\r\n                // Number - The backdrop padding to the side of the label in pixels\r\n                backdropPaddingX: 2,\r\n\r\n                callback: Chart.Ticks.formatters.linear\r\n            },\r\n\r\n            pointLabels: {\r\n                // Number - Point label font size in pixels\r\n                fontSize: 10,\r\n\r\n                // Function - Used to convert point labels\r\n                callback: function(label) {\r\n                    return label;\r\n                }\r\n            }\r\n        };\r\n\r\n        var LinearRadialScale = Chart.LinearScaleBase.extend({\r\n            getValueCount: function() {\r\n                return this.chart.data.labels.length;\r\n            },\r\n            setDimensions: function() {\r\n                var me = this;\r\n                var opts = me.options;\r\n                var tickOpts = opts.ticks;\r\n                // Set the unconstrained dimension before label rotation\r\n                me.width = me.maxWidth;\r\n                me.height = me.maxHeight;\r\n                me.xCenter = Math.round(me.width / 2);\r\n                me.yCenter = Math.round(me.height / 2);\r\n\r\n                var minSize = helpers.min([me.height, me.width]);\r\n                var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\r\n                me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\r\n            },\r\n            determineDataLimits: function() {\r\n                var me = this;\r\n                var chart = me.chart;\r\n                me.min = null;\r\n                me.max = null;\r\n\r\n\r\n                helpers.each(chart.data.datasets, function(dataset, datasetIndex) {\r\n                    if (chart.isDatasetVisible(datasetIndex)) {\r\n                        var meta = chart.getDatasetMeta(datasetIndex);\r\n\r\n                        helpers.each(dataset.data, function(rawValue, index) {\r\n                            var value = +me.getRightValue(rawValue);\r\n                            if (isNaN(value) || meta.data[index].hidden) {\r\n                                return;\r\n                            }\r\n\r\n                            if (me.min === null) {\r\n                                me.min = value;\r\n                            } else if (value < me.min) {\r\n                                me.min = value;\r\n                            }\r\n\r\n                            if (me.max === null) {\r\n                                me.max = value;\r\n                            } else if (value > me.max) {\r\n                                me.max = value;\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n\r\n                // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\r\n                me.handleTickRangeOptions();\r\n            },\r\n            getTickLimit: function() {\r\n                var tickOpts = this.options.ticks;\r\n                var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\r\n                return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\r\n            },\r\n            convertTicksToLabels: function() {\r\n                var me = this;\r\n                Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\r\n\r\n                // Point labels\r\n                me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\r\n            },\r\n            getLabelForIndex: function(index, datasetIndex) {\r\n                return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\r\n            },\r\n            fit: function() {\r\n                /*\r\n                 * Right, this is really confusing and there is a lot of maths going on here\r\n                 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\r\n                 *\r\n                 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\r\n                 *\r\n                 * Solution:\r\n                 *\r\n                 * We assume the radius of the polygon is half the size of the canvas at first\r\n                 * at each index we check if the text overlaps.\r\n                 *\r\n                 * Where it does, we store that angle and that index.\r\n                 *\r\n                 * After finding the largest index and angle we calculate how much we need to remove\r\n                 * from the shape radius to move the point inwards by that x.\r\n                 *\r\n                 * We average the left and right distances to get the maximum shape radius that can fit in the box\r\n                 * along with labels.\r\n                 *\r\n                 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\r\n                 * on each side, removing that from the size, halving it and adding the left x protrusion width.\r\n                 *\r\n                 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\r\n                 * and position it in the most space efficient manner\r\n                 *\r\n                 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\r\n                 */\r\n\r\n                var pointLabels = this.options.pointLabels;\r\n                var pointLabelFontSize = helpers.getValueOrDefault(pointLabels.fontSize, globalDefaults.defaultFontSize);\r\n                var pointLabeFontStyle = helpers.getValueOrDefault(pointLabels.fontStyle, globalDefaults.defaultFontStyle);\r\n                var pointLabeFontFamily = helpers.getValueOrDefault(pointLabels.fontFamily, globalDefaults.defaultFontFamily);\r\n                var pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);\r\n\r\n                // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\r\n                // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\r\n                var largestPossibleRadius = helpers.min([(this.height / 2 - pointLabelFontSize - 5), this.width / 2]),\r\n                    pointPosition,\r\n                    i,\r\n                    textWidth,\r\n                    halfTextWidth,\r\n                    furthestRight = this.width,\r\n                    furthestRightIndex,\r\n                    furthestRightAngle,\r\n                    furthestLeft = 0,\r\n                    furthestLeftIndex,\r\n                    furthestLeftAngle,\r\n                    xProtrusionLeft,\r\n                    xProtrusionRight,\r\n                    radiusReductionRight,\r\n                    radiusReductionLeft;\r\n                this.ctx.font = pointLabeFont;\r\n\r\n                for (i = 0; i < this.getValueCount(); i++) {\r\n                    // 5px to space the text slightly out - similar to what we do in the draw function.\r\n                    pointPosition = this.getPointPosition(i, largestPossibleRadius);\r\n                    textWidth = this.ctx.measureText(this.pointLabels[i] ? this.pointLabels[i] : '').width + 5;\r\n\r\n                    // Add quarter circle to make degree 0 mean top of circle\r\n                    var angleRadians = this.getIndexAngle(i) + (Math.PI / 2);\r\n                    var angle = (angleRadians * 360 / (2 * Math.PI)) % 360;\r\n\r\n                    if (angle === 0 || angle === 180) {\r\n                        // At angle 0 and 180, we're at exactly the top/bottom\r\n                        // of the radar chart, so text will be aligned centrally, so we'll half it and compare\r\n                        // w/left and right text sizes\r\n                        halfTextWidth = textWidth / 2;\r\n                        if (pointPosition.x + halfTextWidth > furthestRight) {\r\n                            furthestRight = pointPosition.x + halfTextWidth;\r\n                            furthestRightIndex = i;\r\n                        }\r\n                        if (pointPosition.x - halfTextWidth < furthestLeft) {\r\n                            furthestLeft = pointPosition.x - halfTextWidth;\r\n                            furthestLeftIndex = i;\r\n                        }\r\n                    } else if (angle < 180) {\r\n                        // Less than half the values means we'll left align the text\r\n                        if (pointPosition.x + textWidth > furthestRight) {\r\n                            furthestRight = pointPosition.x + textWidth;\r\n                            furthestRightIndex = i;\r\n                        }\r\n                        // More than half the values means we'll right align the text\r\n                    } else if (pointPosition.x - textWidth < furthestLeft) {\r\n                        furthestLeft = pointPosition.x - textWidth;\r\n                        furthestLeftIndex = i;\r\n                    }\r\n                }\r\n\r\n                xProtrusionLeft = furthestLeft;\r\n                xProtrusionRight = Math.ceil(furthestRight - this.width);\r\n\r\n                furthestRightAngle = this.getIndexAngle(furthestRightIndex);\r\n                furthestLeftAngle = this.getIndexAngle(furthestLeftIndex);\r\n\r\n                radiusReductionRight = xProtrusionRight / Math.sin(furthestRightAngle + Math.PI / 2);\r\n                radiusReductionLeft = xProtrusionLeft / Math.sin(furthestLeftAngle + Math.PI / 2);\r\n\r\n                // Ensure we actually need to reduce the size of the chart\r\n                radiusReductionRight = (helpers.isNumber(radiusReductionRight)) ? radiusReductionRight : 0;\r\n                radiusReductionLeft = (helpers.isNumber(radiusReductionLeft)) ? radiusReductionLeft : 0;\r\n\r\n                this.drawingArea = Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2);\r\n                this.setCenterPoint(radiusReductionLeft, radiusReductionRight);\r\n            },\r\n            setCenterPoint: function(leftMovement, rightMovement) {\r\n                var me = this;\r\n                var maxRight = me.width - rightMovement - me.drawingArea,\r\n                    maxLeft = leftMovement + me.drawingArea;\r\n\r\n                me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\r\n                // Always vertically in the centre as the text height doesn't change\r\n                me.yCenter = Math.round((me.height / 2) + me.top);\r\n            },\r\n\r\n            getIndexAngle: function(index) {\r\n                var angleMultiplier = (Math.PI * 2) / this.getValueCount();\r\n                var startAngle = this.chart.options && this.chart.options.startAngle ?\r\n                    this.chart.options.startAngle :\r\n                    0;\r\n\r\n                var startAngleRadians = startAngle * Math.PI * 2 / 360;\r\n\r\n                // Start from the top instead of right, so remove a quarter of the circle\r\n                return index * angleMultiplier - (Math.PI / 2) + startAngleRadians;\r\n            },\r\n            getDistanceFromCenterForValue: function(value) {\r\n                var me = this;\r\n\r\n                if (value === null) {\r\n                    return 0; // null always in center\r\n                }\r\n\r\n                // Take into account half font size + the yPadding of the top value\r\n                var scalingFactor = me.drawingArea / (me.max - me.min);\r\n                if (me.options.reverse) {\r\n                    return (me.max - value) * scalingFactor;\r\n                }\r\n                return (value - me.min) * scalingFactor;\r\n            },\r\n            getPointPosition: function(index, distanceFromCenter) {\r\n                var me = this;\r\n                var thisAngle = me.getIndexAngle(index);\r\n                return {\r\n                    x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\r\n                    y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\r\n                };\r\n            },\r\n            getPointPositionForValue: function(index, value) {\r\n                return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\r\n            },\r\n\r\n            getBasePosition: function() {\r\n                var me = this;\r\n                var min = me.min;\r\n                var max = me.max;\r\n\r\n                return me.getPointPositionForValue(0,\r\n                    me.beginAtZero? 0:\r\n                        min < 0 && max < 0? max :\r\n                            min > 0 && max > 0? min :\r\n                                0);\r\n            },\r\n\r\n            draw: function() {\r\n                var me = this;\r\n                var opts = me.options;\r\n                var gridLineOpts = opts.gridLines;\r\n                var tickOpts = opts.ticks;\r\n                var angleLineOpts = opts.angleLines;\r\n                var pointLabelOpts = opts.pointLabels;\r\n                var getValueOrDefault = helpers.getValueOrDefault;\r\n\r\n                if (opts.display) {\r\n                    var ctx = me.ctx;\r\n\r\n                    // Tick Font\r\n                    var tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\r\n                    var tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\r\n                    var tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\r\n                    var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\r\n\r\n                    helpers.each(me.ticks, function(label, index) {\r\n                        // Don't draw a centre value (if it is minimum)\r\n                        if (index > 0 || opts.reverse) {\r\n                            var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\r\n                            var yHeight = me.yCenter - yCenterOffset;\r\n\r\n                            // Draw circular lines around the scale\r\n                            if (gridLineOpts.display && index !== 0) {\r\n                                ctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\r\n                                ctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\r\n\r\n                                if (opts.lineArc) {\r\n                                    // Draw circular arcs between the points\r\n                                    ctx.beginPath();\r\n                                    ctx.arc(me.xCenter, me.yCenter, yCenterOffset, 0, Math.PI * 2);\r\n                                    ctx.closePath();\r\n                                    ctx.stroke();\r\n                                } else {\r\n                                    // Draw straight lines connecting each index\r\n                                    ctx.beginPath();\r\n                                    for (var i = 0; i < me.getValueCount(); i++) {\r\n                                        var pointPosition = me.getPointPosition(i, yCenterOffset);\r\n                                        if (i === 0) {\r\n                                            ctx.moveTo(pointPosition.x, pointPosition.y);\r\n                                        } else {\r\n                                            ctx.lineTo(pointPosition.x, pointPosition.y);\r\n                                        }\r\n                                    }\r\n                                    ctx.closePath();\r\n                                    ctx.stroke();\r\n                                }\r\n                            }\r\n\r\n                            if (tickOpts.display) {\r\n                                var tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\r\n                                ctx.font = tickLabelFont;\r\n\r\n                                if (tickOpts.showLabelBackdrop) {\r\n                                    var labelWidth = ctx.measureText(label).width;\r\n                                    ctx.fillStyle = tickOpts.backdropColor;\r\n                                    ctx.fillRect(\r\n                                        me.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,\r\n                                        yHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,\r\n                                        labelWidth + tickOpts.backdropPaddingX * 2,\r\n                                        tickFontSize + tickOpts.backdropPaddingY * 2\r\n                                    );\r\n                                }\r\n\r\n                                ctx.textAlign = 'center';\r\n                                ctx.textBaseline = 'middle';\r\n                                ctx.fillStyle = tickFontColor;\r\n                                ctx.fillText(label, me.xCenter, yHeight);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    if (!opts.lineArc) {\r\n                        ctx.lineWidth = angleLineOpts.lineWidth;\r\n                        ctx.strokeStyle = angleLineOpts.color;\r\n\r\n                        var outerDistance = me.getDistanceFromCenterForValue(opts.reverse ? me.min : me.max);\r\n\r\n                        // Point Label Font\r\n                        var pointLabelFontSize = getValueOrDefault(pointLabelOpts.fontSize, globalDefaults.defaultFontSize);\r\n                        var pointLabeFontStyle = getValueOrDefault(pointLabelOpts.fontStyle, globalDefaults.defaultFontStyle);\r\n                        var pointLabeFontFamily = getValueOrDefault(pointLabelOpts.fontFamily, globalDefaults.defaultFontFamily);\r\n                        var pointLabeFont = helpers.fontString(pointLabelFontSize, pointLabeFontStyle, pointLabeFontFamily);\r\n\r\n                        for (var i = me.getValueCount() - 1; i >= 0; i--) {\r\n                            if (angleLineOpts.display) {\r\n                                var outerPosition = me.getPointPosition(i, outerDistance);\r\n                                ctx.beginPath();\r\n                                ctx.moveTo(me.xCenter, me.yCenter);\r\n                                ctx.lineTo(outerPosition.x, outerPosition.y);\r\n                                ctx.stroke();\r\n                                ctx.closePath();\r\n                            }\r\n                            // Extra 3px out for some label spacing\r\n                            var pointLabelPosition = me.getPointPosition(i, outerDistance + 5);\r\n\r\n                            // Keep this in loop since we may support array properties here\r\n                            var pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\r\n                            ctx.font = pointLabeFont;\r\n                            ctx.fillStyle = pointLabelFontColor;\r\n\r\n                            var pointLabels = me.pointLabels;\r\n\r\n                            // Add quarter circle to make degree 0 mean top of circle\r\n                            var angleRadians = this.getIndexAngle(i) + (Math.PI / 2);\r\n                            var angle = (angleRadians * 360 / (2 * Math.PI)) % 360;\r\n\r\n                            if (angle === 0 || angle === 180) {\r\n                                ctx.textAlign = 'center';\r\n                            } else if (angle < 180) {\r\n                                ctx.textAlign = 'left';\r\n                            } else {\r\n                                ctx.textAlign = 'right';\r\n                            }\r\n\r\n                            // Set the correct text baseline based on outer positioning\r\n                            if (angle === 90 || angle === 270) {\r\n                                ctx.textBaseline = 'middle';\r\n                            } else if (angle > 270 || angle < 90) {\r\n                                ctx.textBaseline = 'bottom';\r\n                            } else {\r\n                                ctx.textBaseline = 'top';\r\n                            }\r\n\r\n                            ctx.fillText(pointLabels[i] ? pointLabels[i] : '', pointLabelPosition.x, pointLabelPosition.y);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\r\n\r\n    };\r\n\r\n},{}],46:[function(require,module,exports){\r\n    /* global window: false */\r\n    'use strict';\r\n\r\n    var moment = require(1);\r\n    moment = typeof(moment) === 'function' ? moment : window.moment;\r\n\r\n    module.exports = function(Chart) {\r\n\r\n        var helpers = Chart.helpers;\r\n        var time = {\r\n            units: [{\r\n                name: 'millisecond',\r\n                steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\r\n            }, {\r\n                name: 'second',\r\n                steps: [1, 2, 5, 10, 30]\r\n            }, {\r\n                name: 'minute',\r\n                steps: [1, 2, 5, 10, 30]\r\n            }, {\r\n                name: 'hour',\r\n                steps: [1, 2, 3, 6, 12]\r\n            }, {\r\n                name: 'day',\r\n                steps: [1, 2, 5]\r\n            }, {\r\n                name: 'week',\r\n                maxStep: 4\r\n            }, {\r\n                name: 'month',\r\n                maxStep: 3\r\n            }, {\r\n                name: 'quarter',\r\n                maxStep: 4\r\n            }, {\r\n                name: 'year',\r\n                maxStep: false\r\n            }]\r\n        };\r\n\r\n        var defaultConfig = {\r\n            position: 'bottom',\r\n\r\n            time: {\r\n                parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\r\n                format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\r\n                unit: false, // false == automatic or override with week, month, year, etc.\r\n                round: false, // none, or override with week, month, year, etc.\r\n                displayFormat: false, // DEPRECATED\r\n                isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\r\n                minUnit: 'millisecond',\r\n\r\n                // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\r\n                displayFormats: {\r\n                    millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\r\n                    second: 'h:mm:ss a', // 11:20:01 AM\r\n                    minute: 'h:mm:ss a', // 11:20:01 AM\r\n                    hour: 'MMM D, hA', // Sept 4, 5PM\r\n                    day: 'll', // Sep 4 2015\r\n                    week: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\r\n                    month: 'MMM YYYY', // Sept 2015\r\n                    quarter: '[Q]Q - YYYY', // Q3\r\n                    year: 'YYYY' // 2015\r\n                }\r\n            },\r\n            ticks: {\r\n                autoSkip: false\r\n            }\r\n        };\r\n\r\n        var TimeScale = Chart.Scale.extend({\r\n            initialize: function() {\r\n                if (!moment) {\r\n                    throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\r\n                }\r\n\r\n                Chart.Scale.prototype.initialize.call(this);\r\n            },\r\n            getLabelMoment: function(datasetIndex, index) {\r\n                if (datasetIndex === null || index === null) {\r\n                    return null;\r\n                }\r\n\r\n                if (typeof this.labelMoments[datasetIndex] !== 'undefined') {\r\n                    return this.labelMoments[datasetIndex][index];\r\n                }\r\n\r\n                return null;\r\n            },\r\n            getLabelDiff: function(datasetIndex, index) {\r\n                var me = this;\r\n                if (datasetIndex === null || index === null) {\r\n                    return null;\r\n                }\r\n\r\n                if (me.labelDiffs === undefined) {\r\n                    me.buildLabelDiffs();\r\n                }\r\n\r\n                if (typeof me.labelDiffs[datasetIndex] !== 'undefined') {\r\n                    return me.labelDiffs[datasetIndex][index];\r\n                }\r\n\r\n                return null;\r\n            },\r\n            getMomentStartOf: function(tick) {\r\n                var me = this;\r\n                if (me.options.time.unit === 'week' && me.options.time.isoWeekday !== false) {\r\n                    return tick.clone().startOf('isoWeek').isoWeekday(me.options.time.isoWeekday);\r\n                }\r\n                return tick.clone().startOf(me.tickUnit);\r\n            },\r\n            determineDataLimits: function() {\r\n                var me = this;\r\n                me.labelMoments = [];\r\n\r\n                // Only parse these once. If the dataset does not have data as x,y pairs, we will use\r\n                // these\r\n                var scaleLabelMoments = [];\r\n                if (me.chart.data.labels && me.chart.data.labels.length > 0) {\r\n                    helpers.each(me.chart.data.labels, function(label) {\r\n                        var labelMoment = me.parseTime(label);\r\n\r\n                        if (labelMoment.isValid()) {\r\n                            if (me.options.time.round) {\r\n                                labelMoment.startOf(me.options.time.round);\r\n                            }\r\n                            scaleLabelMoments.push(labelMoment);\r\n                        }\r\n                    }, me);\r\n\r\n                    me.firstTick = moment.min.call(me, scaleLabelMoments);\r\n                    me.lastTick = moment.max.call(me, scaleLabelMoments);\r\n                } else {\r\n                    me.firstTick = null;\r\n                    me.lastTick = null;\r\n                }\r\n\r\n                helpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\r\n                    var momentsForDataset = [];\r\n                    var datasetVisible = me.chart.isDatasetVisible(datasetIndex);\r\n\r\n                    if (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\r\n                        helpers.each(dataset.data, function(value) {\r\n                            var labelMoment = me.parseTime(me.getRightValue(value));\r\n\r\n                            if (labelMoment.isValid()) {\r\n                                if (me.options.time.round) {\r\n                                    labelMoment.startOf(me.options.time.round);\r\n                                }\r\n                                momentsForDataset.push(labelMoment);\r\n\r\n                                if (datasetVisible) {\r\n                                    // May have gone outside the scale ranges, make sure we keep the first and last ticks updated\r\n                                    me.firstTick = me.firstTick !== null ? moment.min(me.firstTick, labelMoment) : labelMoment;\r\n                                    me.lastTick = me.lastTick !== null ? moment.max(me.lastTick, labelMoment) : labelMoment;\r\n                                }\r\n                            }\r\n                        }, me);\r\n                    } else {\r\n                        // We have no labels. Use the ones from the scale\r\n                        momentsForDataset = scaleLabelMoments;\r\n                    }\r\n\r\n                    me.labelMoments.push(momentsForDataset);\r\n                }, me);\r\n\r\n                // Set these after we've done all the data\r\n                if (me.options.time.min) {\r\n                    me.firstTick = me.parseTime(me.options.time.min);\r\n                }\r\n\r\n                if (me.options.time.max) {\r\n                    me.lastTick = me.parseTime(me.options.time.max);\r\n                }\r\n\r\n                // We will modify these, so clone for later\r\n                me.firstTick = (me.firstTick || moment()).clone();\r\n                me.lastTick = (me.lastTick || moment()).clone();\r\n            },\r\n            buildLabelDiffs: function() {\r\n                var me = this;\r\n                me.labelDiffs = [];\r\n                var scaleLabelDiffs = [];\r\n                // Parse common labels once\r\n                if (me.chart.data.labels && me.chart.data.labels.length > 0) {\r\n                    helpers.each(me.chart.data.labels, function(label) {\r\n                        var labelMoment = me.parseTime(label);\r\n\r\n                        if (labelMoment.isValid()) {\r\n                            if (me.options.time.round) {\r\n                                labelMoment.startOf(me.options.time.round);\r\n                            }\r\n                            scaleLabelDiffs.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\r\n                        }\r\n                    }, me);\r\n                }\r\n\r\n                helpers.each(me.chart.data.datasets, function(dataset) {\r\n                    var diffsForDataset = [];\r\n\r\n                    if (typeof dataset.data[0] === 'object' && dataset.data[0] !== null) {\r\n                        helpers.each(dataset.data, function(value) {\r\n                            var labelMoment = me.parseTime(me.getRightValue(value));\r\n\r\n                            if (labelMoment.isValid()) {\r\n                                if (me.options.time.round) {\r\n                                    labelMoment.startOf(me.options.time.round);\r\n                                }\r\n                                diffsForDataset.push(labelMoment.diff(me.firstTick, me.tickUnit, true));\r\n                            }\r\n                        }, me);\r\n                    } else {\r\n                        // We have no labels. Use common ones\r\n                        diffsForDataset = scaleLabelDiffs;\r\n                    }\r\n\r\n                    me.labelDiffs.push(diffsForDataset);\r\n                }, me);\r\n            },\r\n            buildTicks: function() {\r\n                var me = this;\r\n\r\n                me.ctx.save();\r\n                var tickFontSize = helpers.getValueOrDefault(me.options.ticks.fontSize, Chart.defaults.global.defaultFontSize);\r\n                var tickFontStyle = helpers.getValueOrDefault(me.options.ticks.fontStyle, Chart.defaults.global.defaultFontStyle);\r\n                var tickFontFamily = helpers.getValueOrDefault(me.options.ticks.fontFamily, Chart.defaults.global.defaultFontFamily);\r\n                var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\r\n                me.ctx.font = tickLabelFont;\r\n\r\n                me.ticks = [];\r\n                me.unitScale = 1; // How much we scale the unit by, ie 2 means 2x unit per step\r\n                me.scaleSizeInUnits = 0; // How large the scale is in the base unit (seconds, minutes, etc)\r\n\r\n                // Set unit override if applicable\r\n                if (me.options.time.unit) {\r\n                    me.tickUnit = me.options.time.unit || 'day';\r\n                    me.displayFormat = me.options.time.displayFormats[me.tickUnit];\r\n                    me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\r\n                    me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, 1);\r\n                } else {\r\n                    // Determine the smallest needed unit of the time\r\n                    var innerWidth = me.isHorizontal() ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);\r\n\r\n                    // Crude approximation of what the label length might be\r\n                    var tempFirstLabel = me.tickFormatFunction(me.firstTick, 0, []);\r\n                    var tickLabelWidth = me.ctx.measureText(tempFirstLabel).width;\r\n                    var cosRotation = Math.cos(helpers.toRadians(me.options.ticks.maxRotation));\r\n                    var sinRotation = Math.sin(helpers.toRadians(me.options.ticks.maxRotation));\r\n                    tickLabelWidth = (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\r\n                    var labelCapacity = innerWidth / (tickLabelWidth);\r\n\r\n                    // Start as small as possible\r\n                    me.tickUnit = me.options.time.minUnit;\r\n                    me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\r\n                    me.displayFormat = me.options.time.displayFormats[me.tickUnit];\r\n\r\n                    var unitDefinitionIndex = 0;\r\n                    var unitDefinition = time.units[unitDefinitionIndex];\r\n\r\n                    // While we aren't ideal and we don't have units left\r\n                    while (unitDefinitionIndex < time.units.length) {\r\n                        // Can we scale this unit. If `false` we can scale infinitely\r\n                        me.unitScale = 1;\r\n\r\n                        if (helpers.isArray(unitDefinition.steps) && Math.ceil(me.scaleSizeInUnits / labelCapacity) < helpers.max(unitDefinition.steps)) {\r\n                            // Use one of the predefined steps\r\n                            for (var idx = 0; idx < unitDefinition.steps.length; ++idx) {\r\n                                if (unitDefinition.steps[idx] >= Math.ceil(me.scaleSizeInUnits / labelCapacity)) {\r\n                                    me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, unitDefinition.steps[idx]);\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            break;\r\n                        } else if ((unitDefinition.maxStep === false) || (Math.ceil(me.scaleSizeInUnits / labelCapacity) < unitDefinition.maxStep)) {\r\n                            // We have a max step. Scale this unit\r\n                            me.unitScale = helpers.getValueOrDefault(me.options.time.unitStepSize, Math.ceil(me.scaleSizeInUnits / labelCapacity));\r\n                            break;\r\n                        } else {\r\n                            // Move to the next unit up\r\n                            ++unitDefinitionIndex;\r\n                            unitDefinition = time.units[unitDefinitionIndex];\r\n\r\n                            me.tickUnit = unitDefinition.name;\r\n                            var leadingUnitBuffer = me.firstTick.diff(me.getMomentStartOf(me.firstTick), me.tickUnit, true);\r\n                            var trailingUnitBuffer = me.getMomentStartOf(me.lastTick.clone().add(1, me.tickUnit)).diff(me.lastTick, me.tickUnit, true);\r\n                            me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true) + leadingUnitBuffer + trailingUnitBuffer;\r\n                            me.displayFormat = me.options.time.displayFormats[unitDefinition.name];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                var roundedStart;\r\n\r\n                // Only round the first tick if we have no hard minimum\r\n                if (!me.options.time.min) {\r\n                    me.firstTick = me.getMomentStartOf(me.firstTick);\r\n                    roundedStart = me.firstTick;\r\n                } else {\r\n                    roundedStart = me.getMomentStartOf(me.firstTick);\r\n                }\r\n\r\n                // Only round the last tick if we have no hard maximum\r\n                if (!me.options.time.max) {\r\n                    var roundedEnd = me.getMomentStartOf(me.lastTick);\r\n                    var delta = roundedEnd.diff(me.lastTick, me.tickUnit, true);\r\n                    if (delta < 0) {\r\n                        // Do not use end of because we need me to be in the next time unit\r\n                        me.lastTick = me.getMomentStartOf(me.lastTick.add(1, me.tickUnit));\r\n                    } else if (delta >= 0) {\r\n                        me.lastTick = roundedEnd;\r\n                    }\r\n\r\n                    me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\r\n                }\r\n\r\n                // Tick displayFormat override\r\n                if (me.options.time.displayFormat) {\r\n                    me.displayFormat = me.options.time.displayFormat;\r\n                }\r\n\r\n                // first tick. will have been rounded correctly if options.time.min is not specified\r\n                me.ticks.push(me.firstTick.clone());\r\n\r\n                // For every unit in between the first and last moment, create a moment and add it to the ticks tick\r\n                for (var i = 1; i <= me.scaleSizeInUnits; ++i) {\r\n                    var newTick = roundedStart.clone().add(i, me.tickUnit);\r\n\r\n                    // Are we greater than the max time\r\n                    if (me.options.time.max && newTick.diff(me.lastTick, me.tickUnit, true) >= 0) {\r\n                        break;\r\n                    }\r\n\r\n                    if (i % me.unitScale === 0) {\r\n                        me.ticks.push(newTick);\r\n                    }\r\n                }\r\n\r\n                // Always show the right tick\r\n                var diff = me.ticks[me.ticks.length - 1].diff(me.lastTick, me.tickUnit);\r\n                if (diff !== 0 || me.scaleSizeInUnits === 0) {\r\n                    // this is a weird case. If the <max> option is the same as the end option, we can't just diff the times because the tick was created from the roundedStart\r\n                    // but the last tick was not rounded.\r\n                    if (me.options.time.max) {\r\n                        me.ticks.push(me.lastTick.clone());\r\n                        me.scaleSizeInUnits = me.lastTick.diff(me.ticks[0], me.tickUnit, true);\r\n                    } else {\r\n                        me.ticks.push(me.lastTick.clone());\r\n                        me.scaleSizeInUnits = me.lastTick.diff(me.firstTick, me.tickUnit, true);\r\n                    }\r\n                }\r\n\r\n                me.ctx.restore();\r\n\r\n                // Invalidate label diffs cache\r\n                me.labelDiffs = undefined;\r\n            },\r\n            // Get tooltip label\r\n            getLabelForIndex: function(index, datasetIndex) {\r\n                var me = this;\r\n                var label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\r\n\r\n                if (typeof me.chart.data.datasets[datasetIndex].data[0] === 'object') {\r\n                    label = me.getRightValue(me.chart.data.datasets[datasetIndex].data[index]);\r\n                }\r\n\r\n                // Format nicely\r\n                if (me.options.time.tooltipFormat) {\r\n                    label = me.parseTime(label).format(me.options.time.tooltipFormat);\r\n                }\r\n\r\n                return label;\r\n            },\r\n            // Function to format an individual tick mark\r\n            tickFormatFunction: function(tick, index, ticks) {\r\n                var formattedTick = tick.format(this.displayFormat);\r\n                var tickOpts = this.options.ticks;\r\n                var callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\r\n\r\n                if (callback) {\r\n                    return callback(formattedTick, index, ticks);\r\n                }\r\n                return formattedTick;\r\n            },\r\n            convertTicksToLabels: function() {\r\n                var me = this;\r\n                me.tickMoments = me.ticks;\r\n                me.ticks = me.ticks.map(me.tickFormatFunction, me);\r\n            },\r\n            getPixelForValue: function(value, index, datasetIndex) {\r\n                var me = this;\r\n                var offset = null;\r\n                if (index !== undefined && datasetIndex !== undefined) {\r\n                    offset = me.getLabelDiff(datasetIndex, index);\r\n                }\r\n\r\n                if (offset === null) {\r\n                    if (!value || !value.isValid) {\r\n                        // not already a moment object\r\n                        value = me.parseTime(me.getRightValue(value));\r\n                    }\r\n                    if (value && value.isValid && value.isValid()) {\r\n                        offset = value.diff(me.firstTick, me.tickUnit, true);\r\n                    }\r\n                }\r\n\r\n                if (offset !== null) {\r\n                    var decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;\r\n\r\n                    if (me.isHorizontal()) {\r\n                        var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\r\n                        var valueOffset = (innerWidth * decimal) + me.paddingLeft;\r\n\r\n                        return me.left + Math.round(valueOffset);\r\n                    }\r\n                    var innerHeight = me.height - (me.paddingTop + me.paddingBottom);\r\n                    var heightOffset = (innerHeight * decimal) + me.paddingTop;\r\n\r\n                    return me.top + Math.round(heightOffset);\r\n                }\r\n            },\r\n            getPixelForTick: function(index) {\r\n                return this.getPixelForValue(this.tickMoments[index], null, null);\r\n            },\r\n            getValueForPixel: function(pixel) {\r\n                var me = this;\r\n                var innerDimension = me.isHorizontal() ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.paddingBottom);\r\n                var offset = (pixel - (me.isHorizontal() ? me.left + me.paddingLeft : me.top + me.paddingTop)) / innerDimension;\r\n                offset *= me.scaleSizeInUnits;\r\n                return me.firstTick.clone().add(moment.duration(offset, me.tickUnit).asSeconds(), 'seconds');\r\n            },\r\n            parseTime: function(label) {\r\n                var me = this;\r\n                if (typeof me.options.time.parser === 'string') {\r\n                    return moment(label, me.options.time.parser);\r\n                }\r\n                if (typeof me.options.time.parser === 'function') {\r\n                    return me.options.time.parser(label);\r\n                }\r\n                // Date objects\r\n                if (typeof label.getMonth === 'function' || typeof label === 'number') {\r\n                    return moment(label);\r\n                }\r\n                // Moment support\r\n                if (label.isValid && label.isValid()) {\r\n                    return label;\r\n                }\r\n                // Custom parsing (return an instance of moment)\r\n                if (typeof me.options.time.format !== 'string' && me.options.time.format.call) {\r\n                    console.warn('options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale');\r\n                    return me.options.time.format(label);\r\n                }\r\n                // Moment format parsing\r\n                return moment(label, me.options.time.format);\r\n            }\r\n        });\r\n        Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\r\n\r\n    };\r\n\r\n},{\"1\":1}]},{},[7])(7)\r\n});","/**\r\n * Dashboard Graph\r\n */\r\nif ($('#homeGraph').length) {\r\n    new Vue({\r\n        el: '#homeGraph',\r\n        data: {\r\n            loading: true,\r\n            chart_obj: {}\r\n        },\r\n        methods: {\r\n            loadChart: function () {\r\n                var vue = this;\r\n                vue.loading = true;\r\n                $.post(\"/fantasy/graphData\",{ '_token': Laravel.csrfToken})\r\n                    .done(function (data) {\r\n                        vue.loading = false;\r\n                        vue.chart_obj = new Chart($('#chart'), {\r\n                            type: 'line',\r\n                            data: data.chart_data,\r\n                            options: {\r\n                                scales: {\r\n                                    yAxes: [{\r\n                                        ticks: {\r\n                                            beginAtZero: true,\r\n                                            maxTicksLimit: 8\r\n                                        }\r\n                                    }]\r\n                                },\r\n                                legend: {\r\n                                    display: true,\r\n                                    position: 'bottom',\r\n                                    labels: {\r\n                                        fontSize: 14,\r\n                                        boxWidth: 50\r\n                                    }\r\n                                },\r\n                            }\r\n                        });\r\n                    })\r\n                    .fail(function () {\r\n                        alert('Loading Graph Error');\r\n                    });\r\n            },\r\n        },\r\n        created: function () {\r\n            this.loadChart();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Buy More Tickets\r\n */\r\nif ($('#buy-tickets').length) {\r\n    new Vue({\r\n        el: '#buy-tickets',\r\n        data: {\r\n            form:new Form({\r\n                stripeEmail: '',\r\n                stripeToken: '',\r\n                checkout_quantity: 1,\r\n                _token: Laravel.csrfToken\r\n            }),\r\n            stripe: '',\r\n            has_success: true\r\n        },\r\n        created: function () {\r\n            var vue = this;\r\n            this.stripe = StripeCheckout.configure({\r\n                key: Laravel.stripeKey,\r\n                locale: \"auto\",\r\n                email: Laravel.email,\r\n                token: function (token) {\r\n                    vue.form.stripeToken = token.id;\r\n                    vue.form.stripeEmail = token.email;\r\n                    vue.form.submit('/fantasy/checkout').then(function () {\r\n                        vue.form.message = 'Payment Process successfully.';\r\n                        vue.has_success = true;\r\n                        vue.form.checkout_quantity = 1;\r\n                    }).catch(function () {\r\n                        vue.has_success = false;\r\n                        vue.form.checkout_quantity = 1;\r\n                    });\r\n                }\r\n            });\r\n        },\r\n        methods: {\r\n            buy: function () {\r\n                var vue = this;\r\n                this.stripe.open({\r\n                    name: 'Fantasy Marketing',\r\n                    description: 'Buying Tickets',\r\n                    zipCode: true,\r\n                    amount: Laravel.ticketPrice * vue.form.checkout_quantity\r\n                });\r\n            },\r\n            isValidCheckOut: function () {\r\n                return (!isNaN(this.form.checkout_quantity) && this.form.checkout_quantity > 0);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Notifications\r\n */\r\nif ($('#users-view').length) {\r\n    var notification_data = {\r\n        form: new Form({\r\n            notification_user: '',\r\n            notification_message: '',\r\n            _token: Laravel.csrfToken\r\n        }),\r\n        has_success: true,\r\n        notification_to_message: ''\r\n    };\r\n    new Vue({\r\n        el: '#users-view',\r\n        data: notification_data,\r\n        methods: {\r\n            openModal: function (type) {\r\n                this.form.reset();\r\n                $('#notification_modal').modal('show');\r\n                this.getNotificationLabel(type);\r\n                this.form.notification_user = type;\r\n            },\r\n            sendNotification: function () {\r\n                var vue = this;\r\n                this.form.submit('/fantasy/user_view_notification').then(function () {\r\n                    vue.form.message = 'Message Send Successfully.';\r\n                    vue.has_success = true;\r\n                }).catch(function () {\r\n                    vue.has_success = false;\r\n                });\r\n            },\r\n            getNotificationLabel: function (type) {\r\n                if (type == 'all') {\r\n                    this.notification_to_message = 'This Notification will be send to all users';\r\n                }\r\n                else {\r\n                    this.notification_to_message = 'This Notification will be send to ' + type;\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Save Profile\r\n */\r\nif (typeof user !== 'undefined') {\r\n    new Vue({\r\n        el: '#profile-view',\r\n        data: {\r\n            form: new Form({\r\n                name: user.name,\r\n                last_name: user.last_name,\r\n                phone: user.phone,\r\n                address: user.address,\r\n                city: user.city,\r\n                state: '',\r\n                zip: user.zip,\r\n                _token: Laravel.csrfToken\r\n            }),\r\n            form_pass: new Form({\r\n                old_password: '',\r\n                new_password: '',\r\n                new_password_confirmation: '',\r\n                _token: Laravel.csrfToken\r\n            }),\r\n            has_success: true\r\n        },\r\n        methods: {\r\n            save: function () {\r\n                this.form.state = $('#profile_state').val();\r\n                var vue = this;\r\n                this.form.submit('/fantasy/store_profile').then(function (data) {\r\n                    vue.form.message = 'User profile updated.';\r\n                    vue.form.name = data.name;\r\n                    vue.form.last_name = data.last_name;\r\n                    vue.form.phone = data.phone;\r\n                    vue.form.address = data.address;\r\n                    vue.form.city = data.city;\r\n                    vue.form.state = data.state;\r\n                    vue.form.zip = data.zip;\r\n                    vue.has_success = true;\r\n                }).catch(function () {\r\n                    vue.has_success = false;\r\n                });\r\n            },\r\n            changePassword:function()\r\n            {\r\n                var vue = this;\r\n                this.form_pass.submit('/fantasy/user_change_password').then(function (data) {\r\n                    vue.form_pass.message = 'Your password was change successfully.';\r\n                    vue.has_success = true;\r\n                }).catch(function () {\r\n                    vue.has_success = false;\r\n                });\r\n            },\r\n            openPasswordModal: function () {\r\n                this.form_pass.reset();\r\n                $('#password_change_modal').modal('show');\r\n            },\r\n            is_password_valid: function () {\r\n               return (this.form_pass.old_password && this.form_pass.new_password!='' && (this.form_pass.new_password == this.form_pass.new_password_confirmation));\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n\r\n//Loads the correct sidebar on window load,\r\n//collapses the sidebar on window resize.\r\n// Sets the min-height of #page-wrapper to window size\r\n$(function () {\r\n    $(window).bind(\"load resize\", function () {\r\n        var topOffset = 50;\r\n        var width = (this.window.innerWidth > 0) ? this.window.innerWidth : this.screen.width;\r\n        if (width < 768) {\r\n            $('div.navbar-collapse').addClass('collapse');\r\n            topOffset = 100; // 2-row-menu\r\n        } else {\r\n            $('div.navbar-collapse').removeClass('collapse');\r\n        }\r\n\r\n        var height = ((this.window.innerHeight > 0) ? this.window.innerHeight : this.screen.height) - 1;\r\n        height = height - topOffset;\r\n        if (height < 1) height = 1;\r\n        if (height > topOffset) {\r\n            $(\"#page-wrapper\").css(\"min-height\", (height) + \"px\");\r\n        }\r\n    });\r\n    $('#side-menu').metisMenu();\r\n    var url = window.location;\r\n    var element = $('ul.nav a').filter(function () {\r\n        return this.href == url;\r\n    }).addClass('active').parent();\r\n    while (true) {\r\n        if (element.is('li')) {\r\n            element = element.parent().addClass('in').parent();\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n});\r\n\r\n"]}